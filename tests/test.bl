/*
enum_variants_to_string_list :: fn (TEnum: type #comptime) [enum_count(TEnum)]string_view #comptime {
	assert(is_enum(TEnum));
	tmp: [enum_count(TEnum)]string_view #noinit;
	info :: cast(*TypeInfoEnum) typeinfo(TEnum);
	loop i := 0; i < tmp.len; i += 1 {
		using std;
		name :: str_new(info.variants[i].name);
		str_lower(&name);
		str_replace_all(&name, '_', '-');

		tmp[i] = name;
	}
	return tmp;
}
*/

#import "libc"
#import "os/windows"

Any :: struct #compiler {
	type_info: *u8;
	data: *u8
};

_CRT_INIT :: fn () win32.BOOL #extern;
my_function :: fn (a: s32, b: s32, c: s32, d: s32, e: s32, f: s32) #extern;
add_numbers :: fn (a: s32, b: s32) s32 #extern;
print_number :: fn (n: s32) #extern;
print_number2 :: fn (n: s64) #extern;
print_string :: fn (len: s64, ptr: *u8) #extern;

my_number := 666;

__os_start :: fn () #entry {
	if _CRT_INIT() == 0 {
		C.exit(1);
	}

	print_number(my_number);

	// str :: "Hello from the BL compiled using custom backend!";
	// print_string(str.len, str.ptr);

	// print_number2(str.len);

	a := 10;
	b := 20;
	c := 30;
	d := 40;
	e := 50;
	f := 60;

	y := c + d;
	my_function(10, 20, 30, 40, 50, 60);
	my_function(10, 20, a + b, d, 50, d + b);
	my_function(a, b, c, d, e, f);

	print_number(add_numbers(10, 20));
	print_number(add_numbers(10, -20));
	print_number(mul_numbers(10, 20));

	use_global_number();

	C.exit(0);
}

mul_numbers :: fn (a: s32, b: s32) s32 {
	return a * b;
}

use_global_number :: fn () {
	print_number(my_number);
	my_number = 20;
	print_number(my_number);
}

/*
x64 todo:
[ ] struct variables
[ ] arrays
[ ] call-side register splits of bigger values
[ ] .data
[ ] type info
[ ] strings
[ ] thread locals
[ ] intrinsics
[ ] global variables

/*

BUG: Invalid ! precedence

if !settings.modal_ctrl && (mods & MOD_CONTROL) == MOD_CONTROL {
	control_pressed = true;
}

// To examples!!!
// To examples!!!
// To examples!!!

#import "std/fs"

text_file_to_stack :: fn (filename: string_view) string_view #comptime {
	using std;
	stream, open_err :: open_file(filename);
	defer close_file(&stream);
	if open_err {
		panic(open_err);
	}
	str := str_new();
	read_err :: read_string(&stream, &str);
	if read_err {
		panic(read_err);
	}
	return str;
}

DATA :: text_file_to_heap("data.txt");

main :: fn() s32 {
	print("%\n", DATA);
	return 0;
}


TODO:

- Infer type name of constant array initializers:
  FOO :: [2]Bar.{ .{ 10, 20 }, .{ 30, 40 } };

- !array => array.len == 0
- #comptime - automatically comptime evaluated in case all the arguments are compile-time known.
What about functions returning types?
- Invalid - operator precedence!
- Add blc --init="My Project" command.
- Nested functions ignore previous using statement in some cases.
- Consider application context vs thread context (i.e. temporary allocator is by default thread
local but application_context is not).
- Consider #import and #load to be limited only to the file scope.
- Allow creation of scoped constants in structure bodies:

	foo :: struct {
		THIS_IS_CONSTANT :: 10;

		number: s32;
	}

- Macros

	bar :: macro (v: s32) s32 {
		return v + 1;
	}

- Introduce calling conventions.
- Change syntax of default argument value assignment to ':'.
- Properly handle fail of ast_expr_lit_fn while generating recipe implementation.

- loop - else ?

	loop i := 0; i < arr.len; i += 1 {
		...
	} else {}

ENUM FLAGS:
- Allow direct | (or) composition of flags.
- Builtin support for checking if the flag is set?
- Replace all functionality of flags-related helper functions.

STATIC IF:

- Static if in other scopes.
- Fix static ifs.
- No scopes introduced by static ifs? But what about {}? Maybe C style is better?
- Struct declaration?
- Global scope?



COMPILE TIME EXECUTION:

- Use #run to mark function to be executed in compile time on the call side: '#run foo()'.
- Use #run to mark function executed only in compile time on the declaration side: 'foo :: fn ()
#run {}'.


POLYMORPH:

- Polymorp types cannot be easily identified; i.e. 'table_insert' should be something like this
'table_insert :: fn (tbl: *Table)' where 'Table' can be any polymorph type. However this is a bit
problematic due to the way how polymorph types are generated by compile-time funcitons...



NEW FEATURES

- Anonymous structs/unions?
- Disable function calls based on condition:

	trace_runtime :: fn () #enable_if IS_DEBUG == true {
		...
	}

- Module versions:

	dir: module@2.9.16
	dir: module@3.2.0

	#import "module"       // the latest one
	#import "module@2      // newest version 2.x.x
	#import "module@2.9    // newest version 2.9.x
	#import "module@3.2.0  // exact version
	#import "module@2+     // any >= 2.0.0
	#import "module@2.1+   // any 2.1.0, 2.1.1, 2.2.0 ...
	#import "module@2.9.0+ // any 2.9.0, 2.9.1, 2.9.2 ...


// To memory.bl???
bytes_to_value :: fn (TValue: type #comptime, bytes: []u8) TValue {
	tmp: TValue;
	assert(bytes.ptr);
	memcpy(auto &tmp, bytes.ptr, std.min(sizeof(TValue), auto bytes.len));
	return tmp;
}

BIG STUFF:

- Implement custom multithreaded linker for windows, lld is slow same as link.exe.

*/
