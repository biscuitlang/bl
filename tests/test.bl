/*
enum_variants_to_string_list :: fn (TEnum: type #comptime) [enum_count(TEnum)]string_view #comptime {
	assert(is_enum(TEnum));
	tmp: [enum_count(TEnum)]string_view #noinit;
	info :: cast(*TypeInfoEnum) typeinfo(TEnum);
	loop i := 0; i < tmp.len; i += 1 {
		using std;
		name :: str_new(info.variants[i].name);
		str_lower(&name);
		str_replace_all(&name, '_', '-');

		tmp[i] = name;
	}
	return tmp;
}
*/

// main :: fn () s32 {
// 	return 0;
// }

#import "libc"
#import "os/windows"

Any :: struct #compiler {
	type_info: *u8;
	data: *u8
};

CodeLocation :: struct #compiler {
	/// Full source file path.
	file: string_view;
	/// Line in the source file.
	line: s32;
	/// Name of the function.
	function: string_view;
	/// File and line combination hash.
	hash: u32;
}

string_view :: []u8;

_CRT_INIT :: fn () win32.BOOL #extern;
my_function :: fn (a: s32, b: s32, c: s32, d: s32, e: s32, f: s32) #extern;
add_numbers :: fn (a: s32, b: s32) s32 #extern;
print_number :: fn (n: s32) #extern;
print_number2 :: fn (n: s64) #extern;
print_address :: fn (v: u64) #extern;
print_string :: fn (len: s64, ptr: *u8) #extern;
assertion_message :: fn (len: s64, file: *u8, line: s32) #extern;

Foo :: struct {
	i: s32;
	j: s32;
}

Bar :: struct {
	i: s32;
	j: s32;
}

__os_start :: fn () #entry {
	if _CRT_INIT() == 0 {
		C.exit(1);
	}

	// test_global_slice();
	// test_string();
	// test_struct_members();
	// test_compounds();
	// test_function_calls();
	// use_global_number();
	// test_looping(10);
	// test_array_int();
	// test_array_ptr();
	// test_casting();
	// test_unop();
	// test_conditions();
	// test_condition_assign();
	// test_glob_addrof();
	// test_out_arg();
	// test_global_ptr_to_global();
	// test_global_compound();
	// test_fn_ptr();
	// test_glob_fn_ptr_in_compound();
	test_pass_string_to_function();

	done :: "------------\n!!! DONE !!!\n------------";
	print_string(done.len, done.ptr);
	C.exit(0);
}

assert :: fn (expr: bool, loc := #call_location) {
	if expr == false {
		assertion_message(loc.file.len, loc.file.ptr, loc.line);
	}
}

test_pass_string_to_function :: fn () {
	my_func :: fn (std: string_view) {
	};

	my_func("This is passed string!");
}

FOO_DATA :: 10;
FOO_DATA_PTR :: &FOO_DATA;

test_global_ptr_to_global :: fn () {
	assert(FOO_DATA_PTR);
	assert(@FOO_DATA_PTR == 10);
}

Doo :: struct {
	a: *s32;
}

DOO_DATA :: 10;
DOO :: Doo.{ a = &DOO_DATA };

test_global_compound :: fn () {
	assert(DOO.a);
	assert(@DOO.a == 10);
}

test_fn_ptr :: fn () {
	my_func :: fn () {
		good :: "NICE!\n";
		print_string(good.len, good.ptr);
	};

	ptr :: &my_func;
	ptr();
}

Goo :: struct {
	func_1: *fn();
	func_2: *fn();
}

goo_func_1 :: fn () {
	good :: "Hello from the function called from the globaly set pointer!\n";
	print_string(good.len, good.ptr);
}

goo_func_2 :: fn () {
	good :: "Hello from another the function called from the globaly set pointer!\n";
	print_string(good.len, good.ptr);
}

GOO :: Goo.{
	func_1 = &goo_func_1,
	func_2 = &goo_func_2
};

test_glob_fn_ptr_in_compound :: fn () {
	GOO.func_1();
	GOO.func_2();
}

test_out_arg :: fn () {
	update_arg :: fn (n: *s32) {
		@n = 10;
	};

	n := 0;
	update_arg(&n);
	assert(n == 10);

	update_arg2 :: fn (buf: *[]string_view) {
		buf.len = 20;
		buf.ptr = null;
	};

	buf: []string_view;
	update_arg2(&buf);
	assert(buf.len == 20);
	assert(!buf.ptr);
}

GLOBAL := 10;
test_glob_addrof :: fn () {
	addr :: &GLOBAL;
	assert(addr);
	assert(@addr == 10);
}

test_condition_assign :: fn () {
	v := 10;
	j := 20;
	n := v == j;
	assert(!n);
	n = v != j;
	assert(n);
	n = v < j;
	assert(n);
	n = v > j;
	assert(!n);
}

test_conditions :: fn () {
	good :: "OK!\n";
	bad :: "INVALID!\n";

	v := 10;
	j := 20;
	if v == j {
		print_string(bad.len, bad.ptr);
	} else {
		print_string(good.len, good.ptr);
	}

	if v != j {
		print_string(good.len, good.ptr);
	} else {
		print_string(bad.len, bad.ptr);
	}

	if v < j {
		print_string(good.len, good.ptr);
	} else {
		print_string(bad.len, bad.ptr);
	}

	if v > j {
		print_string(bad.len, bad.ptr);
	} else {
		print_string(good.len, good.ptr);
	}
}

test_unop :: fn () {
	good :: "OK!\n";

	{
		n := 10;
		m := -n;
		assert(m == -10);
		print_number(m);
	}

	b := false;
	if !b {
		print_string(good.len, good.ptr);
	} else {
		assert(false);
	}

	b = !b;
	if b {
		print_string(good.len, good.ptr);
	} else {
		assert(false);
	}
}

test_array_int :: fn () {
	arr: [4]s32;
	h : s64 = -100;
	print_number(auto h);

	arr[0] = 10;
	arr[1] = 20;
	arr[2] = 30;
	arr[3] = 40;
	assert(arr[0] == 10);
	assert(arr[1] == 20);
	assert(arr[2] == 30);
	assert(arr[3] == 40);

	n : s64 = 0;

	arr[n] = 100;
	n += 1;
	arr[n] = 200;
	n += 1;
	arr[n] = 300;
	n += 1;
	arr[n] = 400;

	assert(arr[0] == 100);
	assert(arr[1] == 200);
	assert(arr[2] == 300);
	assert(arr[3] == 400);

	print_number(arr[n]);
	print_number(arr[n] + 666);
}

test_array_ptr :: fn () {
	arr: []*s32;

	a, b, c, d, e, f: s32;
	// @Incomplete: Ocupy too much registers!
	arr_data :: [_]*s32.{ &a, &b, &c, &d, &e, &f };

	print_address(auto arr_data[0]);
	print_address(auto arr_data[1]);
	print_address(auto arr_data[2]);
	print_address(auto arr_data[3]);

	arr = arr_data;
	print_address(auto arr[0]);
	print_address(auto arr[1]);
	print_address(auto arr[2]);
	print_address(auto arr[3]);
}

command_line_arguments: []string_view;

test_global_slice :: fn () {
	command_line_arguments.len = 10;
	print_number2(command_line_arguments.len);

	my_len := 10;
	command_line_arguments.len = my_len;
	command_line_arguments.ptr = null;
	print_number2(command_line_arguments.len);
}

test_string :: fn () {
	str :: "Hello!!!\n";
	print_string(str.len, str.ptr);

	str2: string_view;
	str2 = str;
	print_string(str2.len, str2.ptr);
}

test_struct_members :: fn () {
	foo: Foo;
	foo.i = 10;
	foo.j = 20;
	print_number(foo.i + 30);
	print_number(foo.j);
}

test_compounds :: fn () {
	bar := Bar.{ j = 888, i = 999 };
	print_number(bar.i);
	print_number(bar.j);

	a := 10;
	b := 20;
	c := 30;

	bar = Bar.{ i = a, j = b + c };
	print_number(bar.i);
	print_number(bar.j);
}

test_slice :: fn () {
	martin := [_]s32.{ 10, 20, 30 };
	loop i := 0; i < martin.len; i += 1 {
		print_number(martin[i]);
	}
	martin_slice : []s32 = martin;
	print_number(martin_slice[0]);
	print_number(martin_slice[1]);
	print_number(martin_slice[2]);
	loop i := 0; i < martin.len; i += 1 {
		print_number(martin_slice[i]);
	}
}

test_casting :: fn () {
	{
		num :: -10;

		c: s8;
		c = cast(s8) num;
		print_number(auto c);

		w: s16;
		w = cast(s16) num;
		print_number(auto w);

		dw: s32;
		dw = cast(s32) num;
		print_number(auto dw);
	}
	{
		num : u32 = 10;

		c: u8;
		c = cast(u8) num;
		print_number(auto c);

		w: u16;
		w = cast(u16) num;
		print_number(auto w);

		dw: u32;
		dw = cast(u32) num;
		print_number(auto dw);

		qw: u64;
		qw = cast(u64) num;
	}
}

test_function_calls :: fn () {
	a := 10;
	b := 20;
	c := 30;
	d := 40;
	e := 50;
	f := 60;

	my_function(10, 20, 30, 40, 50, 60);
	my_function(10, 20, a + b, d, 50, d + b);
	my_function(a, b, c, d, e, f);

	print_number(add_numbers(10, 20));
	print_number(add_numbers(10, -20));
	print_number(mul_numbers(10, 20));
}

test_looping :: fn (n: s32) {
	loop i := 0; i < n; i += 1 {
		print_number(i);
	}
}

mul_numbers :: fn (a: s32, b: s32) s32 {
	return a * b;
}

my_number := 666;

use_global_number :: fn () {
	print_number(my_number);
	my_number = 20;
	print_number(my_number);
}

/*
x64 todo:
[ ] struct variables
[ ] arrays
[ ] call-side register splits of bigger values
[ ] .data
[ ] type info
[ ] strings
[ ] thread locals
[ ] intrinsics
[ ] global variables

/*

BUG: Invalid ! precedence

if !settings.modal_ctrl && (mods & MOD_CONTROL) == MOD_CONTROL {
	control_pressed = true;
}

// To examples!!!
// To examples!!!
// To examples!!!

#import "std/fs"

text_file_to_stack :: fn (filename: string_view) string_view #comptime {
	using std;
	stream, open_err :: open_file(filename);
	defer close_file(&stream);
	if open_err {
		panic(open_err);
	}
	str := str_new();
	read_err :: read_string(&stream, &str);
	if read_err {
		panic(read_err);
	}
	return str;
}

DATA :: text_file_to_heap("data.txt");

main :: fn() s32 {
	print("%\n", DATA);
	return 0;
}


TODO:

- Infer type name of constant array initializers:
  FOO :: [2]Bar.{ .{ 10, 20 }, .{ 30, 40 } };

- !array => array.len == 0
- #comptime - automatically comptime evaluated in case all the arguments are compile-time known.
What about functions returning types?
- Invalid - operator precedence!
- Add blc --init="My Project" command.
- Nested functions ignore previous using statement in some cases.
- Consider application context vs thread context (i.e. temporary allocator is by default thread
local but application_context is not).
- Consider #import and #load to be limited only to the file scope.
- Allow creation of scoped constants in structure bodies:

	foo :: struct {
		THIS_IS_CONSTANT :: 10;

		number: s32;
	}

- Macros

	bar :: macro (v: s32) s32 {
		return v + 1;
	}

- Introduce calling conventions.
- Change syntax of default argument value assignment to ':'.
- Properly handle fail of ast_expr_lit_fn while generating recipe implementation.

- loop - else ?

	loop i := 0; i < arr.len; i += 1 {
		...
	} else {}

ENUM FLAGS:
- Allow direct | (or) composition of flags.
- Builtin support for checking if the flag is set?
- Replace all functionality of flags-related helper functions.

STATIC IF:

- Static if in other scopes.
- Fix static ifs.
- No scopes introduced by static ifs? But what about {}? Maybe C style is better?
- Struct declaration?
- Global scope?



COMPILE TIME EXECUTION:

- Use #run to mark function to be executed in compile time on the call side: '#run foo()'.
- Use #run to mark function executed only in compile time on the declaration side: 'foo :: fn ()
#run {}'.


POLYMORPH:

- Polymorp types cannot be easily identified; i.e. 'table_insert' should be something like this
'table_insert :: fn (tbl: *Table)' where 'Table' can be any polymorph type. However this is a bit
problematic due to the way how polymorph types are generated by compile-time funcitons...



NEW FEATURES

- Anonymous structs/unions?
- Disable function calls based on condition:

	trace_runtime :: fn () #enable_if IS_DEBUG == true {
		...
	}

- Module versions:

	dir: module@2.9.16
	dir: module@3.2.0

	#import "module"       // the latest one
	#import "module@2      // newest version 2.x.x
	#import "module@2.9    // newest version 2.9.x
	#import "module@3.2.0  // exact version
	#import "module@2+     // any >= 2.0.0
	#import "module@2.1+   // any 2.1.0, 2.1.1, 2.2.0 ...
	#import "module@2.9.0+ // any 2.9.0, 2.9.1, 2.9.2 ...


// To memory.bl???
bytes_to_value :: fn (TValue: type #comptime, bytes: []u8) TValue {
	tmp: TValue;
	assert(bytes.ptr);
	memcpy(auto &tmp, bytes.ptr, std.min(sizeof(TValue), auto bytes.len));
	return tmp;
}

BIG STUFF:

- Implement custom multithreaded linker for windows, lld is slow same as link.exe.

*/
