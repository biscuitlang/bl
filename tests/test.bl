#import "std/print"

EntityBase :: struct {
	kind: EntityKind;

	position: s32;
	rotation: s32;
}

EntityKind :: enum {
	UNKNOWN;
	LIGHT = 1;
	NOTE  = 2;
}

Entity :: union #base EntityBase {
	light: Light #tag auto EntityKind.LIGHT;
	note:  Note  #tag auto EntityKind.NOTE;
}


Light :: struct #base EntityBase {
	color: s32;
}

Note :: struct #base EntityBase {
	text: string;
}

entity_type_to_kind :: fn (T: type #comptime) EntityKind #inline {
	T_info :: typeinfo(T);
	info   :: cast(*TypeInfoStruct) typeinfo(Entity);
	loop i := 0; i < info.members.len; i += 1 {
		if info.members[i].base_type == T_info then return auto info.members[i].tag;
	}

	panic();
	return EntityKind.UNKNOWN;
}

get_entity_typeinfo :: fn (entity: Entity) *TypeInfo {
	kind :: entity.base.kind;
	info :: cast(*TypeInfoStruct) typeinfo(entity);
	loop i := 0; i < info.members.len; i += 1 {
		if info.members[i].tag == auto kind then return info.members[i].base_type;
	}

	panic();
	return null;
}

entity_cast :: fn (T: type #comptime, e: *EntityBase) *T #inline {
	if !e then return null;
	if T == Entity then return auto e;
	if e.kind != entity_type_to_kind(T) then return null;
	return auto e;
}

main :: fn () s32 {

	a: Entity;
	a.kind = EntityKind.LIGHT;
	a.position = 10;

	light :: &a.light;
	light.color = 20;

	print("%\n", a);
	print("sizeof(Entity) = %\n", sizeof(Entity));
	print("sizeof(Light) = %\n", sizeof(Light));
	print("sizeof(Note) = %\n", sizeof(Note));
	print("sizeof(EntityBase) = %\n", sizeof(EntityBase));
	print("%\n", light);
	x :: entity_cast(Light, &a);
	print("%\n", @x);
	print("entity_type_to_kind(Light) = %\n", entity_type_to_kind(Light));
	print("entity_type_to_kind(Note)  = %\n", entity_type_to_kind(Note));

	return 0;
}
