//
// @Note 2025-03-23: This binding is incomplete. Feel free to add any missing stuff and open PR.
//

Window :: u8;
GLContext :: *u8;
WindowID :: u32;
Cursor :: u8;
KeyboardID :: u32;
MouseID :: u32;
Surface :: u8;
DisplayID :: u32;

HINT_VIDEO_DRIVER :: "SDL_VIDEO_DRIVER";
HINT_VIDEO_WAYLAND_PREFER_LIBDECOR :: "SDL_VIDEO_WAYLAND_PREFER_LIBDECOR";
HINT_MOUSE_RELATIVE_MODE_CENTER :: "SDL_MOUSE_RELATIVE_MODE_CENTER";

InitFlags :: u32;

INIT_AUDIO : InitFlags :      0x00000010;
INIT_VIDEO : InitFlags :      0x00000020;
INIT_JOYSTICK : InitFlags :   0x00000200;
INIT_HAPTIC : InitFlags :     0x00001000;
INIT_GAMEPAD : InitFlags :    0x00002000;
INIT_EVENTS : InitFlags :     0x00004000;
INIT_SENSOR : InitFlags :     0x00008000;
INIT_CAMERA : InitFlags :     0x00010000;

Rect :: struct {
	x: s32; y: s32;
	w: s32; h: s32;
}

WindowFlags :: u64;

WINDOW_FULLSCREEN : WindowFlags :           0x0000000000000001;
WINDOW_OPENGL : WindowFlags :               0x0000000000000002;
WINDOW_OCCLUDED : WindowFlags :             0x0000000000000004;
WINDOW_HIDDEN : WindowFlags :               0x0000000000000008;
WINDOW_BORDERLESS : WindowFlags :           0x0000000000000010;
WINDOW_RESIZABLE : WindowFlags :            0x0000000000000020;
WINDOW_MINIMIZED : WindowFlags :            0x0000000000000040;
WINDOW_MAXIMIZED : WindowFlags :            0x0000000000000080;
WINDOW_MOUSE_GRABBED : WindowFlags :        0x0000000000000100;
WINDOW_INPUT_FOCUS : WindowFlags :          0x0000000000000200;
WINDOW_MOUSE_FOCUS : WindowFlags :          0x0000000000000400;
WINDOW_EXTERNAL : WindowFlags :             0x0000000000000800;
WINDOW_MODAL : WindowFlags :                0x0000000000001000;
WINDOW_HIGH_PIXEL_DENSITY : WindowFlags :   0x0000000000002000;
WINDOW_MOUSE_CAPTURE : WindowFlags :        0x0000000000004000;
WINDOW_MOUSE_RELATIVE_MODE : WindowFlags :  0x0000000000008000;
WINDOW_ALWAYS_ON_TOP : WindowFlags :        0x0000000000010000;
WINDOW_UTILITY : WindowFlags :              0x0000000000020000;
WINDOW_TOOLTIP : WindowFlags :              0x0000000000040000;
WINDOW_POPUP_MENU : WindowFlags :           0x0000000000080000;
WINDOW_KEYBOARD_GRABBED : WindowFlags :     0x0000000000100000;
WINDOW_VULKAN : WindowFlags :               0x0000000010000000;
WINDOW_METAL : WindowFlags :                0x0000000020000000;
WINDOW_TRANSPARENT : WindowFlags :          0x0000000040000000;
WINDOW_NOT_FOCUSABLE : WindowFlags :        0x0000000080000000;

/**
* The SDL virtual key representation.
*
* Values of this type are used to represent keyboard keys using the current
* layout of the keyboard. These values include Unicode values representing
* the unmodified character that would be generated by pressing the key, or an
* `SDLK_*` constant for those keys that do not generate characters.
*
* A special exception is the number keys at the top of the keyboard which map
* to SDLK_0...SDLK_9 on AZERTY layouts.
*
* Keys with the `SDLK_EXTENDED_MASK` bit set do not map to a scancode or
* unicode code point.
*
* \since This datatype is available since SDL 3.2.0.
*/
Keycode :: u32;

K_EXTENDED_MASK : Keycode :          (1 << 29);
K_SCANCODE_MASK : Keycode :          (1 << 30);

SCANCODE_TO_KEYCODE :: fn (X: Scancode) Keycode #inline {
	return cast(u32) X | K_SCANCODE_MASK;
}

K_UNKNOWN : Keycode :                0x00000000; /**< 0 */
K_RETURN : Keycode :                 0x0000000d; /**< '\r' */
K_ESCAPE : Keycode :                 0x0000001b; /**< '\x1B' */
K_BACKSPACE : Keycode :              0x00000008; /**< '\b' */
K_TAB : Keycode :                    0x00000009; /**< '\t' */
K_SPACE : Keycode :                  0x00000020; /**< ' ' */
K_EXCLAIM : Keycode :                0x00000021; /**< '!' */
K_DBLAPOSTROPHE : Keycode :          0x00000022; /**< '"' */
K_HASH : Keycode :                   0x00000023; /**< '#' */
K_DOLLAR : Keycode :                 0x00000024; /**< '$' */
K_PERCENT : Keycode :                0x00000025; /**< '%' */
K_AMPERSAND : Keycode :              0x00000026; /**< '&' */
K_APOSTROPHE : Keycode :             0x00000027; /**< '\'' */
K_LEFTPAREN : Keycode :              0x00000028; /**< '(' */
K_RIGHTPAREN : Keycode :             0x00000029; /**< ')' */
K_ASTERISK : Keycode :               0x0000002a; /**< '*' */
K_PLUS : Keycode :                   0x0000002b; /**< '+' */
K_COMMA : Keycode :                  0x0000002c; /**< ',' */
K_MINUS : Keycode :                  0x0000002d; /**< '-' */
K_PERIOD : Keycode :                 0x0000002e; /**< '.' */
K_SLASH : Keycode :                  0x0000002f; /**< '/' */
K_0 : Keycode :                      0x00000030; /**< '0' */
K_1 : Keycode :                      0x00000031; /**< '1' */
K_2 : Keycode :                      0x00000032; /**< '2' */
K_3 : Keycode :                      0x00000033; /**< '3' */
K_4 : Keycode :                      0x00000034; /**< '4' */
K_5 : Keycode :                      0x00000035; /**< '5' */
K_6 : Keycode :                      0x00000036; /**< '6' */
K_7 : Keycode :                      0x00000037; /**< '7' */
K_8 : Keycode :                      0x00000038; /**< '8' */
K_9 : Keycode :                      0x00000039; /**< '9' */
K_COLON : Keycode :                  0x0000003a; /**< ':' */
K_SEMICOLON : Keycode :              0x0000003b; /**< ';' */
K_LESS : Keycode :                   0x0000003c; /**< '<' */
K_EQUALS : Keycode :                 0x0000003d; /**< '=' */
K_GREATER : Keycode :                0x0000003e; /**< '>' */
K_QUESTION : Keycode :               0x0000003f; /**< '?' */
K_AT : Keycode :                     0x00000040; /**< '@' */
K_LEFTBRACKET : Keycode :            0x0000005b; /**< '[' */
K_BACKSLASH : Keycode :              0x0000005c; /**< '\\' */
K_RIGHTBRACKET : Keycode :           0x0000005d; /**< ']' */
K_CARET : Keycode :                  0x0000005e; /**< '^' */
K_UNDERSCORE : Keycode :             0x0000005f; /**< '_' */
K_GRAVE : Keycode :                  0x00000060; /**< '`' */
K_A : Keycode :                      0x00000061; /**< 'a' */
K_B : Keycode :                      0x00000062; /**< 'b' */
K_C : Keycode :                      0x00000063; /**< 'c' */
K_D : Keycode :                      0x00000064; /**< 'd' */
K_E : Keycode :                      0x00000065; /**< 'e' */
K_F : Keycode :                      0x00000066; /**< 'f' */
K_G : Keycode :                      0x00000067; /**< 'g' */
K_H : Keycode :                      0x00000068; /**< 'h' */
K_I : Keycode :                      0x00000069; /**< 'i' */
K_J : Keycode :                      0x0000006a; /**< 'j' */
K_K : Keycode :                      0x0000006b; /**< 'k' */
K_L : Keycode :                      0x0000006c; /**< 'l' */
K_M : Keycode :                      0x0000006d; /**< 'm' */
K_N : Keycode :                      0x0000006e; /**< 'n' */
K_O : Keycode :                      0x0000006f; /**< 'o' */
K_P : Keycode :                      0x00000070; /**< 'p' */
K_Q : Keycode :                      0x00000071; /**< 'q' */
K_R : Keycode :                      0x00000072; /**< 'r' */
K_S : Keycode :                      0x00000073; /**< 's' */
K_T : Keycode :                      0x00000074; /**< 't' */
K_U : Keycode :                      0x00000075; /**< 'u' */
K_V : Keycode :                      0x00000076; /**< 'v' */
K_W : Keycode :                      0x00000077; /**< 'w' */
K_X : Keycode :                      0x00000078; /**< 'x' */
K_Y : Keycode :                      0x00000079; /**< 'y' */
K_Z : Keycode :                      0x0000007a; /**< 'z' */
K_LEFTBRACE : Keycode :              0x0000007b; /**< '{' */
K_PIPE : Keycode :                   0x0000007c; /**< '|' */
K_RIGHTBRACE : Keycode :             0x0000007d; /**< '}' */
K_TILDE : Keycode :                  0x0000007e; /**< '~' */
K_DELETE : Keycode :                 0x0000007f; /**< '\x7F' */
K_PLUSMINUS : Keycode :              0x000000b1; /**< '\xB1' */
K_CAPSLOCK : Keycode :               0x40000039; /**< SCANCODE_TO_KEYCODE(SCANCODE_CAPSLOCK) */
K_F1 : Keycode :                     0x4000003a; /**< SCANCODE_TO_KEYCODE(SCANCODE_F1) */
K_F2 : Keycode :                     0x4000003b; /**< SCANCODE_TO_KEYCODE(SCANCODE_F2) */
K_F3 : Keycode :                     0x4000003c; /**< SCANCODE_TO_KEYCODE(SCANCODE_F3) */
K_F4 : Keycode :                     0x4000003d; /**< SCANCODE_TO_KEYCODE(SCANCODE_F4) */
K_F5 : Keycode :                     0x4000003e; /**< SCANCODE_TO_KEYCODE(SCANCODE_F5) */
K_F6 : Keycode :                     0x4000003f; /**< SCANCODE_TO_KEYCODE(SCANCODE_F6) */
K_F7 : Keycode :                     0x40000040; /**< SCANCODE_TO_KEYCODE(SCANCODE_F7) */
K_F8 : Keycode :                     0x40000041; /**< SCANCODE_TO_KEYCODE(SCANCODE_F8) */
K_F9 : Keycode :                     0x40000042; /**< SCANCODE_TO_KEYCODE(SCANCODE_F9) */
K_F10 : Keycode :                    0x40000043; /**< SCANCODE_TO_KEYCODE(SCANCODE_F10) */
K_F11 : Keycode :                    0x40000044; /**< SCANCODE_TO_KEYCODE(SCANCODE_F11) */
K_F12 : Keycode :                    0x40000045; /**< SCANCODE_TO_KEYCODE(SCANCODE_F12) */
K_PRINTSCREEN : Keycode :            0x40000046; /**< SCANCODE_TO_KEYCODE(SCANCODE_PRINTSCREEN) */
K_SCROLLLOCK : Keycode :             0x40000047; /**< SCANCODE_TO_KEYCODE(SCANCODE_SCROLLLOCK) */
K_PAUSE : Keycode :                  0x40000048; /**< SCANCODE_TO_KEYCODE(SCANCODE_PAUSE) */
K_INSERT : Keycode :                 0x40000049; /**< SCANCODE_TO_KEYCODE(SCANCODE_INSERT) */
K_HOME : Keycode :                   0x4000004a; /**< SCANCODE_TO_KEYCODE(SCANCODE_HOME) */
K_PAGEUP : Keycode :                 0x4000004b; /**< SCANCODE_TO_KEYCODE(SCANCODE_PAGEUP) */
K_END : Keycode :                    0x4000004d; /**< SCANCODE_TO_KEYCODE(SCANCODE_END) */
K_PAGEDOWN : Keycode :               0x4000004e; /**< SCANCODE_TO_KEYCODE(SCANCODE_PAGEDOWN) */
K_RIGHT : Keycode :                  0x4000004f; /**< SCANCODE_TO_KEYCODE(SCANCODE_RIGHT) */
K_LEFT : Keycode :                   0x40000050; /**< SCANCODE_TO_KEYCODE(SCANCODE_LEFT) */
K_DOWN : Keycode :                   0x40000051; /**< SCANCODE_TO_KEYCODE(SCANCODE_DOWN) */
K_UP : Keycode :                     0x40000052; /**< SCANCODE_TO_KEYCODE(SCANCODE_UP) */
K_NUMLOCKCLEAR : Keycode :           0x40000053; /**< SCANCODE_TO_KEYCODE(SCANCODE_NUMLOCKCLEAR) */
K_KP_DIVIDE : Keycode :              0x40000054; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_DIVIDE) */
K_KP_MULTIPLY : Keycode :            0x40000055; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_MULTIPLY) */
K_KP_MINUS : Keycode :               0x40000056; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_MINUS) */
K_KP_PLUS : Keycode :                0x40000057; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_PLUS) */
K_KP_ENTER : Keycode :               0x40000058; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_ENTER) */
K_KP_1 : Keycode :                   0x40000059; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_1) */
K_KP_2 : Keycode :                   0x4000005a; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_2) */
K_KP_3 : Keycode :                   0x4000005b; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_3) */
K_KP_4 : Keycode :                   0x4000005c; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_4) */
K_KP_5 : Keycode :                   0x4000005d; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_5) */
K_KP_6 : Keycode :                   0x4000005e; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_6) */
K_KP_7 : Keycode :                   0x4000005f; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_7) */
K_KP_8 : Keycode :                   0x40000060; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_8) */
K_KP_9 : Keycode :                   0x40000061; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_9) */
K_KP_0 : Keycode :                   0x40000062; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_0) */
K_KP_PERIOD : Keycode :              0x40000063; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_PERIOD) */
K_APPLICATION : Keycode :            0x40000065; /**< SCANCODE_TO_KEYCODE(SCANCODE_APPLICATION) */
K_POWER : Keycode :                  0x40000066; /**< SCANCODE_TO_KEYCODE(SCANCODE_POWER) */
K_KP_EQUALS : Keycode :              0x40000067; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_EQUALS) */
K_F13 : Keycode :                    0x40000068; /**< SCANCODE_TO_KEYCODE(SCANCODE_F13) */
K_F14 : Keycode :                    0x40000069; /**< SCANCODE_TO_KEYCODE(SCANCODE_F14) */
K_F15 : Keycode :                    0x4000006a; /**< SCANCODE_TO_KEYCODE(SCANCODE_F15) */
K_F16 : Keycode :                    0x4000006b; /**< SCANCODE_TO_KEYCODE(SCANCODE_F16) */
K_F17 : Keycode :                    0x4000006c; /**< SCANCODE_TO_KEYCODE(SCANCODE_F17) */
K_F18 : Keycode :                    0x4000006d; /**< SCANCODE_TO_KEYCODE(SCANCODE_F18) */
K_F19 : Keycode :                    0x4000006e; /**< SCANCODE_TO_KEYCODE(SCANCODE_F19) */
K_F20 : Keycode :                    0x4000006f; /**< SCANCODE_TO_KEYCODE(SCANCODE_F20) */
K_F21 : Keycode :                    0x40000070; /**< SCANCODE_TO_KEYCODE(SCANCODE_F21) */
K_F22 : Keycode :                    0x40000071; /**< SCANCODE_TO_KEYCODE(SCANCODE_F22) */
K_F23 : Keycode :                    0x40000072; /**< SCANCODE_TO_KEYCODE(SCANCODE_F23) */
K_F24 : Keycode :                    0x40000073; /**< SCANCODE_TO_KEYCODE(SCANCODE_F24) */
K_EXECUTE : Keycode :                0x40000074; /**< SCANCODE_TO_KEYCODE(SCANCODE_EXECUTE) */
K_HELP : Keycode :                   0x40000075; /**< SCANCODE_TO_KEYCODE(SCANCODE_HELP) */
K_MENU : Keycode :                   0x40000076; /**< SCANCODE_TO_KEYCODE(SCANCODE_MENU) */
K_SELECT : Keycode :                 0x40000077; /**< SCANCODE_TO_KEYCODE(SCANCODE_SELECT) */
K_STOP : Keycode :                   0x40000078; /**< SCANCODE_TO_KEYCODE(SCANCODE_STOP) */
K_AGAIN : Keycode :                  0x40000079; /**< SCANCODE_TO_KEYCODE(SCANCODE_AGAIN) */
K_UNDO : Keycode :                   0x4000007a; /**< SCANCODE_TO_KEYCODE(SCANCODE_UNDO) */
K_CUT : Keycode :                    0x4000007b; /**< SCANCODE_TO_KEYCODE(SCANCODE_CUT) */
K_COPY : Keycode :                   0x4000007c; /**< SCANCODE_TO_KEYCODE(SCANCODE_COPY) */
K_PASTE : Keycode :                  0x4000007d; /**< SCANCODE_TO_KEYCODE(SCANCODE_PASTE) */
K_FIND : Keycode :                   0x4000007e; /**< SCANCODE_TO_KEYCODE(SCANCODE_FIND) */
K_MUTE : Keycode :                   0x4000007f; /**< SCANCODE_TO_KEYCODE(SCANCODE_MUTE) */
K_VOLUMEUP : Keycode :               0x40000080; /**< SCANCODE_TO_KEYCODE(SCANCODE_VOLUMEUP) */
K_VOLUMEDOWN : Keycode :             0x40000081; /**< SCANCODE_TO_KEYCODE(SCANCODE_VOLUMEDOWN) */
K_KP_COMMA : Keycode :               0x40000085; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_COMMA) */
K_KP_EQUALSAS400 : Keycode :         0x40000086; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_EQUALSAS400) */
K_ALTERASE : Keycode :               0x40000099; /**< SCANCODE_TO_KEYCODE(SCANCODE_ALTERASE) */
K_SYSREQ : Keycode :                 0x4000009a; /**< SCANCODE_TO_KEYCODE(SCANCODE_SYSREQ) */
K_CANCEL : Keycode :                 0x4000009b; /**< SCANCODE_TO_KEYCODE(SCANCODE_CANCEL) */
K_CLEAR : Keycode :                  0x4000009c; /**< SCANCODE_TO_KEYCODE(SCANCODE_CLEAR) */
K_PRIOR : Keycode :                  0x4000009d; /**< SCANCODE_TO_KEYCODE(SCANCODE_PRIOR) */
K_RETURN2 : Keycode :                0x4000009e; /**< SCANCODE_TO_KEYCODE(SCANCODE_RETURN2) */
K_SEPARATOR : Keycode :              0x4000009f; /**< SCANCODE_TO_KEYCODE(SCANCODE_SEPARATOR) */
K_OUT : Keycode :                    0x400000a0; /**< SCANCODE_TO_KEYCODE(SCANCODE_OUT) */
K_OPER : Keycode :                   0x400000a1; /**< SCANCODE_TO_KEYCODE(SCANCODE_OPER) */
K_CLEARAGAIN : Keycode :             0x400000a2; /**< SCANCODE_TO_KEYCODE(SCANCODE_CLEARAGAIN) */
K_CRSEL : Keycode :                  0x400000a3; /**< SCANCODE_TO_KEYCODE(SCANCODE_CRSEL) */
K_EXSEL : Keycode :                  0x400000a4; /**< SCANCODE_TO_KEYCODE(SCANCODE_EXSEL) */
K_KP_00 : Keycode :                  0x400000b0; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_00) */
K_KP_000 : Keycode :                 0x400000b1; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_000) */
K_THOUSANDSSEPARATOR : Keycode :     0x400000b2; /**< SCANCODE_TO_KEYCODE(SCANCODE_THOUSANDSSEPARATOR) */
K_DECIMALSEPARATOR : Keycode :       0x400000b3; /**< SCANCODE_TO_KEYCODE(SCANCODE_DECIMALSEPARATOR) */
K_CURRENCYUNIT : Keycode :           0x400000b4; /**< SCANCODE_TO_KEYCODE(SCANCODE_CURRENCYUNIT) */
K_CURRENCYSUBUNIT : Keycode :        0x400000b5; /**< SCANCODE_TO_KEYCODE(SCANCODE_CURRENCYSUBUNIT) */
K_KP_LEFTPAREN : Keycode :           0x400000b6; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_LEFTPAREN) */
K_KP_RIGHTPAREN : Keycode :          0x400000b7; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_RIGHTPAREN) */
K_KP_LEFTBRACE : Keycode :           0x400000b8; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_LEFTBRACE) */
K_KP_RIGHTBRACE : Keycode :          0x400000b9; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_RIGHTBRACE) */
K_KP_TAB : Keycode :                 0x400000ba; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_TAB) */
K_KP_BACKSPACE : Keycode :           0x400000bb; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_BACKSPACE) */
K_KP_A : Keycode :                   0x400000bc; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_A) */
K_KP_B : Keycode :                   0x400000bd; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_B) */
K_KP_C : Keycode :                   0x400000be; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_C) */
K_KP_D : Keycode :                   0x400000bf; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_D) */
K_KP_E : Keycode :                   0x400000c0; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_E) */
K_KP_F : Keycode :                   0x400000c1; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_F) */
K_KP_XOR : Keycode :                 0x400000c2; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_XOR) */
K_KP_POWER : Keycode :               0x400000c3; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_POWER) */
K_KP_PERCENT : Keycode :             0x400000c4; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_PERCENT) */
K_KP_LESS : Keycode :                0x400000c5; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_LESS) */
K_KP_GREATER : Keycode :             0x400000c6; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_GREATER) */
K_KP_AMPERSAND : Keycode :           0x400000c7; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_AMPERSAND) */
K_KP_DBLAMPERSAND : Keycode :        0x400000c8; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_DBLAMPERSAND) */
K_KP_VERTICALBAR : Keycode :         0x400000c9; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_VERTICALBAR) */
K_KP_DBLVERTICALBAR : Keycode :      0x400000ca; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_DBLVERTICALBAR) */
K_KP_COLON : Keycode :               0x400000cb; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_COLON) */
K_KP_HASH : Keycode :                0x400000cc; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_HASH) */
K_KP_SPACE : Keycode :               0x400000cd; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_SPACE) */
K_KP_AT : Keycode :                  0x400000ce; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_AT) */
K_KP_EXCLAM : Keycode :              0x400000cf; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_EXCLAM) */
K_KP_MEMSTORE : Keycode :            0x400000d0; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_MEMSTORE) */
K_KP_MEMRECALL : Keycode :           0x400000d1; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_MEMRECALL) */
K_KP_MEMCLEAR : Keycode :            0x400000d2; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_MEMCLEAR) */
K_KP_MEMADD : Keycode :              0x400000d3; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_MEMADD) */
K_KP_MEMSUBTRACT : Keycode :         0x400000d4; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_MEMSUBTRACT) */
K_KP_MEMMULTIPLY : Keycode :         0x400000d5; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_MEMMULTIPLY) */
K_KP_MEMDIVIDE : Keycode :           0x400000d6; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_MEMDIVIDE) */
K_KP_PLUSMINUS : Keycode :           0x400000d7; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_PLUSMINUS) */
K_KP_CLEAR : Keycode :               0x400000d8; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_CLEAR) */
K_KP_CLEARENTRY : Keycode :          0x400000d9; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_CLEARENTRY) */
K_KP_BINARY : Keycode :              0x400000da; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_BINARY) */
K_KP_OCTAL : Keycode :               0x400000db; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_OCTAL) */
K_KP_DECIMAL : Keycode :             0x400000dc; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_DECIMAL) */
K_KP_HEXADECIMAL : Keycode :         0x400000dd; /**< SCANCODE_TO_KEYCODE(SCANCODE_KP_HEXADECIMAL) */
K_LCTRL : Keycode :                  0x400000e0; /**< SCANCODE_TO_KEYCODE(SCANCODE_LCTRL) */
K_LSHIFT : Keycode :                 0x400000e1; /**< SCANCODE_TO_KEYCODE(SCANCODE_LSHIFT) */
K_LALT : Keycode :                   0x400000e2; /**< SCANCODE_TO_KEYCODE(SCANCODE_LALT) */
K_LGUI : Keycode :                   0x400000e3; /**< SCANCODE_TO_KEYCODE(SCANCODE_LGUI) */
K_RCTRL : Keycode :                  0x400000e4; /**< SCANCODE_TO_KEYCODE(SCANCODE_RCTRL) */
K_RSHIFT : Keycode :                 0x400000e5; /**< SCANCODE_TO_KEYCODE(SCANCODE_RSHIFT) */
K_RALT : Keycode :                   0x400000e6; /**< SCANCODE_TO_KEYCODE(SCANCODE_RALT) */
K_RGUI : Keycode :                   0x400000e7; /**< SCANCODE_TO_KEYCODE(SCANCODE_RGUI) */
K_MODE : Keycode :                   0x40000101; /**< SCANCODE_TO_KEYCODE(SCANCODE_MODE) */
K_SLEEP : Keycode :                  0x40000102; /**< SCANCODE_TO_KEYCODE(SCANCODE_SLEEP) */
K_WAKE : Keycode :                   0x40000103; /**< SCANCODE_TO_KEYCODE(SCANCODE_WAKE) */
K_CHANNEL_INCREMENT : Keycode :      0x40000104; /**< SCANCODE_TO_KEYCODE(SCANCODE_CHANNEL_INCREMENT) */
K_CHANNEL_DECREMENT : Keycode :      0x40000105; /**< SCANCODE_TO_KEYCODE(SCANCODE_CHANNEL_DECREMENT) */
K_MEDIA_PLAY : Keycode :             0x40000106; /**< SCANCODE_TO_KEYCODE(SCANCODE_MEDIA_PLAY) */
K_MEDIA_PAUSE : Keycode :            0x40000107; /**< SCANCODE_TO_KEYCODE(SCANCODE_MEDIA_PAUSE) */
K_MEDIA_RECORD : Keycode :           0x40000108; /**< SCANCODE_TO_KEYCODE(SCANCODE_MEDIA_RECORD) */
K_MEDIA_FAST_FORWARD : Keycode :     0x40000109; /**< SCANCODE_TO_KEYCODE(SCANCODE_MEDIA_FAST_FORWARD) */
K_MEDIA_REWIND : Keycode :           0x4000010a; /**< SCANCODE_TO_KEYCODE(SCANCODE_MEDIA_REWIND) */
K_MEDIA_NEXT_TRACK : Keycode :       0x4000010b; /**< SCANCODE_TO_KEYCODE(SCANCODE_MEDIA_NEXT_TRACK) */
K_MEDIA_PREVIOUS_TRACK : Keycode :   0x4000010c; /**< SCANCODE_TO_KEYCODE(SCANCODE_MEDIA_PREVIOUS_TRACK) */
K_MEDIA_STOP : Keycode :             0x4000010d; /**< SCANCODE_TO_KEYCODE(SCANCODE_MEDIA_STOP) */
K_MEDIA_EJECT : Keycode :            0x4000010e; /**< SCANCODE_TO_KEYCODE(SCANCODE_MEDIA_EJECT) */
K_MEDIA_PLAY_PAUSE : Keycode :       0x4000010f; /**< SCANCODE_TO_KEYCODE(SCANCODE_MEDIA_PLAY_PAUSE) */
K_MEDIA_SELECT : Keycode :           0x40000110; /**< SCANCODE_TO_KEYCODE(SCANCODE_MEDIA_SELECT) */
K_AC_NEW : Keycode :                 0x40000111; /**< SCANCODE_TO_KEYCODE(SCANCODE_AC_NEW) */
K_AC_OPEN : Keycode :                0x40000112; /**< SCANCODE_TO_KEYCODE(SCANCODE_AC_OPEN) */
K_AC_CLOSE : Keycode :               0x40000113; /**< SCANCODE_TO_KEYCODE(SCANCODE_AC_CLOSE) */
K_AC_EXIT : Keycode :                0x40000114; /**< SCANCODE_TO_KEYCODE(SCANCODE_AC_EXIT) */
K_AC_SAVE : Keycode :                0x40000115; /**< SCANCODE_TO_KEYCODE(SCANCODE_AC_SAVE) */
K_AC_PRINT : Keycode :               0x40000116; /**< SCANCODE_TO_KEYCODE(SCANCODE_AC_PRINT) */
K_AC_PROPERTIES : Keycode :          0x40000117; /**< SCANCODE_TO_KEYCODE(SCANCODE_AC_PROPERTIES) */
K_AC_SEARCH : Keycode :              0x40000118; /**< SCANCODE_TO_KEYCODE(SCANCODE_AC_SEARCH) */
K_AC_HOME : Keycode :                0x40000119; /**< SCANCODE_TO_KEYCODE(SCANCODE_AC_HOME) */
K_AC_BACK : Keycode :                0x4000011a; /**< SCANCODE_TO_KEYCODE(SCANCODE_AC_BACK) */
K_AC_FORWARD : Keycode :             0x4000011b; /**< SCANCODE_TO_KEYCODE(SCANCODE_AC_FORWARD) */
K_AC_STOP : Keycode :                0x4000011c; /**< SCANCODE_TO_KEYCODE(SCANCODE_AC_STOP) */
K_AC_REFRESH : Keycode :             0x4000011d; /**< SCANCODE_TO_KEYCODE(SCANCODE_AC_REFRESH) */
K_AC_BOOKMARKS : Keycode :           0x4000011e; /**< SCANCODE_TO_KEYCODE(SCANCODE_AC_BOOKMARKS) */
K_SOFTLEFT : Keycode :               0x4000011f; /**< SCANCODE_TO_KEYCODE(SCANCODE_SOFTLEFT) */
K_SOFTRIGHT : Keycode :              0x40000120; /**< SCANCODE_TO_KEYCODE(SCANCODE_SOFTRIGHT) */
K_CALL : Keycode :                   0x40000121; /**< SCANCODE_TO_KEYCODE(SCANCODE_CALL) */
K_ENDCALL : Keycode :                0x40000122; /**< SCANCODE_TO_KEYCODE(SCANCODE_ENDCALL) */
K_LEFT_TAB : Keycode :               0x20000001; /**< Extended key Left Tab */
K_LEVEL5_SHIFT : Keycode :           0x20000002; /**< Extended key Level 5 Shift */
K_MULTI_KEY_COMPOSE : Keycode :      0x20000003; /**< Extended key Multi-key Compose */
K_LMETA : Keycode :                  0x20000004; /**< Extended key Left Meta */
K_RMETA : Keycode :                  0x20000005; /**< Extended key Right Meta */
K_LHYPER : Keycode :                 0x20000006; /**< Extended key Left Hyper */
K_RHYPER : Keycode :                 0x20000007; /**< Extended key Right Hyper */

/**
* Valid key modifiers (possibly OR'd together).
*
* \since This datatype is available since SDL 3.2.0.
*/
Keymod :: u16;

KMOD_NONE : Keymod :   0x0000; /**< no modifier is applicable. */
KMOD_LSHIFT : Keymod : 0x0001; /**< the left Shift key is down. */
KMOD_RSHIFT : Keymod : 0x0002; /**< the right Shift key is down. */
KMOD_LEVEL5 : Keymod : 0x0004; /**< the Level 5 Shift key is down. */
KMOD_LCTRL : Keymod :  0x0040; /**< the left Ctrl (Control) key is down. */
KMOD_RCTRL : Keymod :  0x0080; /**< the right Ctrl (Control) key is down. */
KMOD_LALT : Keymod :   0x0100; /**< the left Alt key is down. */
KMOD_RALT : Keymod :   0x0200; /**< the right Alt key is down. */
KMOD_LGUI : Keymod :   0x0400; /**< the left GUI key (often the Windows key) is down. */
KMOD_RGUI : Keymod :   0x0800; /**< the right GUI key (often the Windows key) is down. */
KMOD_NUM : Keymod :    0x1000; /**< the Num Lock key (may be located on an extended keypad) is down. */
KMOD_CAPS : Keymod :   0x2000; /**< the Caps Lock key is down. */
KMOD_MODE : Keymod :   0x4000; /**< the !AltGr key is down. */
KMOD_SCROLL : Keymod : 0x8000; /**< the Scroll Lock key is down. */
KMOD_CTRL  :: (KMOD_LCTRL | KMOD_RCTRL);   /**< Any Ctrl key is down. */
KMOD_SHIFT :: (KMOD_LSHIFT | KMOD_RSHIFT); /**< Any Shift key is down. */
KMOD_ALT   :: (KMOD_LALT | KMOD_RALT);     /**< Any Alt key is down. */
KMOD_GUI   :: (KMOD_LGUI | KMOD_RGUI);     /**< Any GUI key is down. */


/**
* The SDL keyboard scancode representation.
*
* An SDL scancode is the physical representation of a key on the keyboard,
* independent of language and keyboard mapping.
*
* Values of this type are used to represent keyboard keys, among other places
* in the `scancode` field of the SDL_KeyboardEvent structure.
*
* The values in this enumeration are based on the USB usage page standard:
* https://usb.org/sites/default/files/hut1_5.pdf
*
* \since This enum is available since SDL 3.2.0.
*/
Scancode :: enum u32 {
	SCANCODE_UNKNOWN = 0;

	/**
	*  \name Usage page 0x07
	*
	*  These values are from usage page 0x07 (USB keyboard page).
	*/
	/* @{ */

	SCANCODE_A = 4;
	SCANCODE_B = 5;
	SCANCODE_C = 6;
	SCANCODE_D = 7;
	SCANCODE_E = 8;
	SCANCODE_F = 9;
	SCANCODE_G = 10;
	SCANCODE_H = 11;
	SCANCODE_I = 12;
	SCANCODE_J = 13;
	SCANCODE_K = 14;
	SCANCODE_L = 15;
	SCANCODE_M = 16;
	SCANCODE_N = 17;
	SCANCODE_O = 18;
	SCANCODE_P = 19;
	SCANCODE_Q = 20;
	SCANCODE_R = 21;
	SCANCODE_S = 22;
	SCANCODE_T = 23;
	SCANCODE_U = 24;
	SCANCODE_V = 25;
	SCANCODE_W = 26;
	SCANCODE_X = 27;
	SCANCODE_Y = 28;
	SCANCODE_Z = 29;

	SCANCODE_1 = 30;
	SCANCODE_2 = 31;
	SCANCODE_3 = 32;
	SCANCODE_4 = 33;
	SCANCODE_5 = 34;
	SCANCODE_6 = 35;
	SCANCODE_7 = 36;
	SCANCODE_8 = 37;
	SCANCODE_9 = 38;
	SCANCODE_0 = 39;

	SCANCODE_RETURN = 40;
	SCANCODE_ESCAPE = 41;
	SCANCODE_BACKSPACE = 42;
	SCANCODE_TAB = 43;
	SCANCODE_SPACE = 44;

	SCANCODE_MINUS = 45;
	SCANCODE_EQUALS = 46;
	SCANCODE_LEFTBRACKET = 47;
	SCANCODE_RIGHTBRACKET = 48;
	SCANCODE_BACKSLASH = 49; /**< Located at the lower left of the return
	*   key on ISO keyboards and at the right end
	*   of the QWERTY row on ANSI keyboards.
	*   Produces REVERSE SOLIDUS (backslash) and
	*   VERTICAL LINE in a US layout, REVERSE
	*   SOLIDUS and VERTICAL LINE in a UK Mac
	*   layout, NUMBER SIGN and TILDE in a UK
	*   Windows layout, DOLLAR SIGN and POUND SIGN
	*   in a Swiss German layout, NUMBER SIGN and
	*   APOSTROPHE in a German layout, GRAVE
	*   ACCENT and POUND SIGN in a French Mac
	*   layout, and ASTERISK and MICRO SIGN in a
	*   French Windows layout.
	*/
	SCANCODE_NONUSHASH = 50; /**< ISO USB keyboards actually use this code
	*   instead of 49 for the same key, but all
	*   OSes I've seen treat the two codes
	*   identically. So, as an implementor, unless
	*   your keyboard generates both of those
	*   codes and your OS treats them differently,
	*   you should generate SDL_SCANCODE_BACKSLASH
	*   instead of this code. As a user, you
	*   should not rely on this code because SDL
	*   will never generate it with most (all?)
	*   keyboards.
	*/
	SCANCODE_SEMICOLON = 51;
	SCANCODE_APOSTROPHE = 52;
	SCANCODE_GRAVE = 53; /**< Located in the top left corner (on both ANSI
	*   and ISO keyboards). Produces GRAVE ACCENT and
	*   TILDE in a US Windows layout and in US and UK
	*   Mac layouts on ANSI keyboards, GRAVE ACCENT
	*   and NOT SIGN in a UK Windows layout, SECTION
	*   SIGN and PLUS-MINUS SIGN in US and UK Mac
	*   layouts on ISO keyboards, SECTION SIGN and
	*   DEGREE SIGN in a Swiss German layout (Mac:
	*   only on ISO keyboards), CIRCUMFLEX ACCENT and
	*   DEGREE SIGN in a German layout (Mac: only on
	*   ISO keyboards), SUPERSCRIPT TWO and TILDE in a
	*   French Windows layout, COMMERCIAL AT and
	*   NUMBER SIGN in a French Mac layout on ISO
	*   keyboards, and LESS-THAN SIGN and GREATER-THAN
	*   SIGN in a Swiss German, German, or French Mac
	*   layout on ANSI keyboards.
	*/
	SCANCODE_COMMA = 54;
	SCANCODE_PERIOD = 55;
	SCANCODE_SLASH = 56;

	SCANCODE_CAPSLOCK = 57;

	SCANCODE_F1 = 58;
	SCANCODE_F2 = 59;
	SCANCODE_F3 = 60;
	SCANCODE_F4 = 61;
	SCANCODE_F5 = 62;
	SCANCODE_F6 = 63;
	SCANCODE_F7 = 64;
	SCANCODE_F8 = 65;
	SCANCODE_F9 = 66;
	SCANCODE_F10 = 67;
	SCANCODE_F11 = 68;
	SCANCODE_F12 = 69;

	SCANCODE_PRINTSCREEN = 70;
	SCANCODE_SCROLLLOCK = 71;
	SCANCODE_PAUSE = 72;
	SCANCODE_INSERT = 73; /**< insert on PC, help on some Mac keyboards (but
	does send code 73, not 117) */
	SCANCODE_HOME = 74;
	SCANCODE_PAGEUP = 75;
	SCANCODE_DELETE = 76;
	SCANCODE_END = 77;
	SCANCODE_PAGEDOWN = 78;
	SCANCODE_RIGHT = 79;
	SCANCODE_LEFT = 80;
	SCANCODE_DOWN = 81;
	SCANCODE_UP = 82;

	SCANCODE_NUMLOCKCLEAR = 83; /**< num lock on PC, clear on Mac keyboards
	*/
	SCANCODE_KP_DIVIDE = 84;
	SCANCODE_KP_MULTIPLY = 85;
	SCANCODE_KP_MINUS = 86;
	SCANCODE_KP_PLUS = 87;
	SCANCODE_KP_ENTER = 88;
	SCANCODE_KP_1 = 89;
	SCANCODE_KP_2 = 90;
	SCANCODE_KP_3 = 91;
	SCANCODE_KP_4 = 92;
	SCANCODE_KP_5 = 93;
	SCANCODE_KP_6 = 94;
	SCANCODE_KP_7 = 95;
	SCANCODE_KP_8 = 96;
	SCANCODE_KP_9 = 97;
	SCANCODE_KP_0 = 98;
	SCANCODE_KP_PERIOD = 99;

	SCANCODE_NONUSBACKSLASH = 100; /**< This is the additional key that ISO
	*   keyboards have over ANSI ones,
	*   located between left shift and Y.
	*   Produces GRAVE ACCENT and TILDE in a
	*   US or UK Mac layout, REVERSE SOLIDUS
	*   (backslash) and VERTICAL LINE in a
	*   US or UK Windows layout, and
	*   LESS-THAN SIGN and GREATER-THAN SIGN
	*   in a Swiss German, German, or French
	*   layout. */
	SCANCODE_APPLICATION = 101; /**< windows contextual menu, compose */
	SCANCODE_POWER = 102; /**< The USB document says this is a status flag,
	*   not a physical key - but some Mac keyboards
	*   do have a power key. */
	SCANCODE_KP_EQUALS = 103;
	SCANCODE_F13 = 104;
	SCANCODE_F14 = 105;
	SCANCODE_F15 = 106;
	SCANCODE_F16 = 107;
	SCANCODE_F17 = 108;
	SCANCODE_F18 = 109;
	SCANCODE_F19 = 110;
	SCANCODE_F20 = 111;
	SCANCODE_F21 = 112;
	SCANCODE_F22 = 113;
	SCANCODE_F23 = 114;
	SCANCODE_F24 = 115;
	SCANCODE_EXECUTE = 116;
	SCANCODE_HELP = 117;    /**< AL Integrated Help Center */
	SCANCODE_MENU = 118;    /**< Menu (show menu) */
	SCANCODE_SELECT = 119;
	SCANCODE_STOP = 120;    /**< AC Stop */
	SCANCODE_AGAIN = 121;   /**< AC Redo/Repeat */
	SCANCODE_UNDO = 122;    /**< AC Undo */
	SCANCODE_CUT = 123;     /**< AC Cut */
	SCANCODE_COPY = 124;    /**< AC Copy */
	SCANCODE_PASTE = 125;   /**< AC Paste */
	SCANCODE_FIND = 126;    /**< AC Find */
	SCANCODE_MUTE = 127;
	SCANCODE_VOLUMEUP = 128;
	SCANCODE_VOLUMEDOWN = 129;
	/* not sure whether there's a reason to enable these */
	/*     SDL_SCANCODE_LOCKINGCAPSLOCK = 130,  */
	/*     SDL_SCANCODE_LOCKINGNUMLOCK = 131, */
	/*     SDL_SCANCODE_LOCKINGSCROLLLOCK = 132, */
	SCANCODE_KP_COMMA = 133;
	SCANCODE_KP_EQUALSAS400 = 134;

	SCANCODE_INTERNATIONAL1 = 135; /**< used on Asian keyboards, see
	footnotes in USB doc */
	SCANCODE_INTERNATIONAL2 = 136;
	SCANCODE_INTERNATIONAL3 = 137; /**< Yen */
	SCANCODE_INTERNATIONAL4 = 138;
	SCANCODE_INTERNATIONAL5 = 139;
	SCANCODE_INTERNATIONAL6 = 140;
	SCANCODE_INTERNATIONAL7 = 141;
	SCANCODE_INTERNATIONAL8 = 142;
	SCANCODE_INTERNATIONAL9 = 143;
	SCANCODE_LANG1 = 144; /**< Hangul/English toggle */
	SCANCODE_LANG2 = 145; /**< Hanja conversion */
	SCANCODE_LANG3 = 146; /**< Katakana */
	SCANCODE_LANG4 = 147; /**< Hiragana */
	SCANCODE_LANG5 = 148; /**< Zenkaku/Hankaku */
	SCANCODE_LANG6 = 149; /**< reserved */
	SCANCODE_LANG7 = 150; /**< reserved */
	SCANCODE_LANG8 = 151; /**< reserved */
	SCANCODE_LANG9 = 152; /**< reserved */

	SCANCODE_ALTERASE = 153;    /**< Erase-Eaze */
	SCANCODE_SYSREQ = 154;
	SCANCODE_CANCEL = 155;      /**< AC Cancel */
	SCANCODE_CLEAR = 156;
	SCANCODE_PRIOR = 157;
	SCANCODE_RETURN2 = 158;
	SCANCODE_SEPARATOR = 159;
	SCANCODE_OUT = 160;
	SCANCODE_OPER = 161;
	SCANCODE_CLEARAGAIN = 162;
	SCANCODE_CRSEL = 163;
	SCANCODE_EXSEL = 164;

	SCANCODE_KP_00 = 176;
	SCANCODE_KP_000 = 177;
	SCANCODE_THOUSANDSSEPARATOR = 178;
	SCANCODE_DECIMALSEPARATOR = 179;
	SCANCODE_CURRENCYUNIT = 180;
	SCANCODE_CURRENCYSUBUNIT = 181;
	SCANCODE_KP_LEFTPAREN = 182;
	SCANCODE_KP_RIGHTPAREN = 183;
	SCANCODE_KP_LEFTBRACE = 184;
	SCANCODE_KP_RIGHTBRACE = 185;
	SCANCODE_KP_TAB = 186;
	SCANCODE_KP_BACKSPACE = 187;
	SCANCODE_KP_A = 188;
	SCANCODE_KP_B = 189;
	SCANCODE_KP_C = 190;
	SCANCODE_KP_D = 191;
	SCANCODE_KP_E = 192;
	SCANCODE_KP_F = 193;
	SCANCODE_KP_XOR = 194;
	SCANCODE_KP_POWER = 195;
	SCANCODE_KP_PERCENT = 196;
	SCANCODE_KP_LESS = 197;
	SCANCODE_KP_GREATER = 198;
	SCANCODE_KP_AMPERSAND = 199;
	SCANCODE_KP_DBLAMPERSAND = 200;
	SCANCODE_KP_VERTICALBAR = 201;
	SCANCODE_KP_DBLVERTICALBAR = 202;
	SCANCODE_KP_COLON = 203;
	SCANCODE_KP_HASH = 204;
	SCANCODE_KP_SPACE = 205;
	SCANCODE_KP_AT = 206;
	SCANCODE_KP_EXCLAM = 207;
	SCANCODE_KP_MEMSTORE = 208;
	SCANCODE_KP_MEMRECALL = 209;
	SCANCODE_KP_MEMCLEAR = 210;
	SCANCODE_KP_MEMADD = 211;
	SCANCODE_KP_MEMSUBTRACT = 212;
	SCANCODE_KP_MEMMULTIPLY = 213;
	SCANCODE_KP_MEMDIVIDE = 214;
	SCANCODE_KP_PLUSMINUS = 215;
	SCANCODE_KP_CLEAR = 216;
	SCANCODE_KP_CLEARENTRY = 217;
	SCANCODE_KP_BINARY = 218;
	SCANCODE_KP_OCTAL = 219;
	SCANCODE_KP_DECIMAL = 220;
	SCANCODE_KP_HEXADECIMAL = 221;

	SCANCODE_LCTRL = 224;
	SCANCODE_LSHIFT = 225;
	SCANCODE_LALT = 226; /**< alt, option */
	SCANCODE_LGUI = 227; /**< windows, command (apple), meta */
	SCANCODE_RCTRL = 228;
	SCANCODE_RSHIFT = 229;
	SCANCODE_RALT = 230; /**< alt gr, option */
	SCANCODE_RGUI = 231; /**< windows, command (apple), meta */

	SCANCODE_MODE = 257;    /**< I'm not sure if this is really not covered
	*   by any of the above, but since there's a
	*   special SDL_KMOD_MODE for it I'm adding it here
	*/

	/* @} *//* Usage page 0x07 */

	/**
	*  \name Usage page 0x0C
	*
	*  These values are mapped from usage page 0x0C (USB consumer page).
	*
	*  There are way more keys in the spec than we can represent in the
	*  current scancode range, so pick the ones that commonly come up in
	*  real world usage.
	*/
	/* @{ */

	SCANCODE_SLEEP = 258;                   /**< Sleep */
	SCANCODE_WAKE = 259;                    /**< Wake */

	SCANCODE_CHANNEL_INCREMENT = 260;       /**< Channel Increment */
	SCANCODE_CHANNEL_DECREMENT = 261;       /**< Channel Decrement */

	SCANCODE_MEDIA_PLAY = 262;          /**< Play */
	SCANCODE_MEDIA_PAUSE = 263;         /**< Pause */
	SCANCODE_MEDIA_RECORD = 264;        /**< Record */
	SCANCODE_MEDIA_FAST_FORWARD = 265;  /**< Fast Forward */
	SCANCODE_MEDIA_REWIND = 266;        /**< Rewind */
	SCANCODE_MEDIA_NEXT_TRACK = 267;    /**< Next Track */
	SCANCODE_MEDIA_PREVIOUS_TRACK = 268; /**< Previous Track */
	SCANCODE_MEDIA_STOP = 269;          /**< Stop */
	SCANCODE_MEDIA_EJECT = 270;         /**< Eject */
	SCANCODE_MEDIA_PLAY_PAUSE = 271;    /**< Play / Pause */
	SCANCODE_MEDIA_SELECT = 272;        /* Media Select */

	SCANCODE_AC_NEW = 273;              /**< AC New */
	SCANCODE_AC_OPEN = 274;             /**< AC Open */
	SCANCODE_AC_CLOSE = 275;            /**< AC Close */
	SCANCODE_AC_EXIT = 276;             /**< AC Exit */
	SCANCODE_AC_SAVE = 277;             /**< AC Save */
	SCANCODE_AC_PRINT = 278;            /**< AC Print */
	SCANCODE_AC_PROPERTIES = 279;       /**< AC Properties */

	SCANCODE_AC_SEARCH = 280;           /**< AC Search */
	SCANCODE_AC_HOME = 281;             /**< AC Home */
	SCANCODE_AC_BACK = 282;             /**< AC Back */
	SCANCODE_AC_FORWARD = 283;          /**< AC Forward */
	SCANCODE_AC_STOP = 284;             /**< AC Stop */
	SCANCODE_AC_REFRESH = 285;          /**< AC Refresh */
	SCANCODE_AC_BOOKMARKS = 286;        /**< AC Bookmarks */

	/* @} *//* Usage page 0x0C */


	/**
	*  \name Mobile keys
	*
	*  These are values that are often used on mobile phones.
	*/
	/* @{ */

	SCANCODE_SOFTLEFT = 287; /**< Usually situated below the display on phones and
	used as a multi-function feature key for selecting
	a software defined function shown on the bottom left
	of the display. */
	SCANCODE_SOFTRIGHT = 288; /**< Usually situated below the display on phones and
	used as a multi-function feature key for selecting
	a software defined function shown on the bottom right
	of the display. */
	SCANCODE_CALL = 289; /**< Used for accepting phone calls. */
	SCANCODE_ENDCALL = 290; /**< Used for rejecting phone calls. */

	/* @} *//* Mobile keys */

	/* Add any other keys here. */

	SCANCODE_RESERVED = 400;    /**< 400-500 reserved for dynamic keycodes */

	SCANCODE_COUNT = 512;/**< not a key, just marks the number of scancodes for array bounds */
}


GLAttr :: enum {
	GL_RED_SIZE;                    /**< the minimum number of bits for the red channel of the color buffer; defaults to 3. */
	GL_GREEN_SIZE;                  /**< the minimum number of bits for the green channel of the color buffer; defaults to 3. */
	GL_BLUE_SIZE;                   /**< the minimum number of bits for the blue channel of the color buffer; defaults to 2. */
	GL_ALPHA_SIZE;                  /**< the minimum number of bits for the alpha channel of the color buffer; defaults to 0. */
	GL_BUFFER_SIZE;                 /**< the minimum number of bits for frame buffer size; defaults to 0. */
	GL_DOUBLEBUFFER;                /**< whether the output is single or double buffered; defaults to double buffering on. */
	GL_DEPTH_SIZE;                  /**< the minimum number of bits in the depth buffer; defaults to 16. */
	GL_STENCIL_SIZE;                /**< the minimum number of bits in the stencil buffer; defaults to 0. */
	GL_ACCUM_RED_SIZE;              /**< the minimum number of bits for the red channel of the accumulation buffer; defaults to 0. */
	GL_ACCUM_GREEN_SIZE;            /**< the minimum number of bits for the green channel of the accumulation buffer; defaults to 0. */
	GL_ACCUM_BLUE_SIZE;             /**< the minimum number of bits for the blue channel of the accumulation buffer; defaults to 0. */
	GL_ACCUM_ALPHA_SIZE;            /**< the minimum number of bits for the alpha channel of the accumulation buffer; defaults to 0. */
	GL_STEREO;                      /**< whether the output is stereo 3D; defaults to off. */
	GL_MULTISAMPLEBUFFERS;          /**< the number of buffers used for multisample anti-aliasing; defaults to 0. */
	GL_MULTISAMPLESAMPLES;          /**< the number of samples used around the current pixel used for multisample anti-aliasing. */
	GL_ACCELERATED_VISUAL;          /**< set to 1 to require hardware acceleration, set to 0 to force software rendering; defaults to allow either. */
	GL_RETAINED_BACKING;            /**< not used (deprecated). */
	GL_CONTEXT_MAJOR_VERSION;       /**< OpenGL context major version. */
	GL_CONTEXT_MINOR_VERSION;       /**< OpenGL context minor version. */
	GL_CONTEXT_FLAGS;               /**< some combination of 0 or more of elements of the GLContextFlag enumeration; defaults to 0. */
	GL_CONTEXT_PROFILE_MASK;        /**< type of GL context (Core, Compatibility, ES). See GLProfile; default value depends on platform. */
	GL_SHARE_WITH_CURRENT_CONTEXT;  /**< OpenGL context sharing; defaults to 0. */
	GL_FRAMEBUFFER_SRGB_CAPABLE;    /**< requests sRGB capable visual; defaults to 0. */
	GL_CONTEXT_RELEASE_BEHAVIOR;    /**< sets context the release behavior. See GLContextReleaseFlag; defaults to FLUSH. */
	GL_CONTEXT_RESET_NOTIFICATION;  /**< set context reset notification. See GLContextResetNotification; defaults to NO_NOTIFICATION. */
	GL_CONTEXT_NO_ERROR;
	GL_FLOATBUFFERS;
	GL_EGL_PLATFORM;
}

GL_CONTEXT_PROFILE_CORE ::           0x0001;  /**< OpenGL Core Profile context */
GL_CONTEXT_PROFILE_COMPATIBILITY ::  0x0002;  /**< OpenGL Compatibility Profile context */
GL_CONTEXT_PROFILE_ES ::             0x0004;  /**< GLX_CONTEXT_ES2_PROFILE_BIT_EXT */

Event :: union {
	type: EventType;
	window: WindowEvent;
	key: KeyboardEvent;
	edit: TextEditingEvent;
	text: TextInputEvent;
	button: MouseButtonEvent;
	wheel: MouseWheelEvent;
	drop: DropEvent;
	motion: MouseMotionEvent;
	_: [128]u8;
}

WindowEvent :: struct {
	type: EventType;
	reserved: u32;
	timestamp: u64;   /**< In nanoseconds, populated using GetTicksNS() */
	windowID: WindowID; /**< The associated window */
	data1: s32;       /**< event dependent data */
	data2: s32;       /**< event dependent data */
}

KeyboardEvent :: struct {
	type: EventType;
	reserved: u32;
	timestamp: u64;      /**< In nanoseconds, populated using SDL_GetTicksNS() */
	windowID: WindowID;  /**< The window with keyboard focus, if any */
	which: KeyboardID;   /**< The keyboard instance id, or 0 if unknown or virtual */
	scancode: Scancode;  /**< SDL physical key code */
	key: Keycode;        /**< SDL virtual key code */
	mod: Keymod;         /**< current key modifiers */
	raw: u16;            /**< The platform dependent scancode for this event */
	down: bool;          /**< true if the key is pressed */
	repeat: bool;        /**< true if this is a key repeat */
}

TextEditingEvent :: struct {
	type: EventType;
	reserved: u32;
	timestamp: u64;      /**< In nanoseconds, populated using SDL_GetTicksNS() */
	windowID: WindowID;  /**< The window with keyboard focus, if any */
	text: *C.char;       /**< The editing text */
	start: s32;          /**< The start cursor of selected editing text, or -1 if not set */
	length: s32;         /**< The length of selected editing text, or -1 if not set */
}

TextInputEvent :: struct {
	type: EventType;
	reserved: u32;
	timestamp: u64;      /**< In nanoseconds, populated using SDL_GetTicksNS() */
	windowID: WindowID;  /**< The window with keyboard focus, if any */
	text: *C.char;       /**< The input text, UTF-8 encoded */
}

MouseButtonEvent :: struct {
	type: EventType;
	reserved: u32;
	timestamp: u64;      /**< In nanoseconds, populated using SDL_GetTicksNS() */
	windowID: WindowID;  /**< The window with keyboard focus, if any */
	which: MouseID;  /**< The mouse instance id in relative mode, SDL_TOUCH_MOUSEID for touch events, or 0 */
	button: u8;       /**< The mouse button index */
	down: bool;          /**< true if the button is pressed */
	clicks: u8;       /**< 1 for single-click, 2 for double-click, etc. */
	_: u8;
	x: f32;            /**< X coordinate, relative to window */
	y: f32;            /**< Y coordinate, relative to window */
}

MouseWheelDirection :: enum {
	MOUSEWHEEL_NORMAL;    /**< The scroll direction is normal */
	MOUSEWHEEL_FLIPPED    /**< The scroll direction is flipped / natural */
}

MouseWheelEvent :: struct {
	type: EventType;
	reserved: u32;
	timestamp: u64;      /**< In nanoseconds, populated using SDL_GetTicksNS() */
	windowID: WindowID;  /**< The window with keyboard focus, if any */
	which: MouseID;  /**< The mouse instance id in relative mode, SDL_TOUCH_MOUSEID for touch events, or 0 */
	x: f32;            /**< The amount scrolled horizontally, positive to the right and negative to the left */
	y: f32;            /**< The amount scrolled vertically, positive away from the user and negative toward the user */
	direction: MouseWheelDirection; /**< Set to one of the SDL_MOUSEWHEEL_* defines. When FLIPPED the values in X and Y will be opposite. Multiply by -1 to change them back */
	mouse_x: f32;      /**< X coordinate, relative to window */
	mouse_y: f32;      /**< Y coordinate, relative to window */
}

DropEvent :: struct {
	type: EventType;
	reserved: u32;
	timestamp: u64;      /**< In nanoseconds, populated using SDL_GetTicksNS() */
	windowID: WindowID;  /**< The window with keyboard focus, if any */
	x: f32;            /**< X coordinate, relative to window (not on begin) */
	y: f32;            /**< Y coordinate, relative to window (not on begin) */
	source: *C.char; /**< The source app that sent this drop event, or NULL if that isn't available */
	data: *C.char;   /**< The text for SDL_EVENT_DROP_TEXT and the file name for SDL_EVENT_DROP_FILE, NULL for other events */
}

MouseMotionEvent :: struct {
	type: EventType;
	reserved: u32;
	timestamp: u64;      /**< In nanoseconds, populated using SDL_GetTicksNS() */
	windowID: WindowID;  /**< The window with keyboard focus, if any */
	which: MouseID;  /**< The mouse instance id in relative mode, SDL_TOUCH_MOUSEID for touch events, or 0 */
	state: MouseButtonFlags;       /**< The current button state */
	x: f32;            /**< X coordinate, relative to window */
	y: f32;            /**< Y coordinate, relative to window */
	xrel: f32;         /**< The relative motion in the X direction */
	yrel: f32;         /**< The relative motion in the Y direction */
}

EventType :: enum u32 {
	EVENT_FIRST     = 0;     /**< Unused (do not remove) */

	/* Application events */
	EVENT_QUIT           = 0x100; /**< User-requested quit */

	/* These application events have special meaning on iOS and Android, see README-ios.md and README-android.md for details */
	EVENT_TERMINATING;      /**< The application is being terminated by the OS. This event must be handled in a callback set with AddEventWatch().
	Called on iOS in applicationWillTerminate()
	Called on Android in onDestroy()
	*/
	EVENT_LOW_MEMORY;       /**< The application is low on memory, free memory if possible. This event must be handled in a callback set with AddEventWatch().
	Called on iOS in applicationDidReceiveMemoryWarning()
	Called on Android in onTrimMemory()
	*/
	EVENT_WILL_ENTER_BACKGROUND; /**< The application is about to enter the background. This event must be handled in a callback set with AddEventWatch().
	Called on iOS in applicationWillResignActive()
	Called on Android in onPause()
	*/
	EVENT_DID_ENTER_BACKGROUND; /**< The application did enter the background and may not get CPU for some time. This event must be handled in a callback set with AddEventWatch().
	Called on iOS in applicationDidEnterBackground()
	Called on Android in onPause()
	*/
	EVENT_WILL_ENTER_FOREGROUND; /**< The application is about to enter the foreground. This event must be handled in a callback set with AddEventWatch().
	Called on iOS in applicationWillEnterForeground()
	Called on Android in onResume()
	*/
	EVENT_DID_ENTER_FOREGROUND; /**< The application is now interactive. This event must be handled in a callback set with AddEventWatch().
	Called on iOS in applicationDidBecomeActive()
	Called on Android in onResume()
	*/

	EVENT_LOCALE_CHANGED;  /**< The user's locale preferences have changed. */

	EVENT_SYSTEM_THEME_CHANGED; /**< The system theme changed */

	/* Display events */
	/* 0x150 was DISPLAYEVENT, reserve the number for sdl2-compat */
	EVENT_DISPLAY_ORIENTATION = 0x151;   /**< Display orientation has changed to data1 */
	EVENT_DISPLAY_ADDED;                 /**< Display has been added to the system */
	EVENT_DISPLAY_REMOVED;               /**< Display has been removed from the system */
	EVENT_DISPLAY_MOVED;                 /**< Display has changed position */
	EVENT_DISPLAY_DESKTOP_MODE_CHANGED;  /**< Display has changed desktop mode */
	EVENT_DISPLAY_CURRENT_MODE_CHANGED;  /**< Display has changed current mode */
	EVENT_DISPLAY_CONTENT_SCALE_CHANGED; /**< Display has changed content scale */
	EVENT_DISPLAY_FIRST = EVENT_DISPLAY_ORIENTATION;
	EVENT_DISPLAY_LAST = EVENT_DISPLAY_CONTENT_SCALE_CHANGED;

	/* Window events */
	/* 0x200 was WINDOWEVENT, reserve the number for sdl2-compat */
	/* 0x201 was SYSWMEVENT, reserve the number for sdl2-compat */
	EVENT_WINDOW_SHOWN = 0x202;     /**< Window has been shown */
	EVENT_WINDOW_HIDDEN;            /**< Window has been hidden */
	EVENT_WINDOW_EXPOSED;           /**< Window has been exposed and should be redrawn, and can be redrawn directly from event watchers for this event */
	EVENT_WINDOW_MOVED;             /**< Window has been moved to data1, data2 */
	EVENT_WINDOW_RESIZED;           /**< Window has been resized to data1xdata2 */
	EVENT_WINDOW_PIXEL_SIZE_CHANGED;/**< The pixel size of the window has changed to data1xdata2 */
	EVENT_WINDOW_METAL_VIEW_RESIZED;/**< The pixel size of a Metal view associated with the window has changed */
	EVENT_WINDOW_MINIMIZED;         /**< Window has been minimized */
	EVENT_WINDOW_MAXIMIZED;         /**< Window has been maximized */
	EVENT_WINDOW_RESTORED;          /**< Window has been restored to normal size and position */
	EVENT_WINDOW_MOUSE_ENTER;       /**< Window has gained mouse focus */
	EVENT_WINDOW_MOUSE_LEAVE;       /**< Window has lost mouse focus */
	EVENT_WINDOW_FOCUS_GAINED;      /**< Window has gained keyboard focus */
	EVENT_WINDOW_FOCUS_LOST;        /**< Window has lost keyboard focus */
	EVENT_WINDOW_CLOSE_REQUESTED;   /**< The window manager requests that the window be closed */
	EVENT_WINDOW_HIT_TEST;          /**< Window had a hit test that wasn't HITTEST_NORMAL */
	EVENT_WINDOW_ICCPROF_CHANGED;   /**< The ICC profile of the window's display has changed */
	EVENT_WINDOW_DISPLAY_CHANGED;   /**< Window has been moved to display data1 */
	EVENT_WINDOW_DISPLAY_SCALE_CHANGED; /**< Window display scale has been changed */
	EVENT_WINDOW_SAFE_AREA_CHANGED; /**< The window safe area has been changed */
	EVENT_WINDOW_OCCLUDED;          /**< The window has been occluded */
	EVENT_WINDOW_ENTER_FULLSCREEN;  /**< The window has entered fullscreen mode */
	EVENT_WINDOW_LEAVE_FULLSCREEN;  /**< The window has left fullscreen mode */
	EVENT_WINDOW_DESTROYED;         /**< The window with the associated ID is being or has been destroyed. If this message is being handled
	in an event watcher, the window handle is still valid and can still be used to retrieve any properties
	associated with the window. Otherwise, the handle has already been destroyed and all resources
	associated with it are invalid */
	EVENT_WINDOW_HDR_STATE_CHANGED; /**< Window HDR properties have changed */
	EVENT_WINDOW_FIRST = EVENT_WINDOW_SHOWN;
	EVENT_WINDOW_LAST = EVENT_WINDOW_HDR_STATE_CHANGED;

	/* Keyboard events */
	EVENT_KEY_DOWN        = 0x300; /**< Key pressed */
	EVENT_KEY_UP;                  /**< Key released */
	EVENT_TEXT_EDITING;            /**< Keyboard text editing (composition) */
	EVENT_TEXT_INPUT;              /**< Keyboard text input */
	EVENT_KEYMAP_CHANGED;          /**< Keymap changed due to a system event such as an
	input language or keyboard layout change. */
	EVENT_KEYBOARD_ADDED;          /**< A new keyboard has been inserted into the system */
	EVENT_KEYBOARD_REMOVED;        /**< A keyboard has been removed */
	EVENT_TEXT_EDITING_CANDIDATES; /**< Keyboard text editing candidates */

	/* Mouse events */
	EVENT_MOUSE_MOTION    = 0x400; /**< Mouse moved */
	EVENT_MOUSE_BUTTON_DOWN;       /**< Mouse button pressed */
	EVENT_MOUSE_BUTTON_UP;         /**< Mouse button released */
	EVENT_MOUSE_WHEEL;             /**< Mouse wheel motion */
	EVENT_MOUSE_ADDED;             /**< A new mouse has been inserted into the system */
	EVENT_MOUSE_REMOVED;           /**< A mouse has been removed */

	/* Joystick events */
	EVENT_JOYSTICK_AXIS_MOTION  = 0x600; /**< Joystick axis motion */
	EVENT_JOYSTICK_BALL_MOTION;          /**< Joystick trackball motion */
	EVENT_JOYSTICK_HAT_MOTION;           /**< Joystick hat position change */
	EVENT_JOYSTICK_BUTTON_DOWN;          /**< Joystick button pressed */
	EVENT_JOYSTICK_BUTTON_UP;            /**< Joystick button released */
	EVENT_JOYSTICK_ADDED;                /**< A new joystick has been inserted into the system */
	EVENT_JOYSTICK_REMOVED;              /**< An opened joystick has been removed */
	EVENT_JOYSTICK_BATTERY_UPDATED;      /**< Joystick battery level change */
	EVENT_JOYSTICK_UPDATE_COMPLETE;      /**< Joystick update is complete */

	/* Gamepad events */
	EVENT_GAMEPAD_AXIS_MOTION  = 0x650; /**< Gamepad axis motion */
	EVENT_GAMEPAD_BUTTON_DOWN;          /**< Gamepad button pressed */
	EVENT_GAMEPAD_BUTTON_UP;            /**< Gamepad button released */
	EVENT_GAMEPAD_ADDED;                /**< A new gamepad has been inserted into the system */
	EVENT_GAMEPAD_REMOVED;              /**< A gamepad has been removed */
	EVENT_GAMEPAD_REMAPPED;             /**< The gamepad mapping was updated */
	EVENT_GAMEPAD_TOUCHPAD_DOWN;        /**< Gamepad touchpad was touched */
	EVENT_GAMEPAD_TOUCHPAD_MOTION;      /**< Gamepad touchpad finger was moved */
	EVENT_GAMEPAD_TOUCHPAD_UP;          /**< Gamepad touchpad finger was lifted */
	EVENT_GAMEPAD_SENSOR_UPDATE;        /**< Gamepad sensor was updated */
	EVENT_GAMEPAD_UPDATE_COMPLETE;      /**< Gamepad update is complete */
	EVENT_GAMEPAD_STEAM_HANDLE_UPDATED;  /**< Gamepad Steam handle has changed */

	/* Touch events */
	EVENT_FINGER_DOWN      = 0x700;
	EVENT_FINGER_UP;
	EVENT_FINGER_MOTION;
	EVENT_FINGER_CANCELED;

	/* 0x800, 0x801, and 0x802 were the Gesture events from SDL2. Do not reuse these values! sdl2-compat needs them! */

	/* Clipboard events */
	EVENT_CLIPBOARD_UPDATE = 0x900; /**< The clipboard or primary selection changed */

	/* Drag and drop events */
	EVENT_DROP_FILE        = 0x1000; /**< The system requests a file open */
	EVENT_DROP_TEXT;                 /**< text/plain drag-and-drop event */
	EVENT_DROP_BEGIN;                /**< A new set of drops is beginning (NULL filename) */
	EVENT_DROP_COMPLETE;             /**< Current set of drops is now complete (NULL filename) */
	EVENT_DROP_POSITION;             /**< Position while moving over the window */

	/* Audio hotplug events */
	EVENT_AUDIO_DEVICE_ADDED = 0x1100;  /**< A new audio device is available */
	EVENT_AUDIO_DEVICE_REMOVED;         /**< An audio device has been removed. */
	EVENT_AUDIO_DEVICE_FORMAT_CHANGED;  /**< An audio device's format has been changed by the system. */

	/* Sensor events */
	EVENT_SENSOR_UPDATE = 0x1200;     /**< A sensor was updated */

	/* Pressure-sensitive pen events */
	EVENT_PEN_PROXIMITY_IN = 0x1300;  /**< Pressure-sensitive pen has become available */
	EVENT_PEN_PROXIMITY_OUT;          /**< Pressure-sensitive pen has become unavailable */
	EVENT_PEN_DOWN;                   /**< Pressure-sensitive pen touched drawing surface */
	EVENT_PEN_UP;                     /**< Pressure-sensitive pen stopped touching drawing surface */
	EVENT_PEN_BUTTON_DOWN;            /**< Pressure-sensitive pen button pressed */
	EVENT_PEN_BUTTON_UP;              /**< Pressure-sensitive pen button released */
	EVENT_PEN_MOTION;                 /**< Pressure-sensitive pen is moving on the tablet */
	EVENT_PEN_AXIS;                   /**< Pressure-sensitive pen angle/pressure/etc changed */

	/* Camera hotplug events */
	EVENT_CAMERA_DEVICE_ADDED = 0x1400;  /**< A new camera device is available */
	EVENT_CAMERA_DEVICE_REMOVED;         /**< A camera device has been removed. */
	EVENT_CAMERA_DEVICE_APPROVED;        /**< A camera device has been approved for use by the user. */
	EVENT_CAMERA_DEVICE_DENIED;          /**< A camera device has been denied for use by the user. */

	/* Render events */
	EVENT_RENDER_TARGETS_RESET = 0x2000; /**< The render targets have been reset and their contents need to be updated */
	EVENT_RENDER_DEVICE_RESET; /**< The device has been reset and all textures need to be recreated */
	EVENT_RENDER_DEVICE_LOST; /**< The device has been lost and can't be recovered. */

	/* Reserved events for private platforms */
	EVENT_PRIVATE0 = 0x4000;
	EVENT_PRIVATE1;
	EVENT_PRIVATE2;
	EVENT_PRIVATE3;

	/* Internal events */
	EVENT_POLL_SENTINEL = 0x7F00; /**< Signals the end of an event poll cycle */

	/** Events EVENT_USER through EVENT_LAST are for your use,
	*  and should be allocated with RegisterEvents()
	*/
	EVENT_USER    = 0x8000;

	/**
	*  This last event is only for bounding internal arrays
	*/
	EVENT_LAST    = 0xFFFF;

	/* This just makes sure the enum is the size of Uint32 */
	EVENT_ENUM_PADDING = 0x7FFFFFFF;
}

SystemCursor :: enum {
	SYSTEM_CURSOR_DEFAULT;      /**< Default cursor. Usually an arrow. */
	SYSTEM_CURSOR_TEXT;         /**< Text selection. Usually an I-beam. */
	SYSTEM_CURSOR_WAIT;         /**< Wait. Usually an hourglass or watch or spinning ball. */
	SYSTEM_CURSOR_CROSSHAIR;    /**< Crosshair. */
	SYSTEM_CURSOR_PROGRESS;     /**< Program is busy but still interactive. Usually it's WAIT with an arrow. */
	SYSTEM_CURSOR_NWSE_RESIZE;  /**< Double arrow pointing northwest and southeast. */
	SYSTEM_CURSOR_NESW_RESIZE;  /**< Double arrow pointing northeast and southwest. */
	SYSTEM_CURSOR_EW_RESIZE;    /**< Double arrow pointing west and east. */
	SYSTEM_CURSOR_NS_RESIZE;    /**< Double arrow pointing north and south. */
	SYSTEM_CURSOR_MOVE;         /**< Four pointed arrow pointing north, south, east, and west. */
	SYSTEM_CURSOR_NOT_ALLOWED;  /**< Not permitted. Usually a slashed circle or crossbones. */
	SYSTEM_CURSOR_POINTER;      /**< Pointer that indicates a link. Usually a pointing hand. */
	SYSTEM_CURSOR_NW_RESIZE;    /**< Window resize top-left. This may be a single arrow or a double arrow like NWSE_RESIZE. */
	SYSTEM_CURSOR_N_RESIZE;     /**< Window resize top. May be NS_RESIZE. */
	SYSTEM_CURSOR_NE_RESIZE;    /**< Window resize top-right. May be NESW_RESIZE. */
	SYSTEM_CURSOR_E_RESIZE;     /**< Window resize right. May be EW_RESIZE. */
	SYSTEM_CURSOR_SE_RESIZE;    /**< Window resize bottom-right. May be NWSE_RESIZE. */
	SYSTEM_CURSOR_S_RESIZE;     /**< Window resize bottom. May be NS_RESIZE. */
	SYSTEM_CURSOR_SW_RESIZE;    /**< Window resize bottom-left. May be NESW_RESIZE. */
	SYSTEM_CURSOR_W_RESIZE;     /**< Window resize left. May be EW_RESIZE. */
}

MouseButtonFlags :: u32;

BUTTON_LEFT : u8 :     1;
BUTTON_MIDDLE : u8 :   2;
BUTTON_RIGHT : u8 :    3;
BUTTON_X1 : u8 :       4;
BUTTON_X2 : u8 :       5;

PixelFormat :: enum {
	PIXELFORMAT_UNKNOWN = 0;
	PIXELFORMAT_INDEX1LSB = 0x11100100;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_INDEX1, BITMAPORDER_4321, 0, 1, 0), */
	PIXELFORMAT_INDEX1MSB = 0x11200100;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_INDEX1, BITMAPORDER_1234, 0, 1, 0), */
	PIXELFORMAT_INDEX2LSB = 0x1c100200;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_INDEX2, BITMAPORDER_4321, 0, 2, 0), */
	PIXELFORMAT_INDEX2MSB = 0x1c200200;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_INDEX2, BITMAPORDER_1234, 0, 2, 0), */
	PIXELFORMAT_INDEX4LSB = 0x12100400;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_INDEX4, BITMAPORDER_4321, 0, 4, 0), */
	PIXELFORMAT_INDEX4MSB = 0x12200400;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_INDEX4, BITMAPORDER_1234, 0, 4, 0), */
	PIXELFORMAT_INDEX8 = 0x13000801;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_INDEX8, 0, 0, 8, 1), */
	PIXELFORMAT_RGB332 = 0x14110801;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_PACKED8, PACKEDORDER_XRGB, PACKEDLAYOUT_332, 8, 1), */
	PIXELFORMAT_XRGB4444 = 0x15120c02;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_PACKED16, PACKEDORDER_XRGB, PACKEDLAYOUT_4444, 12, 2), */
	PIXELFORMAT_XBGR4444 = 0x15520c02;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_PACKED16, PACKEDORDER_XBGR, PACKEDLAYOUT_4444, 12, 2), */
	PIXELFORMAT_XRGB1555 = 0x15130f02;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_PACKED16, PACKEDORDER_XRGB, PACKEDLAYOUT_1555, 15, 2), */
	PIXELFORMAT_XBGR1555 = 0x15530f02;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_PACKED16, PACKEDORDER_XBGR, PACKEDLAYOUT_1555, 15, 2), */
	PIXELFORMAT_ARGB4444 = 0x15321002;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_PACKED16, PACKEDORDER_ARGB, PACKEDLAYOUT_4444, 16, 2), */
	PIXELFORMAT_RGBA4444 = 0x15421002;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_PACKED16, PACKEDORDER_RGBA, PACKEDLAYOUT_4444, 16, 2), */
	PIXELFORMAT_ABGR4444 = 0x15721002;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_PACKED16, PACKEDORDER_ABGR, PACKEDLAYOUT_4444, 16, 2), */
	PIXELFORMAT_BGRA4444 = 0x15821002;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_PACKED16, PACKEDORDER_BGRA, PACKEDLAYOUT_4444, 16, 2), */
	PIXELFORMAT_ARGB1555 = 0x15331002;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_PACKED16, PACKEDORDER_ARGB, PACKEDLAYOUT_1555, 16, 2), */
	PIXELFORMAT_RGBA5551 = 0x15441002;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_PACKED16, PACKEDORDER_RGBA, PACKEDLAYOUT_5551, 16, 2), */
	PIXELFORMAT_ABGR1555 = 0x15731002;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_PACKED16, PACKEDORDER_ABGR, PACKEDLAYOUT_1555, 16, 2), */
	PIXELFORMAT_BGRA5551 = 0x15841002;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_PACKED16, PACKEDORDER_BGRA, PACKEDLAYOUT_5551, 16, 2), */
	PIXELFORMAT_RGB565 = 0x15151002;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_PACKED16, PACKEDORDER_XRGB, PACKEDLAYOUT_565, 16, 2), */
	PIXELFORMAT_BGR565 = 0x15551002;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_PACKED16, PACKEDORDER_XBGR, PACKEDLAYOUT_565, 16, 2), */
	PIXELFORMAT_RGB24 = 0x17101803;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_ARRAYU8, ARRAYORDER_RGB, 0, 24, 3), */
	PIXELFORMAT_BGR24 = 0x17401803;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_ARRAYU8, ARRAYORDER_BGR, 0, 24, 3), */
	PIXELFORMAT_XRGB8888 = 0x16161804;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_PACKED32, PACKEDORDER_XRGB, PACKEDLAYOUT_8888, 24, 4), */
	PIXELFORMAT_RGBX8888 = 0x16261804;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_PACKED32, PACKEDORDER_RGBX, PACKEDLAYOUT_8888, 24, 4), */
	PIXELFORMAT_XBGR8888 = 0x16561804;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_PACKED32, PACKEDORDER_XBGR, PACKEDLAYOUT_8888, 24, 4), */
	PIXELFORMAT_BGRX8888 = 0x16661804;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_PACKED32, PACKEDORDER_BGRX, PACKEDLAYOUT_8888, 24, 4), */
	PIXELFORMAT_ARGB8888 = 0x16362004;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_PACKED32, PACKEDORDER_ARGB, PACKEDLAYOUT_8888, 32, 4), */
	PIXELFORMAT_RGBA8888 = 0x16462004;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_PACKED32, PACKEDORDER_RGBA, PACKEDLAYOUT_8888, 32, 4), */
	PIXELFORMAT_ABGR8888 = 0x16762004;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_PACKED32, PACKEDORDER_ABGR, PACKEDLAYOUT_8888, 32, 4), */
	PIXELFORMAT_BGRA8888 = 0x16862004;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_PACKED32, PACKEDORDER_BGRA, PACKEDLAYOUT_8888, 32, 4), */
	PIXELFORMAT_XRGB2101010 = 0x16172004;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_PACKED32, PACKEDORDER_XRGB, PACKEDLAYOUT_2101010, 32, 4), */
	PIXELFORMAT_XBGR2101010 = 0x16572004;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_PACKED32, PACKEDORDER_XBGR, PACKEDLAYOUT_2101010, 32, 4), */
	PIXELFORMAT_ARGB2101010 = 0x16372004;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_PACKED32, PACKEDORDER_ARGB, PACKEDLAYOUT_2101010, 32, 4), */
	PIXELFORMAT_ABGR2101010 = 0x16772004;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_PACKED32, PACKEDORDER_ABGR, PACKEDLAYOUT_2101010, 32, 4), */
	PIXELFORMAT_RGB48 = 0x18103006;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_ARRAYU16, ARRAYORDER_RGB, 0, 48, 6), */
	PIXELFORMAT_BGR48 = 0x18403006;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_ARRAYU16, ARRAYORDER_BGR, 0, 48, 6), */
	PIXELFORMAT_RGBA64 = 0x18204008;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_ARRAYU16, ARRAYORDER_RGBA, 0, 64, 8), */
	PIXELFORMAT_ARGB64 = 0x18304008;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_ARRAYU16, ARRAYORDER_ARGB, 0, 64, 8), */
	PIXELFORMAT_BGRA64 = 0x18504008;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_ARRAYU16, ARRAYORDER_BGRA, 0, 64, 8), */
	PIXELFORMAT_ABGR64 = 0x18604008;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_ARRAYU16, ARRAYORDER_ABGR, 0, 64, 8), */
	PIXELFORMAT_RGB48_FLOAT = 0x1a103006;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_ARRAYF16, ARRAYORDER_RGB, 0, 48, 6), */
	PIXELFORMAT_BGR48_FLOAT = 0x1a403006;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_ARRAYF16, ARRAYORDER_BGR, 0, 48, 6), */
	PIXELFORMAT_RGBA64_FLOAT = 0x1a204008;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_ARRAYF16, ARRAYORDER_RGBA, 0, 64, 8), */
	PIXELFORMAT_ARGB64_FLOAT = 0x1a304008;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_ARRAYF16, ARRAYORDER_ARGB, 0, 64, 8), */
	PIXELFORMAT_BGRA64_FLOAT = 0x1a504008;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_ARRAYF16, ARRAYORDER_BGRA, 0, 64, 8), */
	PIXELFORMAT_ABGR64_FLOAT = 0x1a604008;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_ARRAYF16, ARRAYORDER_ABGR, 0, 64, 8), */
	PIXELFORMAT_RGB96_FLOAT = 0x1b10600c;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_ARRAYF32, ARRAYORDER_RGB, 0, 96, 12), */
	PIXELFORMAT_BGR96_FLOAT = 0x1b40600c;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_ARRAYF32, ARRAYORDER_BGR, 0, 96, 12), */
	PIXELFORMAT_RGBA128_FLOAT = 0x1b208010;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_ARRAYF32, ARRAYORDER_RGBA, 0, 128, 16), */
	PIXELFORMAT_ARGB128_FLOAT = 0x1b308010;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_ARRAYF32, ARRAYORDER_ARGB, 0, 128, 16), */
	PIXELFORMAT_BGRA128_FLOAT = 0x1b508010;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_ARRAYF32, ARRAYORDER_BGRA, 0, 128, 16), */
	PIXELFORMAT_ABGR128_FLOAT = 0x1b608010;
	/* DEFINE_PIXELFORMAT(PIXELTYPE_ARRAYF32, ARRAYORDER_ABGR, 0, 128, 16), */

	PIXELFORMAT_YV12 = 0x32315659;      /**< Planar mode: Y + V + U  (3 planes) */
	/* DEFINE_PIXELFOURCC('Y', 'V', '1', '2'), */
	PIXELFORMAT_IYUV = 0x56555949;      /**< Planar mode: Y + U + V  (3 planes) */
	/* DEFINE_PIXELFOURCC('I', 'Y', 'U', 'V'), */
	PIXELFORMAT_YUY2 = 0x32595559;      /**< Packed mode: Y0+U0+Y1+V0 (1 plane) */
	/* DEFINE_PIXELFOURCC('Y', 'U', 'Y', '2'), */
	PIXELFORMAT_UYVY = 0x59565955;      /**< Packed mode: U0+Y0+V0+Y1 (1 plane) */
	/* DEFINE_PIXELFOURCC('U', 'Y', 'V', 'Y'), */
	PIXELFORMAT_YVYU = 0x55595659;      /**< Packed mode: Y0+V0+Y1+U0 (1 plane) */
	/* DEFINE_PIXELFOURCC('Y', 'V', 'Y', 'U'), */
	PIXELFORMAT_NV12 = 0x3231564e;      /**< Planar mode: Y + U/V interleaved  (2 planes) */
	/* DEFINE_PIXELFOURCC('N', 'V', '1', '2'), */
	PIXELFORMAT_NV21 = 0x3132564e;      /**< Planar mode: Y + V/U interleaved  (2 planes) */
	/* DEFINE_PIXELFOURCC('N', 'V', '2', '1'), */
	PIXELFORMAT_P010 = 0x30313050;      /**< Planar mode: Y + U/V interleaved  (2 planes) */
	/* DEFINE_PIXELFOURCC('P', '0', '1', '0'), */
	PIXELFORMAT_EXTERNAL_OES = 0x2053454f;     /**< Android video texture format */
	/* DEFINE_PIXELFOURCC('O', 'E', 'S', ' ') */

	PIXELFORMAT_MJPG = 0x47504a4d;     /**< Motion JPEG */
	/* DEFINE_PIXELFOURCC('M', 'J', 'P', 'G') */

	PIXELFORMAT_RGBA32 = PIXELFORMAT_ABGR8888;
	PIXELFORMAT_ARGB32 = PIXELFORMAT_BGRA8888;
	PIXELFORMAT_BGRA32 = PIXELFORMAT_ARGB8888;
	PIXELFORMAT_ABGR32 = PIXELFORMAT_RGBA8888;
	PIXELFORMAT_RGBX32 = PIXELFORMAT_XBGR8888;
	PIXELFORMAT_XRGB32 = PIXELFORMAT_BGRX8888;
	PIXELFORMAT_BGRX32 = PIXELFORMAT_XRGB8888;
	PIXELFORMAT_XBGR32 = PIXELFORMAT_RGBX8888;
}

Init :: fn (flags: InitFlags) bool #extern "SDL_Init";
Quit :: fn () #extern "SDL_Quit";
CreateWindow :: fn (title: *C.char, w: s32, h: s32, flags: WindowFlags) *Window #extern "SDL_CreateWindow";
DestroyWindow :: fn (window: *Window) #extern "SDL_DestroyWindow";
PollEvent :: fn (event: *Event) bool #extern "SDL_PollEvent";
PushEvent :: fn (event: *Event) bool #extern "SDL_PushEvent";
RegisterEvents :: fn (numevents: s32) u32 #extern "SDL_RegisterEvents";
WaitEventTimeout :: fn (event: *Event, timeoutMS: s32) bool #extern "SDL_WaitEventTimeout";
SetHint :: fn (name: *C.char, value: *C.char) bool #extern "SDL_SetHint";
GL_SetAttribute :: fn (attr: GLAttr, value: s32) bool #extern "SDL_GL_SetAttribute";
GL_GetAttribute :: fn (attr: GLAttr, value: *s32) bool #extern "SDL_GL_GetAttribute";
GL_CreateContext :: fn (window: *Window) GLContext #extern "SDL_GL_CreateContext";
GL_DestroyContext :: fn (context: GLContext) bool #extern "SDL_GL_DestroyContext";
GL_MakeCurrent :: fn (window: *Window, context: GLContext) bool #extern "SDL_GL_MakeCurrent";
GL_SwapWindow :: fn (window: *Window) bool #extern "SDL_GL_SwapWindow";
GL_GetCurrentContext :: fn () GLContext #extern "SDL_GL_GetCurrentContext";
GetWindowSize :: fn (window: *Window, w: *s32, h: *s32) bool #extern "SDL_GetWindowSize";
GetWindowSizeInPixels :: fn (window: *Window, w: *s32, h: *s32) bool #extern "SDL_GetWindowSizeInPixels";
GetWindowDisplayScale :: fn (window: *Window) f32 #extern "SDL_GetWindowDisplayScale";
GetCurrentVideoDriver :: fn () *C.char #extern "SDL_GetCurrentVideoDriver";
GetError :: fn () *C.char #extern "SDL_GetError";
GetTicks :: fn () u32 #extern "SDL_GetTicks"; // in ms
CreateSystemCursor :: fn (id: SystemCursor) *Cursor #extern "SDL_CreateSystemCursor";
DestroyCursor :: fn (cursor: *Cursor) #extern "SDL_DestroyCursor";
SetCursor :: fn (cursor: *Cursor) bool #extern "SDL_SetCursor";
EnableScreenSaver :: fn () bool #extern "SDL_EnableScreenSaver";
SetWindowTitle :: fn (window: *Window, title: *C.char) bool #extern "SDL_SetWindowTitle";
free :: fn (mem: *u8) #extern "SDL_free";
SetClipboardText :: fn (text: *C.char) bool #extern "SDL_SetClipboardText";
GetClipboardText :: fn () *C.char #extern "SDL_GetClipboardText";
HasClipboardText :: fn () bool #extern "SDL_HasClipboardText";
GL_SetSwapInterval :: fn (interval: s32) bool #extern "SDL_GL_SetSwapInterval";
MaximizeWindow :: fn (window: *Window) bool #extern "SDL_MaximizeWindow";
StartTextInput :: fn (window: *Window) bool #extern "SDL_StartTextInput";
StopTextInput :: fn (window: *Window) bool #extern "SDL_StopTextInput";
GetModState :: fn () Keymod #extern "SDL_GetModState";
GetMouseState :: fn (x: *f32, y: *f32) MouseButtonFlags #extern "SDL_GetMouseState";
GetRelativeMouseState :: fn (x: *f32, y: *f32) MouseButtonFlags #extern "SDL_GetRelativeMouseState";

EventFilter :: *fn (userdata: *u8, event: *Event) bool;
AddEventWatch :: fn (filter: EventFilter, userdata: *u8 = null) bool #extern "SDL_AddEventWatch";

CreateSurfaceFrom :: fn (width: s32, height: s32, format: PixelFormat, pixels: *u8, pitch: s32) *Surface #extern "SDL_CreateSurfaceFrom";
DestroySurface :: fn (surface: *Surface) #extern "SDL_DestroySurface";
SetWindowIcon :: fn (window: *Window, icon: *Surface) bool #extern "SDL_SetWindowIcon";
ShowCursor :: fn () bool #extern "SDL_ShowCursor";
HideCursor :: fn () bool #extern "SDL_HideCursor";
SetWindowRelativeMouseMode :: fn (window: *Window, enabled: bool) bool #extern "SDL_SetWindowRelativeMouseMode";

MessageBoxFlags :: u32;

MESSAGEBOX_ERROR : MessageBoxFlags :                    0x00000010; /**< error dialog */
MESSAGEBOX_WARNING : MessageBoxFlags :                  0x00000020; /**< warning dialog */
MESSAGEBOX_INFORMATION : MessageBoxFlags :              0x00000040; /**< informational dialog */
MESSAGEBOX_BUTTONS_LEFT_TO_RIGHT : MessageBoxFlags :    0x00000080; /**< buttons placed left to right */
MESSAGEBOX_BUTTONS_RIGHT_TO_LEFT : MessageBoxFlags :    0x00000100; /**< buttons placed right to left */

MessageBoxButtonFlags :: u32;

SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT : MessageBoxButtonFlags : 0x00000001; /**< Marks the default button when return is hit */
SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT : MessageBoxButtonFlags : 0x00000002; /**< Marks the default button when escape is hit */

MessageBoxButtonData :: struct {
	flags: MessageBoxButtonFlags;
	buttonID: s32;       /**< User defined button id (value returned via SDL_ShowMessageBox) */
	text: *C.char;       /**< The UTF-8 button text */
}

MessageBoxColorScheme :: u8; // @Incomplete 2025-03-23

MessageBoxData :: struct {
	flags: MessageBoxFlags;
	window: *Window;                 /**< Parent window, can be NULL */
	title: *C.char;                  /**< UTF-8 title */
	message: *C.char;                /**< UTF-8 message text */

	numbuttons: s32;
	buttons: *MessageBoxButtonData;

	colorScheme: *MessageBoxColorScheme;   /**< SDL_MessageBoxColorScheme, can be NULL to use system settings */
}

ShowSimpleMessageBox :: fn (flags: MessageBoxFlags, title: *C.char, message: *C.char, window: *Window) bool #extern "SDL_ShowSimpleMessageBox";
ShowMessageBox :: fn (messageboxdata: *MessageBoxData, buttonid: *s32) bool #extern "SDL_ShowMessageBox";
GetDisplays :: fn (count: *s32) *DisplayID #extern "SDL_GetDisplays";
GetDisplayBounds :: fn (displayID: DisplayID, rect: *Rect) bool #extern "SDL_GetDisplayBounds";
GetPrimaryDisplay :: fn () DisplayID #extern "SDL_GetPrimaryDisplay";
SetWindowPosition :: fn (window: *Window, x: s32, y: s32) bool #extern "SDL_SetWindowPosition";
SetWindowMouseGrab :: fn (window: *Window, grabbed: bool) bool #extern "SDL_SetWindowMouseGrab";
ShowWindow :: fn (window: *Window) bool #extern "SDL_ShowWindow";
CreateColorCursor :: fn (surface: *Surface, hot_x: s32, hot_y: s32) *Cursor #extern "SDL_CreateColorCursor";

DialogFileCallback :: *fn (userdata: *u8, filelist: **C.char, filter: s32);

DialogFileFilter :: struct {
	name: *C.char;
	pattern: *C.char;
}

ShowOpenFileDialog :: fn (callback: DialogFileCallback, userdata: *u8, window: *Window, filters: *DialogFileFilter, nfilters: s32, default_location: *C.char, allow_many: bool) #extern "SDL_ShowOpenFileDialog";


//
// Vulkan
//

VkInstance :: *u8;
VkAllocationCallbacks :: u8;
VkSurfaceKHR :: *u8;

Vulkan_CreateSurface :: fn (window: *Window, instance: VkInstance, allocator: *VkAllocationCallbacks, surface: *VkSurfaceKHR) bool #extern "SDL_Vulkan_CreateSurface";
Vulkan_DestroySurface :: fn (instance: VkInstance, surface: VkSurfaceKHR, allocator: *VkAllocationCallbacks) #extern "SDL_Vulkan_DestroySurface";
Vulkan_GetInstanceExtensions :: fn (count: *u32) **C.char #extern "SDL_Vulkan_GetInstanceExtensions";

#scope_module
C :: #import "libc";