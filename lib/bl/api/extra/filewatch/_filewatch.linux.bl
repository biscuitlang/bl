FileWatch :: struct {
	thread:  Thread;
	pool:    PoolAllocator;
	watches: Table(string_view, Watch);
	lock:    Mutex;

	stop: bool;
}

new_filewatch :: fn () (*FileWatch, Error) {
	fw :: new(FileWatch) catch return null, $;
	fw.pool = pool_make();

	mutex_init(&fw.lock) catch {
		free(auto fw);
		return null, $;
	};

	tbl_init(&fw.watches, 256, &fw.pool);

	thread :: thread_create(auto &worker, auto fw) catch {
		free(auto fw);
		mutex_terminate(&fw.lock);
		release_allocator(&fw.pool);
		return null, $;
	};

	fw.thread = thread;

	return fw, OK;
}

delete_filewatch :: fn (fw: *FileWatch) {
	if !fw then return;

	watches : []Watch : fw.watches.values;
	loop i := 0; i < watches.len; i += 1 {
		terminate_watch(&watches[i]);
	}

	fw.stop = true;
	thread_join(fw.thread);
	release_allocator(&fw.pool);
	mutex_terminate(&fw.lock);

	free(auto fw);
}

watch_changes :: fn (fw: *FileWatch, path: string_view) Error {
	mutex_lock(&fw.lock);
	defer mutex_unlock(&fw.lock);

	normalized_path := str_make(path, application_context.temporary_allocator);
	path_normalize(&normalized_path) catch return $;

	if tbl_contains(&fw.watches, normalized_path) then return error("File '%' is already watched.", normalized_path);

	isdir :: is_directory(normalized_path) catch {
		return $;
	};

	if isdir {
		w: Watch;
		init_dir_watch(&w, normalized_path) catch return $;
		tbl_insert(&fw.watches, str_make(normalized_path, &fw.pool), w);
	} else {
		// @Incomeplete
	}

	return OK;
}

poll_file_changes :: fn (fw: *FileWatch) {
}

#scope_module

Watch :: struct {
	kind: enum { FILE; DIR; };
	data: union {
		file: struct {
			_: u8;
		};

		dir: struct {
			nfd:  s32;
		};
	};
}

C :: #import "libc";
#import "os/linux/sys/inotify"
#import "std/fs"
#import "std/array"
#import "std/table"
#import "std/string"
#import "std/thread"
#import "std/sync"
#import "std/pool"

init_dir_watch :: fn (w: *Watch, dirpath: string_view) Error {
	w.kind = Watch.kind.DIR;

	nfd :: inotify_init();
	if nfd < 0 then return os_get_last_error2();
	C.fcntl(nfd, C.F_SETFL, C.O_NONBLOCK);

	w.data.dir.nfd = nfd;

	install_dir_recursive(w, dirpath) catch {
		C.close(nfd);
		return $;
	};

	return OK;
}

terminate_watch :: fn (w: *Watch) {
	using Watch.kind;
	switch w.kind {
		DIR {
			nfd :: w.data.dir.nfd;
			inotify_rm_watch(nfd, -1); // flush all
			C.close(nfd);
		}

		FILE {
		}
	}
}

DIR_WATCH_MASK :: IDMask.MOVE | IDMask.CREATE | IDMask.DELETE | IDMask.DELETE_SELF | IDMask.MOVE_SELF;

install_dir_recursive :: fn (w: *Watch, dirpath: string_view) Error {
	nfd :: w.data.dir.nfd;
	inotify_rm_watch(nfd, -1); // flush all

	fd :: inotify_add_watch(nfd, strtoc(dirpath), DIR_WATCH_MASK);
	if fd < 0 then return os_get_last_error2();

	visit_err :: visit_files(dirpath, VisitOpt.{ recursive = true }, &nfd, &fn (info: *FileVisitInfo, nfd: *s32) Error {
			if !info.is_directory then return OK;
			print_log("Watch: %", info.filepath);

			fd :: inotify_add_watch(@nfd, strtoc(info.filepath), DIR_WATCH_MASK);
			if fd < 0 then return os_get_last_error2();

			return OK;
		});

	if visit_err {
		inotify_rm_watch(nfd, -1); // flush all
		return visit_err;
	}

	return OK;
}

process_watch :: fn (w: *Watch, path: string_view) Error {
	using Watch.kind;
	switch w.kind {
		DIR {
			buf: [(OS_NAME_MAX + auto sizeof(inotify_event)) * 256]s8 #noinit;
			rebuild := false;

			length :: C.read(w.data.dir.nfd, buf.ptr, auto buf.len);
			if (length < 0) {
				err :: os_get_last_error2();
				if err.code == C.EAGAIN || err.code == C.EWOULDBLOCK {
					return OK; // Wait
				}
				return err;
			}

			loop i : s64 = 0; i < length; {
				event :: cast(*inotify_event)&buf[i];
				print_log("% %", event.mask, inotify_event_name(event));
				i += auto (event.len + sizeof(inotify_event));

				using IDMask;
				if is_flag(event.mask, ISDIR) {
					rebuild = true;
				}
			}

			if rebuild {
				return install_dir_recursive(w, path);
			}
		}

		FILE {
		}
	}

	return OK;
}

worker :: fn (fw: *FileWatch) s32 {

	loop !fw.stop {

		{
			mutex_lock(&fw.lock);
			defer mutex_unlock(&fw.lock);

			watches : []Watch       : fw.watches.values;
			paths   : []string_view : fw.watches.keys;

			loop i := 0; i < watches.len; i += 1 {
				process_watch(&watches[i], paths[i]);
			}
		}

		os_sleep_ms(200);
	}

	return 0;
}

