// Generated file, do not edit unless you know what you are doing!

VK_MAKE_API_VERSION :: fn (variant: u32, major: u32, minor: u32, patch: u32) u32 #comptime {
	return (variant << 29) | (major << 22) | (minor << 12) | patch;
}

VK_API_VERSION_1_0 :: VK_MAKE_API_VERSION(0, 1, 0, 0);

VK_HEADER_VERSION : u32 : 231;

VK_HEADER_VERSION_COMPLETE :: VK_MAKE_API_VERSION(0, 1, 3, VK_HEADER_VERSION);

VK_API_VERSION_VARIANT :: fn (version: u32) u32 #comptime {
	return version >> 29;
}

VK_API_VERSION_MAJOR :: fn (version: u32) u32 #comptime {
	return (version >> 22) & 0x7F;
}

VK_API_VERSION_MINOR :: fn (version: u32) u32 #comptime {
	return (version >> 12) & 0x3FF;
}

VK_API_VERSION_PATCH :: fn (version: u32) u32 #comptime {
	return version & 0xFFF;
}

VK_NULL_HANDLE : C.void_ptr : null;
VK_SHADER_UNUSED_KHR : u32 : 0xFFFFFFFF;

VkBool32 :: u32;
VkDeviceAddress :: u64;
VkDeviceSize :: u64;
VkFlags :: u32;
VkSampleMask :: u32;
VkBuffer :: *u8;
VkImage :: *u8;
VkInstance :: *u8;
VkPhysicalDevice :: *u8;
VkDevice :: *u8;
VkQueue :: *u8;
VkSemaphore :: *u8;
VkCommandBuffer :: *u8;
VkFence :: *u8;
VkDeviceMemory :: *u8;
VkEvent :: *u8;
VkQueryPool :: *u8;
VkBufferView :: *u8;
VkImageView :: *u8;
VkShaderModule :: *u8;
VkPipelineCache :: *u8;
VkPipelineLayout :: *u8;
VkPipeline :: *u8;
VkRenderPass :: *u8;
VkDescriptorSetLayout :: *u8;
VkSampler :: *u8;
VkDescriptorSet :: *u8;
VkDescriptorPool :: *u8;
VkFramebuffer :: *u8;
VkCommandPool :: *u8;
VkSamplerYcbcrConversion :: *u8;
VkDescriptorUpdateTemplate :: *u8;
VkPrivateDataSlot :: *u8;
VkSurfaceKHR :: *u8;
VkSwapchainKHR :: *u8;
VkDisplayKHR :: *u8;
VkDisplayModeKHR :: *u8;
VkDeferredOperationKHR :: *u8;
VkDebugReportCallbackEXT :: *u8;
VkCuModuleNVX :: *u8;
VkCuFunctionNVX :: *u8;
VkDebugUtilsMessengerEXT :: *u8;
VkValidationCacheEXT :: *u8;
VkAccelerationStructureNV :: *u8;
VkPerformanceConfigurationINTEL :: *u8;
VkIndirectCommandsLayoutNV :: *u8;
VkMicromapEXT :: *u8;
VkOpticalFlowSessionNV :: *u8;
VkAccelerationStructureKHR :: *u8;

VK_ATTACHMENT_UNUSED              : u32 : (~0);
VK_FALSE                          : u32 : 0;
VK_LOD_CLAMP_NONE                 : f64 : 1000.0;
VK_QUEUE_FAMILY_IGNORED           : u32 : ~0;
VK_REMAINING_ARRAY_LAYERS         : u32 : ~0;
VK_REMAINING_MIP_LEVELS           : u32 : ~0;
VK_SUBPASS_EXTERNAL               : u32 : ~0;
VK_TRUE                           : u32 : 1;
VK_WHOLE_SIZE                     : u64 : 0xffffffffffffffff;
VK_MAX_MEMORY_TYPES               : u32 : 32;
VK_MAX_PHYSICAL_DEVICE_NAME_SIZE  : u32 : 256;
VK_UUID_SIZE                      : u32 : 16;
VK_MAX_EXTENSION_NAME_SIZE        : u32 : 256;
VK_MAX_DESCRIPTION_SIZE           : u32 : 256;
VK_MAX_MEMORY_HEAPS               : u32 : 16;

VkResult :: enum s32 {
	VK_SUCCESS = 0x0;
	VK_NOT_READY = 0x1;
	VK_TIMEOUT = 0x2;
	VK_EVENT_SET = 0x3;
	VK_EVENT_RESET = 0x4;
	VK_INCOMPLETE = 0x5;
	VK_ERROR_OUT_OF_HOST_MEMORY = -0x1;
	VK_ERROR_OUT_OF_DEVICE_MEMORY = -0x2;
	VK_ERROR_INITIALIZATION_FAILED = -0x3;
	VK_ERROR_DEVICE_LOST = -0x4;
	VK_ERROR_MEMORY_MAP_FAILED = -0x5;
	VK_ERROR_LAYER_NOT_PRESENT = -0x6;
	VK_ERROR_EXTENSION_NOT_PRESENT = -0x7;
	VK_ERROR_FEATURE_NOT_PRESENT = -0x8;
	VK_ERROR_INCOMPATIBLE_DRIVER = -0x9;
	VK_ERROR_TOO_MANY_OBJECTS = -0xa;
	VK_ERROR_FORMAT_NOT_SUPPORTED = -0xb;
	VK_ERROR_FRAGMENTED_POOL = -0xc;
	VK_ERROR_UNKNOWN = -0xd;
	VK_ERROR_OUT_OF_POOL_MEMORY = -0x3b9bd788;
	VK_ERROR_INVALID_EXTERNAL_HANDLE = -0x3b9be343;
	VK_ERROR_FRAGMENTATION = -0x3b9d3ee8;
	VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = -0x3b9eb5e8;
	VK_PIPELINE_COMPILE_REQUIRED = 0x3b9f5228;
	VK_ERROR_SURFACE_LOST_KHR = -0x3b9aca00;
	VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -0x3b9aca01;
	VK_SUBOPTIMAL_KHR = 0x3b9acdeb;
	VK_ERROR_OUT_OF_DATE_KHR = -0x3b9acdec;
	VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -0x3b9ad5b9;
	VK_ERROR_VALIDATION_FAILED_EXT = -0x3b9af4f9;
	VK_ERROR_INVALID_SHADER_NV = -0x3b9af8e0;
	VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -0x3b9d3330;
	VK_ERROR_NOT_PERMITTED_KHR = -0x3b9d71b1;
	VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = -0x3b9eae18;
	VK_THREAD_IDLE_KHR = 0x3b9ee0e0;
	VK_THREAD_DONE_KHR = 0x3b9ee0e1;
	VK_OPERATION_DEFERRED_KHR = 0x3b9ee0e2;
	VK_OPERATION_NOT_DEFERRED_KHR = 0x3b9ee0e3;
	VK_ERROR_COMPRESSION_EXHAUSTED_EXT = -0x3b9ff250;
	VK_ERROR_OUT_OF_POOL_MEMORY_KHR = -0x3b9bd788;
	VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR = -0x3b9be343;
	VK_ERROR_FRAGMENTATION_EXT = -0x3b9d3ee8;
	VK_ERROR_NOT_PERMITTED_EXT = -0x3b9d71b1;
	VK_ERROR_INVALID_DEVICE_ADDRESS_EXT = -0x3b9eb5e8;
	VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR = -0x3b9eb5e8;
	VK_PIPELINE_COMPILE_REQUIRED_EXT = 0x3b9f5228;
	VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT = 0x3b9f5228;
	VK_RESULT_MAX_ENUM = 0x7fffffff;
}

VkStructureType :: enum s32 {
	VK_STRUCTURE_TYPE_APPLICATION_INFO = 0x0;
	VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 0x1;
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 0x2;
	VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 0x3;
	VK_STRUCTURE_TYPE_SUBMIT_INFO = 0x4;
	VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 0x5;
	VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 0x6;
	VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 0x7;
	VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 0x8;
	VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 0x9;
	VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 0xa;
	VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 0xb;
	VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 0xc;
	VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 0xd;
	VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 0xe;
	VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 0xf;
	VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 0x10;
	VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 0x11;
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 0x12;
	VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 0x13;
	VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 0x14;
	VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 0x15;
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 0x16;
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 0x17;
	VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 0x18;
	VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 0x19;
	VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 0x1a;
	VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 0x1b;
	VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 0x1c;
	VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 0x1d;
	VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 0x1e;
	VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 0x1f;
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 0x20;
	VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 0x21;
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 0x22;
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 0x23;
	VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 0x24;
	VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 0x25;
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 0x26;
	VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 0x27;
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 0x28;
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 0x29;
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 0x2a;
	VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 0x2b;
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 0x2c;
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 0x2d;
	VK_STRUCTURE_TYPE_MEMORY_BARRIER = 0x2e;
	VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 0x2f;
	VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 0x30;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = 0x3b9c3930;
	VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 0x3b9d2f48;
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 0x3b9d2f49;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = 0x3b9c0e38;
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS = 0x3b9cba18;
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO = 0x3b9cba19;
	VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO = 0x3b9bb460;
	VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = 0x3b9bb463;
	VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = 0x3b9bb464;
	VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO = 0x3b9bb465;
	VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO = 0x3b9bb466;
	VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = 0x3b9bb46d;
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = 0x3b9bb46e;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES = 0x3b9bdb70;
	VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO = 0x3b9bdb71;
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 = 0x3b9d0450;
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 = 0x3b9d0451;
	VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = 0x3b9d0452;
	VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 = 0x3b9d0453;
	VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = 0x3b9d0454;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 = 0x3b9bb078;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 = 0x3b9bb079;
	VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 = 0x3b9bb07a;
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 = 0x3b9bb07b;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = 0x3b9bb07c;
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 = 0x3b9bb07d;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = 0x3b9bb07e;
	VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 = 0x3b9bb07f;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = 0x3b9bb080;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = 0x3b9c9308;
	VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = 0x3b9c9309;
	VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO = 0x3b9c930a;
	VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 0x3b9c930b;
	VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO = 0x3b9b9908;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES = 0x3b9b9909;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = 0x3b9b990a;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES = 0x3b9c9ec0;
	VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO = 0x3b9d0068;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = 0x3b9d0069;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = 0x3b9d006a;
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 = 0x3b9d006b;
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO = 0x3b9d2b60;
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO = 0x3b9d2b61;
	VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO = 0x3b9d2b62;
	VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = 0x3b9d2b63;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 0x3b9d2b64;
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 0x3b9d2b65;
	VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = 0x3b9c1608;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = 0x3b9bdf58;
	VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES = 0x3b9bdf59;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = 0x3b9bdf5a;
	VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES = 0x3b9bdf5b;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES = 0x3b9bdf5c;
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO = 0x3b9be340;
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO = 0x3b9be341;
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO = 0x3b9be342;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 0x3b9c7f80;
	VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 0x3b9c7f81;
	VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 0x3b9c8368;
	VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 0x3b9bf6c8;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 0x3b9bf2e0;
	VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 0x3b9bf2e1;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = 0x3b9d5a40;
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT = 0x3b9d5a41;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES = 0x3b9bc018;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES = 0x31;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES = 0x32;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES = 0x33;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES = 0x34;
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO = 0x3b9d0838;
	VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2 = 0x3b9c73c8;
	VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2 = 0x3b9c73c9;
	VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2 = 0x3b9c73ca;
	VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2 = 0x3b9c73cb;
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2 = 0x3b9c73cc;
	VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO = 0x3b9c73cd;
	VK_STRUCTURE_TYPE_SUBPASS_END_INFO = 0x3b9c73ce;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES = 0x3b9d7d68;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES = 0x3b9dc7a0;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES = 0x3b9d8920;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES = 0x3b9c0a50;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES = 0x3b9dcb88;
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO = 0x3b9d3ee8;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES = 0x3b9d3ee9;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES = 0x3b9d3eea;
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO = 0x3b9d3eeb;
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT = 0x3b9d3eec;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES = 0x3b9dd358;
	VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE = 0x3b9dd359;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES = 0x3b9e2948;
	VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO = 0x3b9e8af0;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES = 0x3b9cc5d0;
	VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO = 0x3b9cc5d1;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES = 0x3b9e0238;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES = 0x3b9c6fe0;
	VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO = 0x3b9c6fe1;
	VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO = 0x3b9c6fe2;
	VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO = 0x3b9c6fe3;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES = 0x3b9ea648;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES = 0x3b9d7598;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES = 0x3b9e7768;
	VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT = 0x3b9e7769;
	VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT = 0x3b9e776a;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES = 0x3b9ec588;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES = 0x3b9df298;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES = 0x3b9df299;
	VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO = 0x3b9df29a;
	VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO = 0x3b9df29b;
	VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO = 0x3b9df29c;
	VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO = 0x3b9df29d;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES = 0x3b9eb5e8;
	VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO = 0x3b9e8321;
	VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO = 0x3b9eb5ea;
	VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO = 0x3b9eb5eb;
	VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO = 0x3b9eb5ec;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES = 0x35;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES = 0x36;
	VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO = 0x3b9db800;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES = 0x3b9e11d8;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES = 0x3b9e8708;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES = 0x3b9f0020;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES = 0x3b9f4a58;
	VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO = 0x3b9f4a59;
	VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO = 0x3b9f4a5a;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES = 0x3b9f5228;
	VK_STRUCTURE_TYPE_MEMORY_BARRIER_2 = 0x3b9f9490;
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2 = 0x3b9f9491;
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2 = 0x3b9f9492;
	VK_STRUCTURE_TYPE_DEPENDENCY_INFO = 0x3b9f9493;
	VK_STRUCTURE_TYPE_SUBMIT_INFO_2 = 0x3b9f9494;
	VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO = 0x3b9f9495;
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO = 0x3b9f9496;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES = 0x3b9f9497;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES = 0x3b9fbf88;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES = 0x3b9fe698;
	VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2 = 0x3b9fee68;
	VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2 = 0x3b9fee69;
	VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2 = 0x3b9fee6a;
	VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2 = 0x3b9fee6b;
	VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2 = 0x3b9fee6c;
	VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2 = 0x3b9fee6d;
	VK_STRUCTURE_TYPE_BUFFER_COPY_2 = 0x3b9fee6e;
	VK_STRUCTURE_TYPE_IMAGE_COPY_2 = 0x3b9fee6f;
	VK_STRUCTURE_TYPE_IMAGE_BLIT_2 = 0x3b9fee70;
	VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2 = 0x3b9fee71;
	VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2 = 0x3b9fee72;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES = 0x3b9e38e8;
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO = 0x3b9e38e9;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES = 0x3b9e38ea;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES = 0x3b9ce510;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES = 0x3b9ce511;
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK = 0x3b9ce512;
	VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO = 0x3b9ce513;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES = 0x3b9bcbd0;
	VK_STRUCTURE_TYPE_RENDERING_INFO = 0x3b9b75e0;
	VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO = 0x3b9b75e1;
	VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO = 0x3b9b75e2;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES = 0x3b9b75e3;
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO = 0x3b9b75e4;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES = 0x3b9f0fc0;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES = 0x3b9f0fc1;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES = 0x3b9f13a9;
	VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 = 0x3ba04840;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES = 0x3ba11748;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES = 0x3ba11749;
	VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS = 0x3ba1174a;
	VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS = 0x3ba1174b;
	VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 0x3b9acde8;
	VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 0x3b9acde9;
	VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 0x3b9bb467;
	VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 0x3b9bb468;
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 0x3b9bb469;
	VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR = 0x3b9bb46a;
	VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR = 0x3b9bb46b;
	VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 0x3b9bb46c;
	VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 0x3b9ad1d0;
	VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 0x3b9ad1d1;
	VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 0x3b9ad5b8;
	VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 0x3b9ad9a0;
	VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 0x3b9add88;
	VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 0x3b9ae170;
	VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 0x3b9ae940;
	VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 0x3b9aed28;
	VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 0x3b9af4f8;
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 0x3b9b1050;
	VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 0x3b9b1ff0;
	VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 0x3b9b1ff1;
	VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 0x3b9b1ff2;
	VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 0x3b9b2f90;
	VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 0x3b9b2f91;
	VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 0x3b9b2f92;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT = 0x3b9b3760;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT = 0x3b9b3761;
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT = 0x3b9b3762;
	VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX = 0x3b9b3b48;
	VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX = 0x3b9b3b49;
	VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX = 0x3b9b3b4a;
	VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX = 0x3b9b3f30;
	VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX = 0x3b9b3f31;
	VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 0x3b9b6a28;
	VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 0x3b9b75e6;
	VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT = 0x3b9b75e7;
	VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD = 0x3b9b75e8;
	VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX = 0x3b9b75e9;
	VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP = 0x3b9b8968;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV = 0x3b9b8d50;
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 0x3b9ba4c0;
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 0x3b9ba4c1;
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 0x3b9ba8a8;
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 0x3b9ba8a9;
	VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 0x3b9bac90;
	VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = 0x3b9bb848;
	VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN = 0x3b9bbc30;
	VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT = 0x3b9bcfb8;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT = 0x3b9bcfb9;
	VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT = 0x3b9bd3a0;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT = 0x3b9bd3a1;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT = 0x3b9bd3a2;
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 0x3b9be728;
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 0x3b9be729;
	VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 0x3b9be72a;
	VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = 0x3b9be72b;
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 0x3b9beb10;
	VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 0x3b9beb11;
	VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 0x3b9beb12;
	VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 0x3b9beef8;
	VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 0x3b9bfab0;
	VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 0x3b9bfab1;
	VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR = 0x3b9bfab2;
	VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 0x3b9bfab3;
	VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 0x3b9bfe98;
	VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 0x3b9bfe99;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = 0x3b9c0280;
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 0x3b9c0668;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 0x3b9c0669;
	VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT = 0x3b9c066a;
	VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR = 0x3b9c1220;
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = 0x3b9c1dd8;
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT = 0x3b9c2990;
	VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT = 0x3b9c2d78;
	VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT = 0x3b9c2d79;
	VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT = 0x3b9c2d7a;
	VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 0x3b9c2d7b;
	VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE = 0x3b9c3160;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 0x3b9c44e8;
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 0x3b9c48d0;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 0x3b9c4cb8;
	VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 0x3b9c4cb9;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = 0x3b9c5488;
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = 0x3b9c5489;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT = 0x3b9c5870;
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT = 0x3b9c5871;
	VK_STRUCTURE_TYPE_HDR_METADATA_EXT = 0x3b9c6428;
	VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = 0x3b9c7b98;
	VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 0x3b9c8750;
	VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 0x3b9c8751;
	VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR = 0x3b9c8752;
	VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 0x3b9c8b38;
	VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 0x3b9c8b39;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR = 0x3b9c8f20;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR = 0x3b9c8f21;
	VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR = 0x3b9c8f22;
	VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR = 0x3b9c8f23;
	VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR = 0x3b9c8f24;
	VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR = 0x3b9c8f25;
	VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR = 0x3b9c8f26;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 0x3b9c9ad8;
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR = 0x3b9c9ad9;
	VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR = 0x3b9c9ada;
	VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR = 0x3b9ca2a8;
	VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR = 0x3b9ca2a9;
	VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR = 0x3b9ca2aa;
	VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR = 0x3b9ca2ab;
	VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR = 0x3b9ca2ac;
	VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK = 0x3b9ca690;
	VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK = 0x3b9caa78;
	VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT = 0x3b9cbe00;
	VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT = 0x3b9cbe01;
	VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT = 0x3b9cbe02;
	VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = 0x3b9cbe03;
	VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = 0x3b9cbe04;
	VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = 0x3b9cc1e8;
	VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = 0x3b9cc1e9;
	VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = 0x3b9cc1ea;
	VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 0x3b9cc1eb;
	VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 0x3b9cc1ec;
	VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID = 0x3b9cc1ed;
	VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID = 0x3b9cc1ee;
	VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT = 0x3b9cf898;
	VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 0x3b9cf899;
	VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 0x3b9cf89a;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = 0x3b9cf89b;
	VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT = 0x3b9cf89c;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = 0x3b9d0c20;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = 0x3b9d0c21;
	VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = 0x3b9d0c22;
	VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = 0x3b9d1008;
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR = 0x3b9d13f7;
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR = 0x3b9d13f0;
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR = 0x3b9d13f2;
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR = 0x3b9d13f3;
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR = 0x3b9d13f4;
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR = 0x3b9d13f5;
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR = 0x3b9d13f6;
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR = 0x3b9d13f9;
	VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR = 0x3b9d13fa;
	VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR = 0x3b9d13fb;
	VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR = 0x3b9d13fc;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR = 0x3b9d13fd;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR = 0x3b9d13fe;
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR = 0x3b9d1401;
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR = 0x3b9d1404;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR = 0x3ba01578;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR = 0x3ba01579;
	VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR = 0x3b9d13ff;
	VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR = 0x3b9d1400;
	VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR = 0x3b9d1402;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR = 0x3ba0196d;
	VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = 0x3b9d1bc0;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV = 0x3b9d2390;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV = 0x3b9d2391;
	VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 0x3b9d3330;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 0x3b9d3332;
	VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 0x3b9d3333;
	VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 0x3b9d3334;
	VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 0x3b9d3335;
	VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT = 0x3b9d3336;
	VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 0x3b9d3b00;
	VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 0x3b9d3b01;
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV = 0x3b9d4aa0;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV = 0x3b9d4aa1;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV = 0x3b9d4aa2;
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV = 0x3b9d4aa5;
	VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV = 0x3b9d4e88;
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV = 0x3b9d4e89;
	VK_STRUCTURE_TYPE_GEOMETRY_NV = 0x3b9d4e8b;
	VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV = 0x3b9d4e8c;
	VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV = 0x3b9d4e8d;
	VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV = 0x3b9d4e8e;
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV = 0x3b9d4e8f;
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV = 0x3b9d4e90;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV = 0x3b9d4e91;
	VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV = 0x3b9d4e93;
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV = 0x3b9d4e94;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV = 0x3b9d5270;
	VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV = 0x3b9d5271;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT = 0x3b9d6210;
	VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT = 0x3b9d6211;
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT = 0x3b9d8150;
	VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT = 0x3b9d8151;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = 0x3b9d8152;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR = 0x3b9d8d08;
	VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD = 0x3b9d94d8;
	VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT = 0x3b9d98c0;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = 0x3b9d9ca8;
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR = 0x3b9d71b0;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR = 0x3ba0b5a0;
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR = 0x3ba0b5a1;
	VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD = 0x3b9dac48;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = 0x3b9db030;
	VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT = 0x3b9db031;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT = 0x3b9db032;
	VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP = 0x3b9db418;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV = 0x3b9ddb28;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV = 0x3b9ddf10;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV = 0x3b9ddf11;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV = 0x3b9de6e0;
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV = 0x3b9deac8;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV = 0x3b9deaca;
	VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV = 0x3b9deeb0;
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV = 0x3b9deeb1;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL = 0x3b9dfa68;
	VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL = 0x3b9dfe50;
	VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL = 0x3b9dfe51;
	VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL = 0x3b9dfe52;
	VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL = 0x3b9dfe53;
	VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL = 0x3b9dfe54;
	VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL = 0x3b9dfe55;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT = 0x3b9e0620;
	VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD = 0x3b9e0a08;
	VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD = 0x3b9e0a09;
	VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA = 0x3b9e0df0;
	VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT = 0x3b9e19a8;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT = 0x3b9e1d90;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT = 0x3b9e1d91;
	VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT = 0x3b9e1d92;
	VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 0x3b9e3cd0;
	VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR = 0x3b9e3cd1;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR = 0x3b9e3cd2;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR = 0x3b9e3cd3;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR = 0x3b9e3cd4;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD = 0x3b9e40b8;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD = 0x3b9e4888;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT = 0x3b9e5c10;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT = 0x3b9e67c8;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT = 0x3b9e6bb0;
	VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT = 0x3b9e6bb1;
	VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR = 0x3b9e6f98;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV = 0x3b9e7380;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT = 0x3b9e8320;
	VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT = 0x3b9e8322;
	VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT = 0x3b9e8ed8;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR = 0x3b9e92c0;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV = 0x3b9e96a8;
	VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV = 0x3b9e96a9;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV = 0x3b9e96aa;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV = 0x3b9e9a90;
	VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV = 0x3b9e9a91;
	VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV = 0x3b9e9a92;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT = 0x3b9e9e78;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT = 0x3b9ea260;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT = 0x3b9eaa30;
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT = 0x3b9eaa31;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT = 0x3b9eaa32;
	VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT = 0x3b9eae18;
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT = 0x3b9eae1a;
	VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT = 0x3b9eae19;
	VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT = 0x3b9eb200;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT = 0x3b9ebdb8;
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT = 0x3b9ebdb9;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT = 0x3b9ebdba;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT = 0x3b9ec1a0;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT = 0x3b9ed528;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT = 0x3b9edcf8;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR = 0x3b9ee4c8;
	VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR = 0x3b9ee4c9;
	VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR = 0x3b9ee4ca;
	VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR = 0x3b9ee4cb;
	VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR = 0x3b9ee4cc;
	VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR = 0x3b9ee4cd;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT = 0x3b9ef468;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV = 0x3b9f0408;
	VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV = 0x3b9f0409;
	VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV = 0x3b9f040a;
	VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV = 0x3b9f040b;
	VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV = 0x3b9f040c;
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV = 0x3b9f040d;
	VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV = 0x3b9f040e;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV = 0x3b9f040f;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV = 0x3b9f07f0;
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV = 0x3b9f07f1;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT = 0x3b9f13a8;
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM = 0x3b9f1790;
	VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM = 0x3b9f1791;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT = 0x3b9f1f60;
	VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT = 0x3b9f1f61;
	VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT = 0x3b9f1f62;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT = 0x3b9f2730;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT = 0x3b9f2731;
	VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT = 0x3b9f2b18;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT = 0x3b9f2b19;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT = 0x3b9f2b1a;
	VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR = 0x3b9f36d0;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV = 0x3b9f3ea0;
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV = 0x3b9f3ea1;
	VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV = 0x3b9f3ea2;
	VK_STRUCTURE_TYPE_PRESENT_ID_KHR = 0x3b9f4670;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR = 0x3b9f4671;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV = 0x3b9f5de0;
	VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV = 0x3b9f5de1;
	VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT = 0x3b9f88d8;
	VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT = 0x3b9f88d9;
	VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT = 0x3b9f88da;
	VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT = 0x3b9f88db;
	VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT = 0x3b9f88dc;
	VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT = 0x3b9f88dd;
	VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT = 0x3b9f88de;
	VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT = 0x3b9f88df;
	VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT = 0x3b9f88e0;
	VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT = 0x3b9f88e1;
	VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT = 0x3b9f88e2;
	VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT = 0x3b9f88e3;
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV = 0x3b9f9498;
	VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV = 0x3b9f9499;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT = 0x3b9fac00;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT = 0x3b9fac01;
	VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT = 0x3b9fac02;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD = 0x3b9fafe8;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR = 0x3b9de2f8;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR = 0x3b9fb3d0;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR = 0x3b9fb7b8;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV = 0x3b9fc370;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV = 0x3b9fc371;
	VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV = 0x3b9fc372;
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV = 0x3b9fc758;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV = 0x3b9fc759;
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV = 0x3b9fc75a;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT = 0x3b9fcb40;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT = 0x3b9fcb41;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT = 0x3b9fd310;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT = 0x3b9fdae0;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT = 0x3b9fdae1;
	VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM = 0x3b9fdec8;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR = 0x3b9fea80;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT = 0x3b9ff250;
	VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT = 0x3b9ff251;
	VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT = 0x3b9ff252;
	VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT = 0x3b9ff253;
	VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT = 0x3b9ff254;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT = 0x3b9ff638;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT = 0x3b9ffa20;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT = 0x3b9ffe08;
	VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT = 0x3b9ffe09;
	VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT = 0x3b9ffe0a;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT = 0x3ba009c0;
	VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT = 0x3ba01190;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT = 0x3ba02900;
	VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT = 0x3ba02901;
	VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT = 0x3ba02902;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT = 0x3ba02ce8;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT = 0x3ba030d0;
	VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT = 0x3ba030d1;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT = 0x3ba034b8;
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT = 0x3ba034b9;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT = 0x3ba038a0;
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA = 0x3ba057e0;
	VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA = 0x3ba057e1;
	VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 0x3ba057e2;
	VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA = 0x3ba05bc8;
	VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 0x3ba05bc9;
	VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA = 0x3ba05fb0;
	VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA = 0x3ba05fb1;
	VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA = 0x3ba05fb2;
	VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA = 0x3ba05fb3;
	VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA = 0x3ba05fb4;
	VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA = 0x3ba05fb5;
	VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA = 0x3ba05fb6;
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA = 0x3ba05fb7;
	VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA = 0x3ba05fb8;
	VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA = 0x3ba05fb9;
	VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI = 0x3ba06b68;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI = 0x3ba06b69;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI = 0x3ba06b6a;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI = 0x3ba06f50;
	VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV = 0x3ba07338;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV = 0x3ba07339;
	VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT = 0x3ba07720;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT = 0x3ba07721;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT = 0x3ba086c0;
	VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT = 0x3ba086c1;
	VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT = 0x3ba086c2;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT = 0x3ba08aa8;
	VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX = 0x3ba08e90;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT = 0x3ba09a48;
	VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT = 0x3ba09a49;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT = 0x3ba09e30;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR = 0x3ba0add0;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT = 0x3ba0c158;
	VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT = 0x3ba0c159;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT = 0x3ba0c540;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT = 0x3ba0c541;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT = 0x3ba0c928;
	VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT = 0x3ba0d4e0;
	VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT = 0x3ba0d4e1;
	VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT = 0x3ba0d4e2;
	VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT = 0x3ba0d4e3;
	VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT = 0x3ba0d4e4;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT = 0x3ba0d4e5;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT = 0x3ba0d4e6;
	VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT = 0x3ba0d4e7;
	VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT = 0x3ba0d4e8;
	VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT = 0x3ba0d4e9;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT = 0x3ba10f78;
	VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT = 0x3ba10f79;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT = 0x3ba11360;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE = 0x3ba132a0;
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE = 0x3ba132a1;
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE = 0x3ba132a2;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT = 0x3ba13688;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT = 0x3ba13a70;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM = 0x3ba14628;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM = 0x3ba14629;
	VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM = 0x3ba1462a;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV = 0x3ba159b0;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT = 0x3ba17508;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM = 0x3ba180c0;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM = 0x3ba180c1;
	VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM = 0x3ba180c2;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT = 0x3ba1bb58;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT = 0x3ba1bb59;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT = 0x3ba1c710;
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT = 0x3ba1c711;
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT = 0x3ba1c712;
	VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT = 0x3ba1c713;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT = 0x3ba1d6b0;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT = 0x3ba1d6b1;
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT = 0x3ba1d6b2;
	VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT = 0x3ba1d6b3;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT = 0x3ba001f0;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV = 0x3ba1de80;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV = 0x3ba1de81;
	VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV = 0x3ba1de82;
	VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV = 0x3ba1de83;
	VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV = 0x3ba1de84;
	VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV = 0x3ba1de85;
	VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV = 0x3ba1de8a;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT = 0x3ba1e268;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT = 0x3ba1e650;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM = 0x3ba22ca0;
	VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM = 0x3ba22ca1;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC = 0x3ba23088;
	VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC = 0x3ba23089;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT = 0x3ba02518;
	VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT = 0x3ba0251a;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM = 0x3ba25f68;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM = 0x3ba25f69;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = 0x3b9c9ec0;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = 0x3b9bc018;
	VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT = 0x3b9af4f8;
	VK_STRUCTURE_TYPE_RENDERING_INFO_KHR = 0x3b9b75e0;
	VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR = 0x3b9b75e1;
	VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR = 0x3b9b75e2;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR = 0x3b9b75e3;
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR = 0x3b9b75e4;
	VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV = 0x3b9b75e8;
	VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR = 0x3b9b9908;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR = 0x3b9b9909;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR = 0x3b9b990a;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR = 0x3b9bb078;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR = 0x3b9bb079;
	VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR = 0x3b9bb07a;
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR = 0x3b9bb07b;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR = 0x3b9bb07c;
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR = 0x3b9bb07d;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR = 0x3b9bb07e;
	VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR = 0x3b9bb07f;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR = 0x3b9bb080;
	VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR = 0x3b9bb460;
	VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR = 0x3b9bb463;
	VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR = 0x3b9bb464;
	VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR = 0x3b9bb465;
	VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR = 0x3b9bb466;
	VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR = 0x3b9bb46d;
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR = 0x3b9bb46e;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT = 0x3b9bcbd0;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR = 0x3b9bdb70;
	VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR = 0x3b9bdb71;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR = 0x3b9bdf58;
	VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR = 0x3b9bdf59;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR = 0x3b9bdf5a;
	VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR = 0x3b9bdf5b;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR = 0x3b9bdf5c;
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR = 0x3b9be340;
	VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR = 0x3b9be341;
	VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR = 0x3b9be342;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR = 0x3b9bf2e0;
	VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR = 0x3b9bf2e1;
	VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR = 0x3b9bf6c8;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR = 0x3b9c0a50;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR = 0x3b9c0a50;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR = 0x3b9c0e38;
	VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR = 0x3b9c1608;
	VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT = 0x3b9c2990;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR = 0x3b9c6fe0;
	VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR = 0x3b9c6fe1;
	VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR = 0x3b9c6fe2;
	VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR = 0x3b9c6fe3;
	VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR = 0x3b9c73c8;
	VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR = 0x3b9c73c9;
	VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR = 0x3b9c73ca;
	VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR = 0x3b9c73cb;
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR = 0x3b9c73cc;
	VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR = 0x3b9c73cd;
	VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR = 0x3b9c73ce;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR = 0x3b9c7f80;
	VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR = 0x3b9c7f81;
	VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR = 0x3b9c8368;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR = 0x3b9c9308;
	VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR = 0x3b9c9309;
	VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR = 0x3b9c930a;
	VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR = 0x3b9c930b;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR = 0x3b9c9ec0;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR = 0x3b9c9ec0;
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR = 0x3b9cba18;
	VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR = 0x3b9cba19;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT = 0x3b9cc5d0;
	VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT = 0x3b9cc5d1;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT = 0x3b9ce510;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT = 0x3b9ce511;
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT = 0x3b9ce512;
	VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT = 0x3b9ce513;
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR = 0x3b9d0450;
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR = 0x3b9d0451;
	VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR = 0x3b9d0452;
	VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR = 0x3b9d0453;
	VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR = 0x3b9d0454;
	VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR = 0x3b9d0838;
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR = 0x3b9d2b60;
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR = 0x3b9d2b61;
	VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR = 0x3b9d2b62;
	VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR = 0x3b9d2b63;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR = 0x3b9d2b64;
	VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR = 0x3b9d2b65;
	VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR = 0x3b9d2f48;
	VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR = 0x3b9d2f49;
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT = 0x3b9d3ee8;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT = 0x3b9d3ee9;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT = 0x3b9d3eea;
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT = 0x3b9d3eeb;
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT = 0x3b9d3eec;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR = 0x3b9d5a40;
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR = 0x3b9d5a41;
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT = 0x3b9d71b0;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR = 0x3b9d7598;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR = 0x3b9d7d68;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR = 0x3b9d8920;
	VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT = 0x3b9db800;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR = 0x3b9dc7a0;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR = 0x3b9dcb88;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR = 0x3b9dd358;
	VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR = 0x3b9dd359;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV = 0x3b9de2f8;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR = 0x3b9df298;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR = 0x3b9df299;
	VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR = 0x3b9df29a;
	VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR = 0x3b9df29b;
	VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR = 0x3b9df29c;
	VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR = 0x3b9df29d;
	VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL = 0x3b9dfe50;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR = 0x3b9e0238;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR = 0x3b9e11d8;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT = 0x3b9e2948;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT = 0x3b9e38e8;
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT = 0x3b9e38e9;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT = 0x3b9e38ea;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR = 0x3b9e7768;
	VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR = 0x3b9e7769;
	VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR = 0x3b9e776a;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT = 0x3b9e8320;
	VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT = 0x3b9e8321;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT = 0x3b9e8708;
	VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT = 0x3b9e8af0;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR = 0x3b9ea648;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR = 0x3b9eb5e8;
	VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR = 0x3b9e8321;
	VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR = 0x3b9eb5ea;
	VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR = 0x3b9eb5eb;
	VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR = 0x3b9eb5ec;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT = 0x3b9ec588;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT = 0x3b9f0020;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR = 0x3b9f0fc0;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR = 0x3b9f0fc1;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT = 0x3b9f13a9;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT = 0x3b9f4a58;
	VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT = 0x3b9f4a59;
	VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT = 0x3b9f4a5a;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT = 0x3b9f5228;
	VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR = 0x3b9f9490;
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR = 0x3b9f9491;
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR = 0x3b9f9492;
	VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR = 0x3b9f9493;
	VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR = 0x3b9f9494;
	VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR = 0x3b9f9495;
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR = 0x3b9f9496;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR = 0x3b9f9497;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR = 0x3b9fbf88;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT = 0x3b9fe698;
	VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR = 0x3b9fee68;
	VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR = 0x3b9fee69;
	VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR = 0x3b9fee6a;
	VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR = 0x3b9fee6b;
	VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR = 0x3b9fee6c;
	VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR = 0x3b9fee6d;
	VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR = 0x3b9fee6e;
	VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR = 0x3b9fee6f;
	VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR = 0x3b9fee70;
	VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR = 0x3b9fee71;
	VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR = 0x3b9fee72;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM = 0x3ba001f0;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE = 0x3ba02518;
	VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE = 0x3ba0251a;
	VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR = 0x3ba04840;
	VK_STRUCTURE_TYPE_PIPELINE_INFO_EXT = 0x3b9ee4c9;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT = 0x3ba0b5a0;
	VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT = 0x3ba0b5a1;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR = 0x3ba11748;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR = 0x3ba11749;
	VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR = 0x3ba1174a;
	VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR = 0x3ba1174b;
	VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV = 1000568000;
	VK_STRUCTURE_TYPE_MAX_ENUM = 0x7fffffff;
}

VkPipelineCacheHeaderVersion :: enum s32 {
	VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 0x1;
	VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM = 0x7fffffff;
}
VkImageLayout :: enum s32 {
	VK_IMAGE_LAYOUT_UNDEFINED = 0x0;
	VK_IMAGE_LAYOUT_GENERAL = 0x1;
	VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 0x2;
	VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 0x3;
	VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 0x4;
	VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 0x5;
	VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 0x6;
	VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 0x7;
	VK_IMAGE_LAYOUT_PREINITIALIZED = 0x8;
	VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 0x3b9c9308;
	VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 0x3b9c9309;
	VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL = 0x3b9e7768;
	VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL = 0x3b9e7769;
	VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL = 0x3b9e776a;
	VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL = 0x3b9e776b;
	VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL = 0x3b9f9490;
	VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL = 0x3b9f9491;
	VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 0x3b9acdea;
	VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR = 0x3b9c7b98;
	VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = 0x3b9e1d90;
	VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR = 0x3b9d4aa3;
	VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT = 0x3b9ff638;
	VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR = 0x3b9c9308;
	VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR = 0x3b9c9309;
	VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV = 0x3b9d4aa3;
	VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR = 0x3b9e7768;
	VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR = 0x3b9e7769;
	VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR = 0x3b9e776a;
	VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR = 0x3b9e776b;
	VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR = 0x3b9f9490;
	VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR = 0x3b9f9491;
	VK_IMAGE_LAYOUT_MAX_ENUM = 0x7fffffff;
}
VkObjectType :: enum s32 {
	VK_OBJECT_TYPE_UNKNOWN = 0x0;
	VK_OBJECT_TYPE_INSTANCE = 0x1;
	VK_OBJECT_TYPE_PHYSICAL_DEVICE = 0x2;
	VK_OBJECT_TYPE_DEVICE = 0x3;
	VK_OBJECT_TYPE_QUEUE = 0x4;
	VK_OBJECT_TYPE_SEMAPHORE = 0x5;
	VK_OBJECT_TYPE_COMMAND_BUFFER = 0x6;
	VK_OBJECT_TYPE_FENCE = 0x7;
	VK_OBJECT_TYPE_DEVICE_MEMORY = 0x8;
	VK_OBJECT_TYPE_BUFFER = 0x9;
	VK_OBJECT_TYPE_IMAGE = 0xa;
	VK_OBJECT_TYPE_EVENT = 0xb;
	VK_OBJECT_TYPE_QUERY_POOL = 0xc;
	VK_OBJECT_TYPE_BUFFER_VIEW = 0xd;
	VK_OBJECT_TYPE_IMAGE_VIEW = 0xe;
	VK_OBJECT_TYPE_SHADER_MODULE = 0xf;
	VK_OBJECT_TYPE_PIPELINE_CACHE = 0x10;
	VK_OBJECT_TYPE_PIPELINE_LAYOUT = 0x11;
	VK_OBJECT_TYPE_RENDER_PASS = 0x12;
	VK_OBJECT_TYPE_PIPELINE = 0x13;
	VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT = 0x14;
	VK_OBJECT_TYPE_SAMPLER = 0x15;
	VK_OBJECT_TYPE_DESCRIPTOR_POOL = 0x16;
	VK_OBJECT_TYPE_DESCRIPTOR_SET = 0x17;
	VK_OBJECT_TYPE_FRAMEBUFFER = 0x18;
	VK_OBJECT_TYPE_COMMAND_POOL = 0x19;
	VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION = 0x3b9d2b60;
	VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE = 0x3b9c1608;
	VK_OBJECT_TYPE_PRIVATE_DATA_SLOT = 0x3b9f4a58;
	VK_OBJECT_TYPE_SURFACE_KHR = 0x3b9aca00;
	VK_OBJECT_TYPE_SWAPCHAIN_KHR = 0x3b9acde8;
	VK_OBJECT_TYPE_DISPLAY_KHR = 0x3b9ad1d0;
	VK_OBJECT_TYPE_DISPLAY_MODE_KHR = 0x3b9ad1d1;
	VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT = 0x3b9af4f8;
	VK_OBJECT_TYPE_CU_MODULE_NVX = 0x3b9b3b48;
	VK_OBJECT_TYPE_CU_FUNCTION_NVX = 0x3b9b3b49;
	VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT = 0x3b9cbe00;
	VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR = 0x3b9d13f0;
	VK_OBJECT_TYPE_VALIDATION_CACHE_EXT = 0x3b9d3b00;
	VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV = 0x3b9d4e88;
	VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL = 0x3b9dfe50;
	VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR = 0x3b9ee0e0;
	VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV = 0x3b9f0408;
	VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA = 0x3ba05fb0;
	VK_OBJECT_TYPE_MICROMAP_EXT = 0x3ba0d4e0;
	VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV = 0x3ba1de80;
	VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR = 0x3b9c1608;
	VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR = 0x3b9d2b60;
	VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT = 0x3b9f4a58;
	VK_OBJECT_TYPE_MAX_ENUM = 0x7fffffff;
}
VkVendorId :: enum s32 {
	VK_VENDOR_ID_VIV = 0x10001;
	VK_VENDOR_ID_VSI = 0x10002;
	VK_VENDOR_ID_KAZAN = 0x10003;
	VK_VENDOR_ID_CODEPLAY = 0x10004;
	VK_VENDOR_ID_MESA = 0x10005;
	VK_VENDOR_ID_POCL = 0x10006;
	VK_VENDOR_ID_MAX_ENUM = 0x7fffffff;
}
VkSystemAllocationScope :: enum s32 {
	VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0x0;
	VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 0x1;
	VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 0x2;
	VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 0x3;
	VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 0x4;
	VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM = 0x7fffffff;
}
VkInternalAllocationType :: enum s32 {
	VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0x0;
	VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM = 0x7fffffff;
}
VkFormat :: enum s32 {
	VK_FORMAT_UNDEFINED = 0x0;
	VK_FORMAT_R4G4_UNORM_PACK8 = 0x1;
	VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 0x2;
	VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 0x3;
	VK_FORMAT_R5G6B5_UNORM_PACK16 = 0x4;
	VK_FORMAT_B5G6R5_UNORM_PACK16 = 0x5;
	VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 0x6;
	VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 0x7;
	VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 0x8;
	VK_FORMAT_R8_UNORM = 0x9;
	VK_FORMAT_R8_SNORM = 0xa;
	VK_FORMAT_R8_USCALED = 0xb;
	VK_FORMAT_R8_SSCALED = 0xc;
	VK_FORMAT_R8_UINT = 0xd;
	VK_FORMAT_R8_SINT = 0xe;
	VK_FORMAT_R8_SRGB = 0xf;
	VK_FORMAT_R8G8_UNORM = 0x10;
	VK_FORMAT_R8G8_SNORM = 0x11;
	VK_FORMAT_R8G8_USCALED = 0x12;
	VK_FORMAT_R8G8_SSCALED = 0x13;
	VK_FORMAT_R8G8_UINT = 0x14;
	VK_FORMAT_R8G8_SINT = 0x15;
	VK_FORMAT_R8G8_SRGB = 0x16;
	VK_FORMAT_R8G8B8_UNORM = 0x17;
	VK_FORMAT_R8G8B8_SNORM = 0x18;
	VK_FORMAT_R8G8B8_USCALED = 0x19;
	VK_FORMAT_R8G8B8_SSCALED = 0x1a;
	VK_FORMAT_R8G8B8_UINT = 0x1b;
	VK_FORMAT_R8G8B8_SINT = 0x1c;
	VK_FORMAT_R8G8B8_SRGB = 0x1d;
	VK_FORMAT_B8G8R8_UNORM = 0x1e;
	VK_FORMAT_B8G8R8_SNORM = 0x1f;
	VK_FORMAT_B8G8R8_USCALED = 0x20;
	VK_FORMAT_B8G8R8_SSCALED = 0x21;
	VK_FORMAT_B8G8R8_UINT = 0x22;
	VK_FORMAT_B8G8R8_SINT = 0x23;
	VK_FORMAT_B8G8R8_SRGB = 0x24;
	VK_FORMAT_R8G8B8A8_UNORM = 0x25;
	VK_FORMAT_R8G8B8A8_SNORM = 0x26;
	VK_FORMAT_R8G8B8A8_USCALED = 0x27;
	VK_FORMAT_R8G8B8A8_SSCALED = 0x28;
	VK_FORMAT_R8G8B8A8_UINT = 0x29;
	VK_FORMAT_R8G8B8A8_SINT = 0x2a;
	VK_FORMAT_R8G8B8A8_SRGB = 0x2b;
	VK_FORMAT_B8G8R8A8_UNORM = 0x2c;
	VK_FORMAT_B8G8R8A8_SNORM = 0x2d;
	VK_FORMAT_B8G8R8A8_USCALED = 0x2e;
	VK_FORMAT_B8G8R8A8_SSCALED = 0x2f;
	VK_FORMAT_B8G8R8A8_UINT = 0x30;
	VK_FORMAT_B8G8R8A8_SINT = 0x31;
	VK_FORMAT_B8G8R8A8_SRGB = 0x32;
	VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 0x33;
	VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 0x34;
	VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 0x35;
	VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 0x36;
	VK_FORMAT_A8B8G8R8_UINT_PACK32 = 0x37;
	VK_FORMAT_A8B8G8R8_SINT_PACK32 = 0x38;
	VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 0x39;
	VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 0x3a;
	VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 0x3b;
	VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 0x3c;
	VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 0x3d;
	VK_FORMAT_A2R10G10B10_UINT_PACK32 = 0x3e;
	VK_FORMAT_A2R10G10B10_SINT_PACK32 = 0x3f;
	VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 0x40;
	VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 0x41;
	VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 0x42;
	VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 0x43;
	VK_FORMAT_A2B10G10R10_UINT_PACK32 = 0x44;
	VK_FORMAT_A2B10G10R10_SINT_PACK32 = 0x45;
	VK_FORMAT_R16_UNORM = 0x46;
	VK_FORMAT_R16_SNORM = 0x47;
	VK_FORMAT_R16_USCALED = 0x48;
	VK_FORMAT_R16_SSCALED = 0x49;
	VK_FORMAT_R16_UINT = 0x4a;
	VK_FORMAT_R16_SINT = 0x4b;
	VK_FORMAT_R16_SFLOAT = 0x4c;
	VK_FORMAT_R16G16_UNORM = 0x4d;
	VK_FORMAT_R16G16_SNORM = 0x4e;
	VK_FORMAT_R16G16_USCALED = 0x4f;
	VK_FORMAT_R16G16_SSCALED = 0x50;
	VK_FORMAT_R16G16_UINT = 0x51;
	VK_FORMAT_R16G16_SINT = 0x52;
	VK_FORMAT_R16G16_SFLOAT = 0x53;
	VK_FORMAT_R16G16B16_UNORM = 0x54;
	VK_FORMAT_R16G16B16_SNORM = 0x55;
	VK_FORMAT_R16G16B16_USCALED = 0x56;
	VK_FORMAT_R16G16B16_SSCALED = 0x57;
	VK_FORMAT_R16G16B16_UINT = 0x58;
	VK_FORMAT_R16G16B16_SINT = 0x59;
	VK_FORMAT_R16G16B16_SFLOAT = 0x5a;
	VK_FORMAT_R16G16B16A16_UNORM = 0x5b;
	VK_FORMAT_R16G16B16A16_SNORM = 0x5c;
	VK_FORMAT_R16G16B16A16_USCALED = 0x5d;
	VK_FORMAT_R16G16B16A16_SSCALED = 0x5e;
	VK_FORMAT_R16G16B16A16_UINT = 0x5f;
	VK_FORMAT_R16G16B16A16_SINT = 0x60;
	VK_FORMAT_R16G16B16A16_SFLOAT = 0x61;
	VK_FORMAT_R32_UINT = 0x62;
	VK_FORMAT_R32_SINT = 0x63;
	VK_FORMAT_R32_SFLOAT = 0x64;
	VK_FORMAT_R32G32_UINT = 0x65;
	VK_FORMAT_R32G32_SINT = 0x66;
	VK_FORMAT_R32G32_SFLOAT = 0x67;
	VK_FORMAT_R32G32B32_UINT = 0x68;
	VK_FORMAT_R32G32B32_SINT = 0x69;
	VK_FORMAT_R32G32B32_SFLOAT = 0x6a;
	VK_FORMAT_R32G32B32A32_UINT = 0x6b;
	VK_FORMAT_R32G32B32A32_SINT = 0x6c;
	VK_FORMAT_R32G32B32A32_SFLOAT = 0x6d;
	VK_FORMAT_R64_UINT = 0x6e;
	VK_FORMAT_R64_SINT = 0x6f;
	VK_FORMAT_R64_SFLOAT = 0x70;
	VK_FORMAT_R64G64_UINT = 0x71;
	VK_FORMAT_R64G64_SINT = 0x72;
	VK_FORMAT_R64G64_SFLOAT = 0x73;
	VK_FORMAT_R64G64B64_UINT = 0x74;
	VK_FORMAT_R64G64B64_SINT = 0x75;
	VK_FORMAT_R64G64B64_SFLOAT = 0x76;
	VK_FORMAT_R64G64B64A64_UINT = 0x77;
	VK_FORMAT_R64G64B64A64_SINT = 0x78;
	VK_FORMAT_R64G64B64A64_SFLOAT = 0x79;
	VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 0x7a;
	VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 0x7b;
	VK_FORMAT_D16_UNORM = 0x7c;
	VK_FORMAT_X8_D24_UNORM_PACK32 = 0x7d;
	VK_FORMAT_D32_SFLOAT = 0x7e;
	VK_FORMAT_S8_UINT = 0x7f;
	VK_FORMAT_D16_UNORM_S8_UINT = 0x80;
	VK_FORMAT_D24_UNORM_S8_UINT = 0x81;
	VK_FORMAT_D32_SFLOAT_S8_UINT = 0x82;
	VK_FORMAT_BC1_RGB_UNORM_BLOCK = 0x83;
	VK_FORMAT_BC1_RGB_SRGB_BLOCK = 0x84;
	VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 0x85;
	VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 0x86;
	VK_FORMAT_BC2_UNORM_BLOCK = 0x87;
	VK_FORMAT_BC2_SRGB_BLOCK = 0x88;
	VK_FORMAT_BC3_UNORM_BLOCK = 0x89;
	VK_FORMAT_BC3_SRGB_BLOCK = 0x8a;
	VK_FORMAT_BC4_UNORM_BLOCK = 0x8b;
	VK_FORMAT_BC4_SNORM_BLOCK = 0x8c;
	VK_FORMAT_BC5_UNORM_BLOCK = 0x8d;
	VK_FORMAT_BC5_SNORM_BLOCK = 0x8e;
	VK_FORMAT_BC6H_UFLOAT_BLOCK = 0x8f;
	VK_FORMAT_BC6H_SFLOAT_BLOCK = 0x90;
	VK_FORMAT_BC7_UNORM_BLOCK = 0x91;
	VK_FORMAT_BC7_SRGB_BLOCK = 0x92;
	VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 0x93;
	VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 0x94;
	VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 0x95;
	VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 0x96;
	VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 0x97;
	VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 0x98;
	VK_FORMAT_EAC_R11_UNORM_BLOCK = 0x99;
	VK_FORMAT_EAC_R11_SNORM_BLOCK = 0x9a;
	VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 0x9b;
	VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 0x9c;
	VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 0x9d;
	VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 0x9e;
	VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 0x9f;
	VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 0xa0;
	VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 0xa1;
	VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 0xa2;
	VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 0xa3;
	VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 0xa4;
	VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 0xa5;
	VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 0xa6;
	VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 0xa7;
	VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 0xa8;
	VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 0xa9;
	VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 0xaa;
	VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 0xab;
	VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 0xac;
	VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 0xad;
	VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 0xae;
	VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 0xaf;
	VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 0xb0;
	VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 0xb1;
	VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 0xb2;
	VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 0xb3;
	VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 0xb4;
	VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 0xb5;
	VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 0xb6;
	VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 0xb7;
	VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 0xb8;
	VK_FORMAT_G8B8G8R8_422_UNORM = 0x3b9d2b60;
	VK_FORMAT_B8G8R8G8_422_UNORM = 0x3b9d2b61;
	VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM = 0x3b9d2b62;
	VK_FORMAT_G8_B8R8_2PLANE_420_UNORM = 0x3b9d2b63;
	VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM = 0x3b9d2b64;
	VK_FORMAT_G8_B8R8_2PLANE_422_UNORM = 0x3b9d2b65;
	VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM = 0x3b9d2b66;
	VK_FORMAT_R10X6_UNORM_PACK16 = 0x3b9d2b67;
	VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 0x3b9d2b68;
	VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 0x3b9d2b69;
	VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 0x3b9d2b6a;
	VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 0x3b9d2b6b;
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 0x3b9d2b6c;
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 0x3b9d2b6d;
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 0x3b9d2b6e;
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 0x3b9d2b6f;
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 0x3b9d2b70;
	VK_FORMAT_R12X4_UNORM_PACK16 = 0x3b9d2b71;
	VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 0x3b9d2b72;
	VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 0x3b9d2b73;
	VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 0x3b9d2b74;
	VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 0x3b9d2b75;
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 0x3b9d2b76;
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 0x3b9d2b77;
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 0x3b9d2b78;
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 0x3b9d2b79;
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 0x3b9d2b7a;
	VK_FORMAT_G16B16G16R16_422_UNORM = 0x3b9d2b7b;
	VK_FORMAT_B16G16R16G16_422_UNORM = 0x3b9d2b7c;
	VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM = 0x3b9d2b7d;
	VK_FORMAT_G16_B16R16_2PLANE_420_UNORM = 0x3b9d2b7e;
	VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM = 0x3b9d2b7f;
	VK_FORMAT_G16_B16R16_2PLANE_422_UNORM = 0x3b9d2b80;
	VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM = 0x3b9d2b81;
	VK_FORMAT_G8_B8R8_2PLANE_444_UNORM = 0x3b9fd310;
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16 = 0x3b9fd311;
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16 = 0x3b9fd312;
	VK_FORMAT_G16_B16R16_2PLANE_444_UNORM = 0x3b9fd313;
	VK_FORMAT_A4R4G4B4_UNORM_PACK16 = 0x3b9ffa20;
	VK_FORMAT_A4B4G4R4_UNORM_PACK16 = 0x3b9ffa21;
	VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK = 0x3b9bcbd0;
	VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK = 0x3b9bcbd1;
	VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK = 0x3b9bcbd2;
	VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK = 0x3b9bcbd3;
	VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK = 0x3b9bcbd4;
	VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK = 0x3b9bcbd5;
	VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK = 0x3b9bcbd6;
	VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK = 0x3b9bcbd7;
	VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK = 0x3b9bcbd8;
	VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK = 0x3b9bcbd9;
	VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK = 0x3b9bcbda;
	VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK = 0x3b9bcbdb;
	VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK = 0x3b9bcbdc;
	VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK = 0x3b9bcbdd;
	VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 0x3b9b9cf0;
	VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 0x3b9b9cf1;
	VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 0x3b9b9cf2;
	VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 0x3b9b9cf3;
	VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 0x3b9b9cf4;
	VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 0x3b9b9cf5;
	VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 0x3b9b9cf6;
	VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 0x3b9b9cf7;
	VK_FORMAT_R16G16_S10_5_NV = 0x3ba1de80;
	VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT = 0x3b9bcbd0;
	VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT = 0x3b9bcbd1;
	VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT = 0x3b9bcbd2;
	VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT = 0x3b9bcbd3;
	VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT = 0x3b9bcbd4;
	VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT = 0x3b9bcbd5;
	VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT = 0x3b9bcbd6;
	VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT = 0x3b9bcbd7;
	VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT = 0x3b9bcbd8;
	VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT = 0x3b9bcbd9;
	VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT = 0x3b9bcbda;
	VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT = 0x3b9bcbdb;
	VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT = 0x3b9bcbdc;
	VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT = 0x3b9bcbdd;
	VK_FORMAT_G8B8G8R8_422_UNORM_KHR = 0x3b9d2b60;
	VK_FORMAT_B8G8R8G8_422_UNORM_KHR = 0x3b9d2b61;
	VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR = 0x3b9d2b62;
	VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR = 0x3b9d2b63;
	VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR = 0x3b9d2b64;
	VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR = 0x3b9d2b65;
	VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR = 0x3b9d2b66;
	VK_FORMAT_R10X6_UNORM_PACK16_KHR = 0x3b9d2b67;
	VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR = 0x3b9d2b68;
	VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR = 0x3b9d2b69;
	VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR = 0x3b9d2b6a;
	VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR = 0x3b9d2b6b;
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR = 0x3b9d2b6c;
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR = 0x3b9d2b6d;
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR = 0x3b9d2b6e;
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR = 0x3b9d2b6f;
	VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR = 0x3b9d2b70;
	VK_FORMAT_R12X4_UNORM_PACK16_KHR = 0x3b9d2b71;
	VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR = 0x3b9d2b72;
	VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR = 0x3b9d2b73;
	VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR = 0x3b9d2b74;
	VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR = 0x3b9d2b75;
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR = 0x3b9d2b76;
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR = 0x3b9d2b77;
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR = 0x3b9d2b78;
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR = 0x3b9d2b79;
	VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR = 0x3b9d2b7a;
	VK_FORMAT_G16B16G16R16_422_UNORM_KHR = 0x3b9d2b7b;
	VK_FORMAT_B16G16R16G16_422_UNORM_KHR = 0x3b9d2b7c;
	VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR = 0x3b9d2b7d;
	VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR = 0x3b9d2b7e;
	VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR = 0x3b9d2b7f;
	VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR = 0x3b9d2b80;
	VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR = 0x3b9d2b81;
	VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT = 0x3b9fd310;
	VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT = 0x3b9fd311;
	VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT = 0x3b9fd312;
	VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT = 0x3b9fd313;
	VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT = 0x3b9ffa20;
	VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT = 0x3b9ffa21;
	VK_FORMAT_MAX_ENUM = 0x7fffffff;
}
VkImageTiling :: enum s32 {
	VK_IMAGE_TILING_OPTIMAL = 0x0;
	VK_IMAGE_TILING_LINEAR = 0x1;
	VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = 0x3b9d3330;
	VK_IMAGE_TILING_MAX_ENUM = 0x7fffffff;
}
VkImageType :: enum s32 {
	VK_IMAGE_TYPE_1D = 0x0;
	VK_IMAGE_TYPE_2D = 0x1;
	VK_IMAGE_TYPE_3D = 0x2;
	VK_IMAGE_TYPE_MAX_ENUM = 0x7fffffff;
}
VkPhysicalDeviceType :: enum s32 {
	VK_PHYSICAL_DEVICE_TYPE_OTHER = 0x0;
	VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 0x1;
	VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 0x2;
	VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 0x3;
	VK_PHYSICAL_DEVICE_TYPE_CPU = 0x4;
	VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM = 0x7fffffff;
}
VkQueryType :: enum s32 {
	VK_QUERY_TYPE_OCCLUSION = 0x0;
	VK_QUERY_TYPE_PIPELINE_STATISTICS = 0x1;
	VK_QUERY_TYPE_TIMESTAMP = 0x2;
	VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT = 0x3b9b3764;
	VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR = 0x3b9c8f20;
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR = 0x3b9d13f0;
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR = 0x3b9d13f1;
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV = 0x3b9d4e88;
	VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL = 0x3b9dfe50;
	VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT = 0x3b9fcb40;
	VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT = 0x3ba09e30;
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR = 0x3ba0add0;
	VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR = 0x3ba0add1;
	VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT = 0x3ba0d4e0;
	VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT = 0x3ba0d4e1;
	VK_QUERY_TYPE_MAX_ENUM = 0x7fffffff;
}
VkSharingMode :: enum s32 {
	VK_SHARING_MODE_EXCLUSIVE = 0x0;
	VK_SHARING_MODE_CONCURRENT = 0x1;
	VK_SHARING_MODE_MAX_ENUM = 0x7fffffff;
}
VkComponentSwizzle :: enum s32 {
	VK_COMPONENT_SWIZZLE_IDENTITY = 0x0;
	VK_COMPONENT_SWIZZLE_ZERO = 0x1;
	VK_COMPONENT_SWIZZLE_ONE = 0x2;
	VK_COMPONENT_SWIZZLE_R = 0x3;
	VK_COMPONENT_SWIZZLE_G = 0x4;
	VK_COMPONENT_SWIZZLE_B = 0x5;
	VK_COMPONENT_SWIZZLE_A = 0x6;
	VK_COMPONENT_SWIZZLE_MAX_ENUM = 0x7fffffff;
}
VkImageViewType :: enum s32 {
	VK_IMAGE_VIEW_TYPE_1D = 0x0;
	VK_IMAGE_VIEW_TYPE_2D = 0x1;
	VK_IMAGE_VIEW_TYPE_3D = 0x2;
	VK_IMAGE_VIEW_TYPE_CUBE = 0x3;
	VK_IMAGE_VIEW_TYPE_1D_ARRAY = 0x4;
	VK_IMAGE_VIEW_TYPE_2D_ARRAY = 0x5;
	VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 0x6;
	VK_IMAGE_VIEW_TYPE_MAX_ENUM = 0x7fffffff;
}
VkBlendFactor :: enum s32 {
	VK_BLEND_FACTOR_ZERO = 0x0;
	VK_BLEND_FACTOR_ONE = 0x1;
	VK_BLEND_FACTOR_SRC_COLOR = 0x2;
	VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 0x3;
	VK_BLEND_FACTOR_DST_COLOR = 0x4;
	VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 0x5;
	VK_BLEND_FACTOR_SRC_ALPHA = 0x6;
	VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 0x7;
	VK_BLEND_FACTOR_DST_ALPHA = 0x8;
	VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 0x9;
	VK_BLEND_FACTOR_CONSTANT_COLOR = 0xa;
	VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 0xb;
	VK_BLEND_FACTOR_CONSTANT_ALPHA = 0xc;
	VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 0xd;
	VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 0xe;
	VK_BLEND_FACTOR_SRC1_COLOR = 0xf;
	VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 0x10;
	VK_BLEND_FACTOR_SRC1_ALPHA = 0x11;
	VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 0x12;
	VK_BLEND_FACTOR_MAX_ENUM = 0x7fffffff;
}
VkBlendOp :: enum s32 {
	VK_BLEND_OP_ADD = 0x0;
	VK_BLEND_OP_SUBTRACT = 0x1;
	VK_BLEND_OP_REVERSE_SUBTRACT = 0x2;
	VK_BLEND_OP_MIN = 0x3;
	VK_BLEND_OP_MAX = 0x4;
	VK_BLEND_OP_ZERO_EXT = 0x3b9d0c20;
	VK_BLEND_OP_SRC_EXT = 0x3b9d0c21;
	VK_BLEND_OP_DST_EXT = 0x3b9d0c22;
	VK_BLEND_OP_SRC_OVER_EXT = 0x3b9d0c23;
	VK_BLEND_OP_DST_OVER_EXT = 0x3b9d0c24;
	VK_BLEND_OP_SRC_IN_EXT = 0x3b9d0c25;
	VK_BLEND_OP_DST_IN_EXT = 0x3b9d0c26;
	VK_BLEND_OP_SRC_OUT_EXT = 0x3b9d0c27;
	VK_BLEND_OP_DST_OUT_EXT = 0x3b9d0c28;
	VK_BLEND_OP_SRC_ATOP_EXT = 0x3b9d0c29;
	VK_BLEND_OP_DST_ATOP_EXT = 0x3b9d0c2a;
	VK_BLEND_OP_XOR_EXT = 0x3b9d0c2b;
	VK_BLEND_OP_MULTIPLY_EXT = 0x3b9d0c2c;
	VK_BLEND_OP_SCREEN_EXT = 0x3b9d0c2d;
	VK_BLEND_OP_OVERLAY_EXT = 0x3b9d0c2e;
	VK_BLEND_OP_DARKEN_EXT = 0x3b9d0c2f;
	VK_BLEND_OP_LIGHTEN_EXT = 0x3b9d0c30;
	VK_BLEND_OP_COLORDODGE_EXT = 0x3b9d0c31;
	VK_BLEND_OP_COLORBURN_EXT = 0x3b9d0c32;
	VK_BLEND_OP_HARDLIGHT_EXT = 0x3b9d0c33;
	VK_BLEND_OP_SOFTLIGHT_EXT = 0x3b9d0c34;
	VK_BLEND_OP_DIFFERENCE_EXT = 0x3b9d0c35;
	VK_BLEND_OP_EXCLUSION_EXT = 0x3b9d0c36;
	VK_BLEND_OP_INVERT_EXT = 0x3b9d0c37;
	VK_BLEND_OP_INVERT_RGB_EXT = 0x3b9d0c38;
	VK_BLEND_OP_LINEARDODGE_EXT = 0x3b9d0c39;
	VK_BLEND_OP_LINEARBURN_EXT = 0x3b9d0c3a;
	VK_BLEND_OP_VIVIDLIGHT_EXT = 0x3b9d0c3b;
	VK_BLEND_OP_LINEARLIGHT_EXT = 0x3b9d0c3c;
	VK_BLEND_OP_PINLIGHT_EXT = 0x3b9d0c3d;
	VK_BLEND_OP_HARDMIX_EXT = 0x3b9d0c3e;
	VK_BLEND_OP_HSL_HUE_EXT = 0x3b9d0c3f;
	VK_BLEND_OP_HSL_SATURATION_EXT = 0x3b9d0c40;
	VK_BLEND_OP_HSL_COLOR_EXT = 0x3b9d0c41;
	VK_BLEND_OP_HSL_LUMINOSITY_EXT = 0x3b9d0c42;
	VK_BLEND_OP_PLUS_EXT = 0x3b9d0c43;
	VK_BLEND_OP_PLUS_CLAMPED_EXT = 0x3b9d0c44;
	VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT = 0x3b9d0c45;
	VK_BLEND_OP_PLUS_DARKER_EXT = 0x3b9d0c46;
	VK_BLEND_OP_MINUS_EXT = 0x3b9d0c47;
	VK_BLEND_OP_MINUS_CLAMPED_EXT = 0x3b9d0c48;
	VK_BLEND_OP_CONTRAST_EXT = 0x3b9d0c49;
	VK_BLEND_OP_INVERT_OVG_EXT = 0x3b9d0c4a;
	VK_BLEND_OP_RED_EXT = 0x3b9d0c4b;
	VK_BLEND_OP_GREEN_EXT = 0x3b9d0c4c;
	VK_BLEND_OP_BLUE_EXT = 0x3b9d0c4d;
	VK_BLEND_OP_MAX_ENUM = 0x7fffffff;
}
VkCompareOp :: enum s32 {
	VK_COMPARE_OP_NEVER = 0x0;
	VK_COMPARE_OP_LESS = 0x1;
	VK_COMPARE_OP_EQUAL = 0x2;
	VK_COMPARE_OP_LESS_OR_EQUAL = 0x3;
	VK_COMPARE_OP_GREATER = 0x4;
	VK_COMPARE_OP_NOT_EQUAL = 0x5;
	VK_COMPARE_OP_GREATER_OR_EQUAL = 0x6;
	VK_COMPARE_OP_ALWAYS = 0x7;
	VK_COMPARE_OP_MAX_ENUM = 0x7fffffff;
}
VkDynamicState :: enum s32 {
	VK_DYNAMIC_STATE_VIEWPORT = 0x0;
	VK_DYNAMIC_STATE_SCISSOR = 0x1;
	VK_DYNAMIC_STATE_LINE_WIDTH = 0x2;
	VK_DYNAMIC_STATE_DEPTH_BIAS = 0x3;
	VK_DYNAMIC_STATE_BLEND_CONSTANTS = 0x4;
	VK_DYNAMIC_STATE_DEPTH_BOUNDS = 0x5;
	VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 0x6;
	VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 0x7;
	VK_DYNAMIC_STATE_STENCIL_REFERENCE = 0x8;
	VK_DYNAMIC_STATE_CULL_MODE = 0x3b9edcf8;
	VK_DYNAMIC_STATE_FRONT_FACE = 0x3b9edcf9;
	VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY = 0x3b9edcfa;
	VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT = 0x3b9edcfb;
	VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT = 0x3b9edcfc;
	VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE = 0x3b9edcfd;
	VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE = 0x3b9edcfe;
	VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE = 0x3b9edcff;
	VK_DYNAMIC_STATE_DEPTH_COMPARE_OP = 0x3b9edd00;
	VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE = 0x3b9edd01;
	VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE = 0x3b9edd02;
	VK_DYNAMIC_STATE_STENCIL_OP = 0x3b9edd03;
	VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE = 0x3ba08aa9;
	VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE = 0x3ba08aaa;
	VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE = 0x3ba08aac;
	VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV = 0x3b9c1dd8;
	VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT = 0x3b9c4cb8;
	VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT = 0x3b9cf898;
	VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR = 0x3ba01578;
	VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV = 0x3b9d4aa4;
	VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV = 0x3b9d4aa6;
	VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV = 0x3b9deac9;
	VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR = 0x3b9e3cd0;
	VK_DYNAMIC_STATE_LINE_STIPPLE_EXT = 0x3b9ebdb8;
	VK_DYNAMIC_STATE_VERTEX_INPUT_EXT = 0x3ba02900;
	VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT = 0x3ba08aa8;
	VK_DYNAMIC_STATE_LOGIC_OP_EXT = 0x3ba08aab;
	VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT = 0x3ba09a48;
	VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT = 0x3ba1bb5a;
	VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT = 0x3ba1bb5b;
	VK_DYNAMIC_STATE_POLYGON_MODE_EXT = 0x3ba1bb5c;
	VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT = 0x3ba1bb5d;
	VK_DYNAMIC_STATE_SAMPLE_MASK_EXT = 0x3ba1bb5e;
	VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT = 0x3ba1bb5f;
	VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT = 0x3ba1bb60;
	VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT = 0x3ba1bb61;
	VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT = 0x3ba1bb62;
	VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT = 0x3ba1bb63;
	VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT = 0x3ba1bb64;
	VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT = 0x3ba1bb65;
	VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT = 0x3ba1bb66;
	VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT = 0x3ba1bb67;
	VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT = 0x3ba1bb68;
	VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT = 0x3ba1bb69;
	VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT = 0x3ba1bb6a;
	VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT = 0x3ba1bb6b;
	VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT = 0x3ba1bb6c;
	VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT = 0x3ba1bb6d;
	VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT = 0x3ba1bb6e;
	VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV = 0x3ba1bb6f;
	VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV = 0x3ba1bb70;
	VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV = 0x3ba1bb71;
	VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV = 0x3ba1bb72;
	VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV = 0x3ba1bb73;
	VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV = 0x3ba1bb74;
	VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV = 0x3ba1bb75;
	VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV = 0x3ba1bb76;
	VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV = 0x3ba1bb77;
	VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV = 0x3ba1bb78;
	VK_DYNAMIC_STATE_CULL_MODE_EXT = 0x3b9edcf8;
	VK_DYNAMIC_STATE_FRONT_FACE_EXT = 0x3b9edcf9;
	VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT = 0x3b9edcfa;
	VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT = 0x3b9edcfb;
	VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT = 0x3b9edcfc;
	VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT = 0x3b9edcfd;
	VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT = 0x3b9edcfe;
	VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT = 0x3b9edcff;
	VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT = 0x3b9edd00;
	VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT = 0x3b9edd01;
	VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT = 0x3b9edd02;
	VK_DYNAMIC_STATE_STENCIL_OP_EXT = 0x3b9edd03;
	VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT = 0x3ba08aa9;
	VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT = 0x3ba08aaa;
	VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT = 0x3ba08aac;
	VK_DYNAMIC_STATE_MAX_ENUM = 0x7fffffff;
}
VkFrontFace :: enum s32 {
	VK_FRONT_FACE_COUNTER_CLOCKWISE = 0x0;
	VK_FRONT_FACE_CLOCKWISE = 0x1;
	VK_FRONT_FACE_MAX_ENUM = 0x7fffffff;
}
VkVertexInputRate :: enum s32 {
	VK_VERTEX_INPUT_RATE_VERTEX = 0x0;
	VK_VERTEX_INPUT_RATE_INSTANCE = 0x1;
	VK_VERTEX_INPUT_RATE_MAX_ENUM = 0x7fffffff;
}
VkPrimitiveTopology :: enum s32 {
	VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0x0;
	VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 0x1;
	VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 0x2;
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 0x3;
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 0x4;
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 0x5;
	VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 0x6;
	VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 0x7;
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 0x8;
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 0x9;
	VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 0xa;
	VK_PRIMITIVE_TOPOLOGY_MAX_ENUM = 0x7fffffff;
}
VkPolygonMode :: enum s32 {
	VK_POLYGON_MODE_FILL = 0x0;
	VK_POLYGON_MODE_LINE = 0x1;
	VK_POLYGON_MODE_POINT = 0x2;
	VK_POLYGON_MODE_FILL_RECTANGLE_NV = 0x3b9d1fa8;
	VK_POLYGON_MODE_MAX_ENUM = 0x7fffffff;
}
VkStencilOp :: enum s32 {
	VK_STENCIL_OP_KEEP = 0x0;
	VK_STENCIL_OP_ZERO = 0x1;
	VK_STENCIL_OP_REPLACE = 0x2;
	VK_STENCIL_OP_INCREMENT_AND_CLAMP = 0x3;
	VK_STENCIL_OP_DECREMENT_AND_CLAMP = 0x4;
	VK_STENCIL_OP_INVERT = 0x5;
	VK_STENCIL_OP_INCREMENT_AND_WRAP = 0x6;
	VK_STENCIL_OP_DECREMENT_AND_WRAP = 0x7;
	VK_STENCIL_OP_MAX_ENUM = 0x7fffffff;
}
VkLogicOp :: enum s32 {
	VK_LOGIC_OP_CLEAR = 0x0;
	VK_LOGIC_OP_AND = 0x1;
	VK_LOGIC_OP_AND_REVERSE = 0x2;
	VK_LOGIC_OP_COPY = 0x3;
	VK_LOGIC_OP_AND_INVERTED = 0x4;
	VK_LOGIC_OP_NO_OP = 0x5;
	VK_LOGIC_OP_XOR = 0x6;
	VK_LOGIC_OP_OR = 0x7;
	VK_LOGIC_OP_NOR = 0x8;
	VK_LOGIC_OP_EQUIVALENT = 0x9;
	VK_LOGIC_OP_INVERT = 0xa;
	VK_LOGIC_OP_OR_REVERSE = 0xb;
	VK_LOGIC_OP_COPY_INVERTED = 0xc;
	VK_LOGIC_OP_OR_INVERTED = 0xd;
	VK_LOGIC_OP_NAND = 0xe;
	VK_LOGIC_OP_SET = 0xf;
	VK_LOGIC_OP_MAX_ENUM = 0x7fffffff;
}
VkBorderColor :: enum s32 {
	VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0x0;
	VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 0x1;
	VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 0x2;
	VK_BORDER_COLOR_INT_OPAQUE_BLACK = 0x3;
	VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 0x4;
	VK_BORDER_COLOR_INT_OPAQUE_WHITE = 0x5;
	VK_BORDER_COLOR_FLOAT_CUSTOM_EXT = 0x3b9f2b1b;
	VK_BORDER_COLOR_INT_CUSTOM_EXT = 0x3b9f2b1c;
	VK_BORDER_COLOR_MAX_ENUM = 0x7fffffff;
}
VkFilter :: enum s32 {
	VK_FILTER_NEAREST = 0x0;
	VK_FILTER_LINEAR = 0x1;
	VK_FILTER_CUBIC_EXT = 0x3b9b0498;
	VK_FILTER_CUBIC_IMG = 0x3b9b0498;
	VK_FILTER_MAX_ENUM = 0x7fffffff;
}
VkSamplerAddressMode :: enum s32 {
	VK_SAMPLER_ADDRESS_MODE_REPEAT = 0x0;
	VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 0x1;
	VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 0x2;
	VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 0x3;
	VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 0x4;
	VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR = 0x4;
	VK_SAMPLER_ADDRESS_MODE_MAX_ENUM = 0x7fffffff;
}
VkSamplerMipmapMode :: enum s32 {
	VK_SAMPLER_MIPMAP_MODE_NEAREST = 0x0;
	VK_SAMPLER_MIPMAP_MODE_LINEAR = 0x1;
	VK_SAMPLER_MIPMAP_MODE_MAX_ENUM = 0x7fffffff;
}
VkDescriptorType :: enum s32 {
	VK_DESCRIPTOR_TYPE_SAMPLER = 0x0;
	VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 0x1;
	VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 0x2;
	VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 0x3;
	VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 0x4;
	VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 0x5;
	VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 0x6;
	VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 0x7;
	VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 0x8;
	VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 0x9;
	VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 0xa;
	VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK = 0x3b9ce510;
	VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR = 0x3b9d13f0;
	VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV = 0x3b9d4e88;
	VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM = 0x3ba180c0;
	VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM = 0x3ba180c1;
	VK_DESCRIPTOR_TYPE_MUTABLE_EXT = 0x3ba02518;
	VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT = 0x3b9ce510;
	VK_DESCRIPTOR_TYPE_MUTABLE_VALVE = 0x3ba02518;
	VK_DESCRIPTOR_TYPE_MAX_ENUM = 0x7fffffff;
}
VkAttachmentLoadOp :: enum s32 {
	VK_ATTACHMENT_LOAD_OP_LOAD = 0x0;
	VK_ATTACHMENT_LOAD_OP_CLEAR = 0x1;
	VK_ATTACHMENT_LOAD_OP_DONT_CARE = 0x2;
	VK_ATTACHMENT_LOAD_OP_NONE_EXT = 0x3ba0e480;
	VK_ATTACHMENT_LOAD_OP_MAX_ENUM = 0x7fffffff;
}
VkAttachmentStoreOp :: enum s32 {
	VK_ATTACHMENT_STORE_OP_STORE = 0x0;
	VK_ATTACHMENT_STORE_OP_DONT_CARE = 0x1;
	VK_ATTACHMENT_STORE_OP_NONE = 0x3b9f61c8;
	VK_ATTACHMENT_STORE_OP_NONE_KHR = 0x3b9f61c8;
	VK_ATTACHMENT_STORE_OP_NONE_QCOM = 0x3b9f61c8;
	VK_ATTACHMENT_STORE_OP_NONE_EXT = 0x3b9f61c8;
	VK_ATTACHMENT_STORE_OP_MAX_ENUM = 0x7fffffff;
}
VkPipelineBindPoint :: enum s32 {
	VK_PIPELINE_BIND_POINT_GRAPHICS = 0x0;
	VK_PIPELINE_BIND_POINT_COMPUTE = 0x1;
	VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR = 0x3b9d4e88;
	VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI = 0x3ba06b6b;
	VK_PIPELINE_BIND_POINT_RAY_TRACING_NV = 0x3b9d4e88;
	VK_PIPELINE_BIND_POINT_MAX_ENUM = 0x7fffffff;
}
VkCommandBufferLevel :: enum s32 {
	VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0x0;
	VK_COMMAND_BUFFER_LEVEL_SECONDARY = 0x1;
	VK_COMMAND_BUFFER_LEVEL_MAX_ENUM = 0x7fffffff;
}
VkIndexType :: enum s32 {
	VK_INDEX_TYPE_UINT16 = 0x0;
	VK_INDEX_TYPE_UINT32 = 0x1;
	VK_INDEX_TYPE_NONE_KHR = 0x3b9d4e88;
	VK_INDEX_TYPE_UINT8_EXT = 0x3b9ed528;
	VK_INDEX_TYPE_NONE_NV = 0x3b9d4e88;
	VK_INDEX_TYPE_MAX_ENUM = 0x7fffffff;
}
VkSubpassContents :: enum s32 {
	VK_SUBPASS_CONTENTS_INLINE = 0x0;
	VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 0x1;
	VK_SUBPASS_CONTENTS_MAX_ENUM = 0x7fffffff;
}
VkAccessFlagBits :: enum u32 #flags {
	VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 0x1;
	VK_ACCESS_INDEX_READ_BIT = 0x2;
	VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 0x4;
	VK_ACCESS_UNIFORM_READ_BIT = 0x8;
	VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 0x10;
	VK_ACCESS_SHADER_READ_BIT = 0x20;
	VK_ACCESS_SHADER_WRITE_BIT = 0x40;
	VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 0x80;
	VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 0x100;
	VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x200;
	VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x400;
	VK_ACCESS_TRANSFER_READ_BIT = 0x800;
	VK_ACCESS_TRANSFER_WRITE_BIT = 0x1000;
	VK_ACCESS_HOST_READ_BIT = 0x2000;
	VK_ACCESS_HOST_WRITE_BIT = 0x4000;
	VK_ACCESS_MEMORY_READ_BIT = 0x8000;
	VK_ACCESS_MEMORY_WRITE_BIT = 0x10000;
	VK_ACCESS_NONE = 0x0;
	VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 0x2000000;
	VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 0x4000000;
	VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 0x8000000;
	VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = 0x100000;
	VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 0x80000;
	VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR = 0x200000;
	VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 0x400000;
	VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 0x1000000;
	VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = 0x800000;
	VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV = 0x20000;
	VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV = 0x40000;
	VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV = 0x800000;
	VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV = 0x200000;
	VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV = 0x400000;
	VK_ACCESS_NONE_KHR = 0x0;
	VK_ACCESS_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkAccessFlags :: VkFlags;
VkImageAspectFlagBits :: enum u32 #flags {
	VK_IMAGE_ASPECT_COLOR_BIT = 0x1;
	VK_IMAGE_ASPECT_DEPTH_BIT = 0x2;
	VK_IMAGE_ASPECT_STENCIL_BIT = 0x4;
	VK_IMAGE_ASPECT_METADATA_BIT = 0x8;
	VK_IMAGE_ASPECT_PLANE_0_BIT = 0x10;
	VK_IMAGE_ASPECT_PLANE_1_BIT = 0x20;
	VK_IMAGE_ASPECT_PLANE_2_BIT = 0x40;
	VK_IMAGE_ASPECT_NONE = 0x0;
	VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT = 0x80;
	VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT = 0x100;
	VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT = 0x200;
	VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT = 0x400;
	VK_IMAGE_ASPECT_PLANE_0_BIT_KHR = 0x10;
	VK_IMAGE_ASPECT_PLANE_1_BIT_KHR = 0x20;
	VK_IMAGE_ASPECT_PLANE_2_BIT_KHR = 0x40;
	VK_IMAGE_ASPECT_NONE_KHR = 0x0;
	VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkImageAspectFlags :: VkFlags;
VkFormatFeatureFlagBits :: enum u32 #flags {
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 0x1;
	VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 0x2;
	VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 0x4;
	VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 0x8;
	VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 0x10;
	VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x20;
	VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 0x40;
	VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 0x80;
	VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 0x100;
	VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x200;
	VK_FORMAT_FEATURE_BLIT_SRC_BIT = 0x400;
	VK_FORMAT_FEATURE_BLIT_DST_BIT = 0x800;
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x1000;
	VK_FORMAT_FEATURE_TRANSFER_SRC_BIT = 0x4000;
	VK_FORMAT_FEATURE_TRANSFER_DST_BIT = 0x8000;
	VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT = 0x20000;
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 0x40000;
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 0x80000;
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 0x100000;
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 0x200000;
	VK_FORMAT_FEATURE_DISJOINT_BIT = 0x400000;
	VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT = 0x800000;
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT = 0x10000;
	VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = 0x20000000;
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = 0x2000;
	VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x1000000;
	VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x40000000;
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 0x2000;
	VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR = 0x4000;
	VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR = 0x8000;
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT = 0x10000;
	VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR = 0x20000;
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = 0x40000;
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = 0x80000;
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = 0x100000;
	VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = 0x200000;
	VK_FORMAT_FEATURE_DISJOINT_BIT_KHR = 0x400000;
	VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR = 0x800000;
	VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkFormatFeatureFlags :: VkFlags;
VkImageCreateFlagBits :: enum u32 #flags {
	VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 0x1;
	VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0x2;
	VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 0x4;
	VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 0x8;
	VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 0x10;
	VK_IMAGE_CREATE_ALIAS_BIT = 0x400;
	VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT = 0x40;
	VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT = 0x20;
	VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT = 0x80;
	VK_IMAGE_CREATE_EXTENDED_USAGE_BIT = 0x100;
	VK_IMAGE_CREATE_PROTECTED_BIT = 0x800;
	VK_IMAGE_CREATE_DISJOINT_BIT = 0x200;
	VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV = 0x2000;
	VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT = 0x1000;
	VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT = 0x4000;
	VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT = 0x40000;
	VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT = 0x20000;
	VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM = 0x8000;
	VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = 0x40;
	VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR = 0x20;
	VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR = 0x80;
	VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR = 0x100;
	VK_IMAGE_CREATE_DISJOINT_BIT_KHR = 0x200;
	VK_IMAGE_CREATE_ALIAS_BIT_KHR = 0x400;
	VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkImageCreateFlags :: VkFlags;
VkSampleCountFlagBits :: enum u32 #flags {
	VK_SAMPLE_COUNT_1_BIT = 0x1;
	VK_SAMPLE_COUNT_2_BIT = 0x2;
	VK_SAMPLE_COUNT_4_BIT = 0x4;
	VK_SAMPLE_COUNT_8_BIT = 0x8;
	VK_SAMPLE_COUNT_16_BIT = 0x10;
	VK_SAMPLE_COUNT_32_BIT = 0x20;
	VK_SAMPLE_COUNT_64_BIT = 0x40;
	VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkSampleCountFlags :: VkFlags;
VkImageUsageFlagBits :: enum u32 #flags {
	VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 0x1;
	VK_IMAGE_USAGE_TRANSFER_DST_BIT = 0x2;
	VK_IMAGE_USAGE_SAMPLED_BIT = 0x4;
	VK_IMAGE_USAGE_STORAGE_BIT = 0x8;
	VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 0x10;
	VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x20;
	VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 0x40;
	VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 0x80;
	VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x200;
	VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x100;
	VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x80000;
	VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI = 0x40000;
	VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM = 0x100000;
	VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM = 0x200000;
	VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV = 0x100;
	VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkImageUsageFlags :: VkFlags;
VkInstanceCreateFlagBits :: enum u32 #flags {
	VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR = 0x1;
	VK_INSTANCE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkInstanceCreateFlags :: VkFlags;
VkMemoryHeapFlagBits :: enum u32 #flags {
	VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x1;
	VK_MEMORY_HEAP_MULTI_INSTANCE_BIT = 0x2;
	VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR = 0x2;
	VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkMemoryHeapFlags :: VkFlags;
VkMemoryPropertyFlagBits :: enum u32 #flags {
	VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x1;
	VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x2;
	VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x4;
	VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0x8;
	VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x10;
	VK_MEMORY_PROPERTY_PROTECTED_BIT = 0x20;
	VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = 0x40;
	VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = 0x80;
	VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV = 0x100;
	VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkMemoryPropertyFlags :: VkFlags;
VkQueueFlagBits :: enum u32 #flags {
	VK_QUEUE_GRAPHICS_BIT = 0x1;
	VK_QUEUE_COMPUTE_BIT = 0x2;
	VK_QUEUE_TRANSFER_BIT = 0x4;
	VK_QUEUE_SPARSE_BINDING_BIT = 0x8;
	VK_QUEUE_PROTECTED_BIT = 0x10;
	VK_QUEUE_OPTICAL_FLOW_BIT_NV = 0x100;
	VK_QUEUE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkQueueFlags :: VkFlags;
VkDeviceCreateFlags :: VkFlags;
VkDeviceQueueCreateFlagBits :: enum u32 #flags {
	VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT = 0x1;
	VK_DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkDeviceQueueCreateFlags :: VkFlags;
VkPipelineStageFlagBits :: enum u32 #flags {
	VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0x1;
	VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0x2;
	VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 0x4;
	VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 0x8;
	VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0x10;
	VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x20;
	VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0x40;
	VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0x80;
	VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0x100;
	VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0x200;
	VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0x400;
	VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0x800;
	VK_PIPELINE_STAGE_TRANSFER_BIT = 0x1000;
	VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0x2000;
	VK_PIPELINE_STAGE_HOST_BIT = 0x4000;
	VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0x8000;
	VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 0x10000;
	VK_PIPELINE_STAGE_NONE = 0x0;
	VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT = 0x1000000;
	VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x40000;
	VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 0x2000000;
	VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR = 0x200000;
	VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 0x800000;
	VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x400000;
	VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV = 0x20000;
	VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT = 0x80000;
	VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT = 0x100000;
	VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV = 0x400000;
	VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV = 0x200000;
	VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV = 0x2000000;
	VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV = 0x80000;
	VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV = 0x100000;
	VK_PIPELINE_STAGE_NONE_KHR = 0x0;
	VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkPipelineStageFlags :: VkFlags;
VkMemoryMapFlags :: VkFlags;
VkSparseMemoryBindFlagBits :: enum u32 #flags {
	VK_SPARSE_MEMORY_BIND_METADATA_BIT = 0x1;
	VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkSparseMemoryBindFlags :: VkFlags;
VkSparseImageFormatFlagBits :: enum u32 #flags {
	VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 0x1;
	VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 0x2;
	VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x4;
	VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkSparseImageFormatFlags :: VkFlags;
VkFenceCreateFlagBits :: enum u32 #flags {
	VK_FENCE_CREATE_SIGNALED_BIT = 0x1;
	VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkFenceCreateFlags :: VkFlags;
VkSemaphoreCreateFlags :: VkFlags;
VkEventCreateFlagBits :: enum u32 #flags {
	VK_EVENT_CREATE_DEVICE_ONLY_BIT = 0x1;
	VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR = 0x1;
	VK_EVENT_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkEventCreateFlags :: VkFlags;
VkQueryPipelineStatisticFlagBits :: enum u32 #flags {
	VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 0x1;
	VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 0x2;
	VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 0x4;
	VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 0x8;
	VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 0x10;
	VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 0x20;
	VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 0x40;
	VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 0x80;
	VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 0x100;
	VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 0x200;
	VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 0x400;
	VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT = 0x800;
	VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT = 0x1000;
	VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkQueryPipelineStatisticFlags :: VkFlags;
VkQueryPoolCreateFlags :: VkFlags;
VkQueryResultFlagBits :: enum u32 #flags {
	VK_QUERY_RESULT_64_BIT = 0x1;
	VK_QUERY_RESULT_WAIT_BIT = 0x2;
	VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 0x4;
	VK_QUERY_RESULT_PARTIAL_BIT = 0x8;
	VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkQueryResultFlags :: VkFlags;
VkBufferCreateFlagBits :: enum u32 #flags {
	VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 0x1;
	VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0x2;
	VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 0x4;
	VK_BUFFER_CREATE_PROTECTED_BIT = 0x8;
	VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 0x10;
	VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = 0x10;
	VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = 0x10;
	VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkBufferCreateFlags :: VkFlags;
VkBufferUsageFlagBits :: enum u32 #flags {
	VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 0x1;
	VK_BUFFER_USAGE_TRANSFER_DST_BIT = 0x2;
	VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x4;
	VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x8;
	VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 0x10;
	VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 0x20;
	VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 0x40;
	VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 0x80;
	VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 0x100;
	VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT = 0x20000;
	VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 0x800;
	VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 0x1000;
	VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x200;
	VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR = 0x80000;
	VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR = 0x100000;
	VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR = 0x400;
	VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT = 0x800000;
	VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT = 0x1000000;
	VK_BUFFER_USAGE_RAY_TRACING_BIT_NV = 0x400;
	VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT = 0x20000;
	VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR = 0x20000;
	VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkBufferUsageFlags :: VkFlags;
VkBufferViewCreateFlags :: VkFlags;
VkImageViewCreateFlagBits :: enum u32 #flags {
	VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT = 0x1;
	VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT = 0x2;
	VK_IMAGE_VIEW_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkImageViewCreateFlags :: VkFlags;
VkShaderModuleCreateFlags :: VkFlags;
VkPipelineCacheCreateFlagBits :: enum u32 #flags {
	VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT = 0x1;
	VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT = 0x1;
	VK_PIPELINE_CACHE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkPipelineCacheCreateFlags :: VkFlags;
VkColorComponentFlagBits :: enum u32 #flags {
	VK_COLOR_COMPONENT_R_BIT = 0x1;
	VK_COLOR_COMPONENT_G_BIT = 0x2;
	VK_COLOR_COMPONENT_B_BIT = 0x4;
	VK_COLOR_COMPONENT_A_BIT = 0x8;
	VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkColorComponentFlags :: VkFlags;
VkPipelineCreateFlagBits :: enum u32 #flags {
	VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0x1;
	VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 0x2;
	VK_PIPELINE_CREATE_DERIVATIVE_BIT = 0x4;
	VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = 0x8;
	VK_PIPELINE_CREATE_DISPATCH_BASE_BIT = 0x10;
	VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT = 0x100;
	VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT = 0x200;
	VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x200000;
	VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x400000;
	VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR = 0x4000;
	VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR = 0x8000;
	VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR = 0x10000;
	VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR = 0x20000;
	VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR = 0x1000;
	VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR = 0x2000;
	VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR = 0x80000;
	VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV = 0x20;
	VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR = 0x40;
	VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = 0x80;
	VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV = 0x40000;
	VK_PIPELINE_CREATE_LIBRARY_BIT_KHR = 0x800;
	VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT = 0x20000000;
	VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT = 0x800000;
	VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT = 0x400;
	VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV = 0x100000;
	VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x2000000;
	VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x4000000;
	VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT = 0x1000000;
	VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT = 0x8000000;
	VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT = 0x40000000;
	VK_PIPELINE_CREATE_DISPATCH_BASE = 0x10;
	VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x200000;
	VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x400000;
	VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = 0x8;
	VK_PIPELINE_CREATE_DISPATCH_BASE_KHR = 0x10;
	VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT = 0x100;
	VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT = 0x200;
	VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkPipelineCreateFlags :: VkFlags;
VkPipelineShaderStageCreateFlagBits :: enum u32 #flags {
	VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT = 0x1;
	VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT = 0x2;
	VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT = 0x1;
	VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT = 0x2;
	VK_PIPELINE_SHADER_STAGE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkPipelineShaderStageCreateFlags :: VkFlags;
VkShaderStageFlagBits :: enum u32 #flags {
	VK_SHADER_STAGE_VERTEX_BIT = 0x1;
	VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 0x2;
	VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x4;
	VK_SHADER_STAGE_GEOMETRY_BIT = 0x8;
	VK_SHADER_STAGE_FRAGMENT_BIT = 0x10;
	VK_SHADER_STAGE_COMPUTE_BIT = 0x20;
	VK_SHADER_STAGE_ALL_GRAPHICS = 0x1f;
	VK_SHADER_STAGE_ALL = 0x7fffffff;
	VK_SHADER_STAGE_RAYGEN_BIT_KHR = 0x100;
	VK_SHADER_STAGE_ANY_HIT_BIT_KHR = 0x200;
	VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR = 0x400;
	VK_SHADER_STAGE_MISS_BIT_KHR = 0x800;
	VK_SHADER_STAGE_INTERSECTION_BIT_KHR = 0x1000;
	VK_SHADER_STAGE_CALLABLE_BIT_KHR = 0x2000;
	VK_SHADER_STAGE_TASK_BIT_EXT = 0x40;
	VK_SHADER_STAGE_MESH_BIT_EXT = 0x80;
	VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI = 0x4000;
	VK_SHADER_STAGE_RAYGEN_BIT_NV = 0x100;
	VK_SHADER_STAGE_ANY_HIT_BIT_NV = 0x200;
	VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV = 0x400;
	VK_SHADER_STAGE_MISS_BIT_NV = 0x800;
	VK_SHADER_STAGE_INTERSECTION_BIT_NV = 0x1000;
	VK_SHADER_STAGE_CALLABLE_BIT_NV = 0x2000;
	VK_SHADER_STAGE_TASK_BIT_NV = 0x40;
	VK_SHADER_STAGE_MESH_BIT_NV = 0x80;
	VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkCullModeFlagBits :: enum u32 #flags {
	VK_CULL_MODE_NONE = 0x0;
	VK_CULL_MODE_FRONT_BIT = 0x1;
	VK_CULL_MODE_BACK_BIT = 0x2;
	VK_CULL_MODE_FRONT_AND_BACK = 0x3;
	VK_CULL_MODE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkCullModeFlags :: VkFlags;
VkPipelineVertexInputStateCreateFlags :: VkFlags;
VkPipelineInputAssemblyStateCreateFlags :: VkFlags;
VkPipelineTessellationStateCreateFlags :: VkFlags;
VkPipelineViewportStateCreateFlags :: VkFlags;
VkPipelineRasterizationStateCreateFlags :: VkFlags;
VkPipelineMultisampleStateCreateFlags :: VkFlags;
VkPipelineDepthStencilStateCreateFlagBits :: enum u32 #flags {
	VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT = 0x1;
	VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT = 0x2;
	VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM = 0x1;
	VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM = 0x2;
	VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkPipelineDepthStencilStateCreateFlags :: VkFlags;
VkPipelineColorBlendStateCreateFlagBits :: enum u32 #flags {
	VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT = 0x1;
	VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM = 0x1;
	VK_PIPELINE_COLOR_BLEND_STATE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkPipelineColorBlendStateCreateFlags :: VkFlags;
VkPipelineDynamicStateCreateFlags :: VkFlags;
VkPipelineLayoutCreateFlagBits :: enum u32 #flags {
	VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT = 0x2;
	VK_PIPELINE_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkPipelineLayoutCreateFlags :: VkFlags;
VkShaderStageFlags :: VkFlags;
VkSamplerCreateFlagBits :: enum u32 #flags {
	VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT = 0x1;
	VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT = 0x2;
	VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT = 0x4;
	VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM = 0x10;
	VK_SAMPLER_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkSamplerCreateFlags :: VkFlags;
VkDescriptorPoolCreateFlagBits :: enum u32 #flags {
	VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0x1;
	VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT = 0x2;
	VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT = 0x4;
	VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT = 0x2;
	VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE = 0x4;
	VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkDescriptorPoolCreateFlags :: VkFlags;
VkDescriptorPoolResetFlags :: VkFlags;
VkDescriptorSetLayoutCreateFlagBits :: enum u32 #flags {
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT = 0x2;
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = 0x1;
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT = 0x4;
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT = 0x2;
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE = 0x4;
	VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkDescriptorSetLayoutCreateFlags :: VkFlags;
VkAttachmentDescriptionFlagBits :: enum u32 #flags {
	VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0x1;
	VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkAttachmentDescriptionFlags :: VkFlags;
VkDependencyFlagBits :: enum u32 #flags {
	VK_DEPENDENCY_BY_REGION_BIT = 0x1;
	VK_DEPENDENCY_DEVICE_GROUP_BIT = 0x4;
	VK_DEPENDENCY_VIEW_LOCAL_BIT = 0x2;
	VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT = 0x8;
	VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR = 0x2;
	VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR = 0x4;
	VK_DEPENDENCY_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkDependencyFlags :: VkFlags;
VkFramebufferCreateFlagBits :: enum u32 #flags {
	VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT = 0x1;
	VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR = 0x1;
	VK_FRAMEBUFFER_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkFramebufferCreateFlags :: VkFlags;
VkRenderPassCreateFlagBits :: enum u32 #flags {
	VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM = 0x2;
	VK_RENDER_PASS_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkRenderPassCreateFlags :: VkFlags;
VkSubpassDescriptionFlagBits :: enum u32 #flags {
	VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX = 0x1;
	VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX = 0x2;
	VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM = 0x4;
	VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM = 0x8;
	VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT = 0x10;
	VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT = 0x20;
	VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT = 0x40;
	VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT = 0x80;
	VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM = 0x10;
	VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM = 0x20;
	VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM = 0x40;
	VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkSubpassDescriptionFlags :: VkFlags;
VkCommandPoolCreateFlagBits :: enum u32 #flags {
	VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 0x1;
	VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0x2;
	VK_COMMAND_POOL_CREATE_PROTECTED_BIT = 0x4;
	VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkCommandPoolCreateFlags :: VkFlags;
VkCommandPoolResetFlagBits :: enum u32 #flags {
	VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0x1;
	VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkCommandPoolResetFlags :: VkFlags;
VkCommandBufferUsageFlagBits :: enum u32 #flags {
	VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 0x1;
	VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 0x2;
	VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 0x4;
	VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkCommandBufferUsageFlags :: VkFlags;
VkQueryControlFlagBits :: enum u32 #flags {
	VK_QUERY_CONTROL_PRECISE_BIT = 0x1;
	VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkQueryControlFlags :: VkFlags;
VkCommandBufferResetFlagBits :: enum u32 #flags {
	VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0x1;
	VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkCommandBufferResetFlags :: VkFlags;
VkStencilFaceFlagBits :: enum u32 #flags {
	VK_STENCIL_FACE_FRONT_BIT = 0x1;
	VK_STENCIL_FACE_BACK_BIT = 0x2;
	VK_STENCIL_FACE_FRONT_AND_BACK = 0x3;
	VK_STENCIL_FRONT_AND_BACK = 0x3;
	VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkStencilFaceFlags :: VkFlags;
VkExtent2D :: struct {
	width: u32;
	height: u32;
}
VkExtent3D :: struct {
	width: u32;
	height: u32;
	depth: u32;
}
VkOffset2D :: struct {
	x: s32;
	y: s32;
}
VkOffset3D :: struct {
	x: s32;
	y: s32;
	z: s32;
}
VkRect2D :: struct {
	offset: VkOffset2D;
	extent: VkExtent2D;
}
VkBaseInStructure :: struct {
	sType: VkStructureType;
	pNext: *VkBaseInStructure;
}
VkBaseOutStructure :: struct {
	sType: VkStructureType;
	pNext: *VkBaseOutStructure;
}
VkBufferMemoryBarrier :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	srcAccessMask: VkAccessFlags;
	dstAccessMask: VkAccessFlags;
	srcQueueFamilyIndex: u32;
	dstQueueFamilyIndex: u32;
	buffer: VkBuffer;
	offset: VkDeviceSize;
	size: VkDeviceSize;
}
VkDispatchIndirectCommand :: struct {
	x: u32;
	y: u32;
	z: u32;
}
VkDrawIndexedIndirectCommand :: struct {
	indexCount: u32;
	instanceCount: u32;
	firstIndex: u32;
	vertexOffset: s32;
	firstInstance: u32;
}
VkDrawIndirectCommand :: struct {
	vertexCount: u32;
	instanceCount: u32;
	firstVertex: u32;
	firstInstance: u32;
}
VkImageSubresourceRange :: struct {
	aspectMask: VkImageAspectFlags;
	baseMipLevel: u32;
	levelCount: u32;
	baseArrayLayer: u32;
	layerCount: u32;
}
VkImageMemoryBarrier :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	srcAccessMask: VkAccessFlags;
	dstAccessMask: VkAccessFlags;
	oldLayout: VkImageLayout;
	newLayout: VkImageLayout;
	srcQueueFamilyIndex: u32;
	dstQueueFamilyIndex: u32;
	image: VkImage;
	subresourceRange: VkImageSubresourceRange;
}
VkMemoryBarrier :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	srcAccessMask: VkAccessFlags;
	dstAccessMask: VkAccessFlags;
}
VkPipelineCacheHeaderVersionOne :: struct {
	headerSize: u32;
	headerVersion: VkPipelineCacheHeaderVersion;
	vendorID: u32;
	deviceID: u32;
	pipelineCacheUUID: [16]u8;
}
PFN_vkAllocationFunction :: *fn (C.void_ptr, usize, usize, VkSystemAllocationScope) C.void_ptr;
PFN_vkFreeFunction :: *fn (C.void_ptr, C.void_ptr);
PFN_vkInternalAllocationNotification :: *fn (C.void_ptr, usize, VkInternalAllocationType, VkSystemAllocationScope);
PFN_vkInternalFreeNotification :: *fn (C.void_ptr, usize, VkInternalAllocationType, VkSystemAllocationScope);
PFN_vkReallocationFunction :: *fn (C.void_ptr, C.void_ptr, usize, usize, VkSystemAllocationScope) C.void_ptr;
PFN_vkVoidFunction :: *fn ();
VkAllocationCallbacks :: struct {
	pUserData: C.void_ptr;
	pfnAllocation: PFN_vkAllocationFunction;
	pfnReallocation: PFN_vkReallocationFunction;
	pfnFree: PFN_vkFreeFunction;
	pfnInternalAllocation: PFN_vkInternalAllocationNotification;
	pfnInternalFree: PFN_vkInternalFreeNotification;
}
VkApplicationInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	pApplicationName: *C.char;
	applicationVersion: u32;
	pEngineName: *C.char;
	engineVersion: u32;
	apiVersion: u32;
}
VkFormatProperties :: struct {
	linearTilingFeatures: VkFormatFeatureFlags;
	optimalTilingFeatures: VkFormatFeatureFlags;
	bufferFeatures: VkFormatFeatureFlags;
}
VkImageFormatProperties :: struct {
	maxExtent: VkExtent3D;
	maxMipLevels: u32;
	maxArrayLayers: u32;
	sampleCounts: VkSampleCountFlags;
	maxResourceSize: VkDeviceSize;
}
VkInstanceCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkInstanceCreateFlags;
	pApplicationInfo: *VkApplicationInfo;
	enabledLayerCount: u32;
	ppEnabledLayerNames: **C.char;
	enabledExtensionCount: u32;
	ppEnabledExtensionNames: **C.char;
}
VkMemoryHeap :: struct {
	size: VkDeviceSize;
	flags: VkMemoryHeapFlags;
}
VkMemoryType :: struct {
	propertyFlags: VkMemoryPropertyFlags;
	heapIndex: u32;
}
VkPhysicalDeviceFeatures :: struct {
	robustBufferAccess: VkBool32;
	fullDrawIndexUint32: VkBool32;
	imageCubeArray: VkBool32;
	independentBlend: VkBool32;
	geometryShader: VkBool32;
	tessellationShader: VkBool32;
	sampleRateShading: VkBool32;
	dualSrcBlend: VkBool32;
	logicOp: VkBool32;
	multiDrawIndirect: VkBool32;
	drawIndirectFirstInstance: VkBool32;
	depthClamp: VkBool32;
	depthBiasClamp: VkBool32;
	fillModeNonSolid: VkBool32;
	depthBounds: VkBool32;
	wideLines: VkBool32;
	largePoints: VkBool32;
	alphaToOne: VkBool32;
	multiViewport: VkBool32;
	samplerAnisotropy: VkBool32;
	textureCompressionETC2: VkBool32;
	textureCompressionASTC_LDR: VkBool32;
	textureCompressionBC: VkBool32;
	occlusionQueryPrecise: VkBool32;
	pipelineStatisticsQuery: VkBool32;
	vertexPipelineStoresAndAtomics: VkBool32;
	fragmentStoresAndAtomics: VkBool32;
	shaderTessellationAndGeometryPointSize: VkBool32;
	shaderImageGatherExtended: VkBool32;
	shaderStorageImageExtendedFormats: VkBool32;
	shaderStorageImageMultisample: VkBool32;
	shaderStorageImageReadWithoutFormat: VkBool32;
	shaderStorageImageWriteWithoutFormat: VkBool32;
	shaderUniformBufferArrayDynamicIndexing: VkBool32;
	shaderSampledImageArrayDynamicIndexing: VkBool32;
	shaderStorageBufferArrayDynamicIndexing: VkBool32;
	shaderStorageImageArrayDynamicIndexing: VkBool32;
	shaderClipDistance: VkBool32;
	shaderCullDistance: VkBool32;
	shaderFloat64: VkBool32;
	shaderInt64: VkBool32;
	shaderInt16: VkBool32;
	shaderResourceResidency: VkBool32;
	shaderResourceMinLod: VkBool32;
	sparseBinding: VkBool32;
	sparseResidencyBuffer: VkBool32;
	sparseResidencyImage2D: VkBool32;
	sparseResidencyImage3D: VkBool32;
	sparseResidency2Samples: VkBool32;
	sparseResidency4Samples: VkBool32;
	sparseResidency8Samples: VkBool32;
	sparseResidency16Samples: VkBool32;
	sparseResidencyAliased: VkBool32;
	variableMultisampleRate: VkBool32;
	inheritedQueries: VkBool32;
}
VkPhysicalDeviceLimits :: struct {
	maxImageDimension1D: u32;
	maxImageDimension2D: u32;
	maxImageDimension3D: u32;
	maxImageDimensionCube: u32;
	maxImageArrayLayers: u32;
	maxTexelBufferElements: u32;
	maxUniformBufferRange: u32;
	maxStorageBufferRange: u32;
	maxPushConstantsSize: u32;
	maxMemoryAllocationCount: u32;
	maxSamplerAllocationCount: u32;
	bufferImageGranularity: VkDeviceSize;
	sparseAddressSpaceSize: VkDeviceSize;
	maxBoundDescriptorSets: u32;
	maxPerStageDescriptorSamplers: u32;
	maxPerStageDescriptorUniformBuffers: u32;
	maxPerStageDescriptorStorageBuffers: u32;
	maxPerStageDescriptorSampledImages: u32;
	maxPerStageDescriptorStorageImages: u32;
	maxPerStageDescriptorInputAttachments: u32;
	maxPerStageResources: u32;
	maxDescriptorSetSamplers: u32;
	maxDescriptorSetUniformBuffers: u32;
	maxDescriptorSetUniformBuffersDynamic: u32;
	maxDescriptorSetStorageBuffers: u32;
	maxDescriptorSetStorageBuffersDynamic: u32;
	maxDescriptorSetSampledImages: u32;
	maxDescriptorSetStorageImages: u32;
	maxDescriptorSetInputAttachments: u32;
	maxVertexInputAttributes: u32;
	maxVertexInputBindings: u32;
	maxVertexInputAttributeOffset: u32;
	maxVertexInputBindingStride: u32;
	maxVertexOutputComponents: u32;
	maxTessellationGenerationLevel: u32;
	maxTessellationPatchSize: u32;
	maxTessellationControlPerVertexInputComponents: u32;
	maxTessellationControlPerVertexOutputComponents: u32;
	maxTessellationControlPerPatchOutputComponents: u32;
	maxTessellationControlTotalOutputComponents: u32;
	maxTessellationEvaluationInputComponents: u32;
	maxTessellationEvaluationOutputComponents: u32;
	maxGeometryShaderInvocations: u32;
	maxGeometryInputComponents: u32;
	maxGeometryOutputComponents: u32;
	maxGeometryOutputVertices: u32;
	maxGeometryTotalOutputComponents: u32;
	maxFragmentInputComponents: u32;
	maxFragmentOutputAttachments: u32;
	maxFragmentDualSrcAttachments: u32;
	maxFragmentCombinedOutputResources: u32;
	maxComputeSharedMemorySize: u32;
	maxComputeWorkGroupCount: [3]u32;
	maxComputeWorkGroupInvocations: u32;
	maxComputeWorkGroupSize: [3]u32;
	subPixelPrecisionBits: u32;
	subTexelPrecisionBits: u32;
	mipmapPrecisionBits: u32;
	maxDrawIndexedIndexValue: u32;
	maxDrawIndirectCount: u32;
	maxSamplerLodBias: f32;
	maxSamplerAnisotropy: f32;
	maxViewports: u32;
	maxViewportDimensions: [2]u32;
	viewportBoundsRange: [2]f32;
	viewportSubPixelBits: u32;
	minMemoryMapAlignment: usize;
	minTexelBufferOffsetAlignment: VkDeviceSize;
	minUniformBufferOffsetAlignment: VkDeviceSize;
	minStorageBufferOffsetAlignment: VkDeviceSize;
	minTexelOffset: s32;
	maxTexelOffset: u32;
	minTexelGatherOffset: s32;
	maxTexelGatherOffset: u32;
	minInterpolationOffset: f32;
	maxInterpolationOffset: f32;
	subPixelInterpolationOffsetBits: u32;
	maxFramebufferWidth: u32;
	maxFramebufferHeight: u32;
	maxFramebufferLayers: u32;
	framebufferColorSampleCounts: VkSampleCountFlags;
	framebufferDepthSampleCounts: VkSampleCountFlags;
	framebufferStencilSampleCounts: VkSampleCountFlags;
	framebufferNoAttachmentsSampleCounts: VkSampleCountFlags;
	maxColorAttachments: u32;
	sampledImageColorSampleCounts: VkSampleCountFlags;
	sampledImageIntegerSampleCounts: VkSampleCountFlags;
	sampledImageDepthSampleCounts: VkSampleCountFlags;
	sampledImageStencilSampleCounts: VkSampleCountFlags;
	storageImageSampleCounts: VkSampleCountFlags;
	maxSampleMaskWords: u32;
	timestampComputeAndGraphics: VkBool32;
	timestampPeriod: f32;
	maxClipDistances: u32;
	maxCullDistances: u32;
	maxCombinedClipAndCullDistances: u32;
	discreteQueuePriorities: u32;
	pointSizeRange: [2]f32;
	lineWidthRange: [2]f32;
	pointSizeGranularity: f32;
	lineWidthGranularity: f32;
	strictLines: VkBool32;
	standardSampleLocations: VkBool32;
	optimalBufferCopyOffsetAlignment: VkDeviceSize;
	optimalBufferCopyRowPitchAlignment: VkDeviceSize;
	nonCoherentAtomSize: VkDeviceSize;
}
VkPhysicalDeviceMemoryProperties :: struct {
	memoryTypeCount: u32;
	memoryTypes: [32]VkMemoryType;
	memoryHeapCount: u32;
	memoryHeaps: [16]VkMemoryHeap;
}
VkPhysicalDeviceSparseProperties :: struct {
	residencyStandard2DBlockShape: VkBool32;
	residencyStandard2DMultisampleBlockShape: VkBool32;
	residencyStandard3DBlockShape: VkBool32;
	residencyAlignedMipSize: VkBool32;
	residencyNonResidentStrict: VkBool32;
}
VkPhysicalDeviceProperties :: struct {
	apiVersion: u32;
	driverVersion: u32;
	vendorID: u32;
	deviceID: u32;
	deviceType: VkPhysicalDeviceType;
	deviceName: [256]C.char;
	pipelineCacheUUID: [16]u8;
	limits: VkPhysicalDeviceLimits;
	sparseProperties: VkPhysicalDeviceSparseProperties;
}
VkQueueFamilyProperties :: struct {
	queueFlags: VkQueueFlags;
	queueCount: u32;
	timestampValidBits: u32;
	minImageTransferGranularity: VkExtent3D;
}
VkDeviceQueueCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkDeviceQueueCreateFlags;
	queueFamilyIndex: u32;
	queueCount: u32;
	pQueuePriorities: *f32;
}
VkDeviceCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkDeviceCreateFlags;
	queueCreateInfoCount: u32;
	pQueueCreateInfos: *VkDeviceQueueCreateInfo;
	enabledLayerCount: u32;
	ppEnabledLayerNames: **C.char;
	enabledExtensionCount: u32;
	ppEnabledExtensionNames: **C.char;
	pEnabledFeatures: *VkPhysicalDeviceFeatures;
}
VkExtensionProperties :: struct {
	extensionName: [256]C.char;
	specVersion: u32;
}
VkLayerProperties :: struct {
	layerName: [256]C.char;
	specVersion: u32;
	implementationVersion: u32;
	description: [256]C.char;
}
VkSubmitInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	waitSemaphoreCount: u32;
	pWaitSemaphores: *VkSemaphore;
	pWaitDstStageMask: *VkPipelineStageFlags;
	commandBufferCount: u32;
	pCommandBuffers: *VkCommandBuffer;
	signalSemaphoreCount: u32;
	pSignalSemaphores: *VkSemaphore;
}
VkMappedMemoryRange :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	memory: VkDeviceMemory;
	offset: VkDeviceSize;
	size: VkDeviceSize;
}
VkMemoryAllocateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	allocationSize: VkDeviceSize;
	memoryTypeIndex: u32;
}
VkMemoryRequirements :: struct {
	size: VkDeviceSize;
	alignment: VkDeviceSize;
	memoryTypeBits: u32;
}
VkSparseMemoryBind :: struct {
	resourceOffset: VkDeviceSize;
	size: VkDeviceSize;
	memory: VkDeviceMemory;
	memoryOffset: VkDeviceSize;
	flags: VkSparseMemoryBindFlags;
}
VkSparseBufferMemoryBindInfo :: struct {
	buffer: VkBuffer;
	bindCount: u32;
	pBinds: *VkSparseMemoryBind;
}
VkSparseImageOpaqueMemoryBindInfo :: struct {
	image: VkImage;
	bindCount: u32;
	pBinds: *VkSparseMemoryBind;
}
VkImageSubresource :: struct {
	aspectMask: VkImageAspectFlags;
	mipLevel: u32;
	arrayLayer: u32;
}
VkSparseImageMemoryBind :: struct {
	subresource: VkImageSubresource;
	offset: VkOffset3D;
	extent: VkExtent3D;
	memory: VkDeviceMemory;
	memoryOffset: VkDeviceSize;
	flags: VkSparseMemoryBindFlags;
}
VkSparseImageMemoryBindInfo :: struct {
	image: VkImage;
	bindCount: u32;
	pBinds: *VkSparseImageMemoryBind;
}
VkBindSparseInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	waitSemaphoreCount: u32;
	pWaitSemaphores: *VkSemaphore;
	bufferBindCount: u32;
	pBufferBinds: *VkSparseBufferMemoryBindInfo;
	imageOpaqueBindCount: u32;
	pImageOpaqueBinds: *VkSparseImageOpaqueMemoryBindInfo;
	imageBindCount: u32;
	pImageBinds: *VkSparseImageMemoryBindInfo;
	signalSemaphoreCount: u32;
	pSignalSemaphores: *VkSemaphore;
}
VkSparseImageFormatProperties :: struct {
	aspectMask: VkImageAspectFlags;
	imageGranularity: VkExtent3D;
	flags: VkSparseImageFormatFlags;
}
VkSparseImageMemoryRequirements :: struct {
	formatProperties: VkSparseImageFormatProperties;
	imageMipTailFirstLod: u32;
	imageMipTailSize: VkDeviceSize;
	imageMipTailOffset: VkDeviceSize;
	imageMipTailStride: VkDeviceSize;
}
VkFenceCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkFenceCreateFlags;
}
VkSemaphoreCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkSemaphoreCreateFlags;
}
VkEventCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkEventCreateFlags;
}
VkQueryPoolCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkQueryPoolCreateFlags;
	queryType: VkQueryType;
	queryCount: u32;
	pipelineStatistics: VkQueryPipelineStatisticFlags;
}
VkBufferCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkBufferCreateFlags;
	size: VkDeviceSize;
	usage: VkBufferUsageFlags;
	sharingMode: VkSharingMode;
	queueFamilyIndexCount: u32;
	pQueueFamilyIndices: *u32;
}
VkBufferViewCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkBufferViewCreateFlags;
	buffer: VkBuffer;
	format: VkFormat;
	offset: VkDeviceSize;
	range: VkDeviceSize;
}
VkImageCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkImageCreateFlags;
	imageType: VkImageType;
	format: VkFormat;
	extent: VkExtent3D;
	mipLevels: u32;
	arrayLayers: u32;
	samples: VkSampleCountFlagBits;
	tiling: VkImageTiling;
	usage: VkImageUsageFlags;
	sharingMode: VkSharingMode;
	queueFamilyIndexCount: u32;
	pQueueFamilyIndices: *u32;
	initialLayout: VkImageLayout;
}
VkSubresourceLayout :: struct {
	offset: VkDeviceSize;
	size: VkDeviceSize;
	rowPitch: VkDeviceSize;
	arrayPitch: VkDeviceSize;
	depthPitch: VkDeviceSize;
}
VkComponentMapping :: struct {
	r: VkComponentSwizzle;
	g: VkComponentSwizzle;
	b: VkComponentSwizzle;
	a: VkComponentSwizzle;
}
VkImageViewCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkImageViewCreateFlags;
	image: VkImage;
	viewType: VkImageViewType;
	format: VkFormat;
	components: VkComponentMapping;
	subresourceRange: VkImageSubresourceRange;
}
VkShaderModuleCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkShaderModuleCreateFlags;
	codeSize: usize;
	pCode: *u32;
}
VkPipelineCacheCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkPipelineCacheCreateFlags;
	initialDataSize: usize;
	pInitialData: C.void_ptr;
}
VkSpecializationMapEntry :: struct {
	constantID: u32;
	offset: u32;
	size: usize;
}
VkSpecializationInfo :: struct {
	mapEntryCount: u32;
	pMapEntries: *VkSpecializationMapEntry;
	dataSize: usize;
	pData: C.void_ptr;
}
VkPipelineShaderStageCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkPipelineShaderStageCreateFlags;
	stage: VkShaderStageFlagBits;
	module: VkShaderModule;
	pName: *C.char;
	pSpecializationInfo: *VkSpecializationInfo;
}
VkComputePipelineCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkPipelineCreateFlags;
	stage: VkPipelineShaderStageCreateInfo;
	layout: VkPipelineLayout;
	basePipelineHandle: VkPipeline;
	basePipelineIndex: s32;
}
VkVertexInputBindingDescription :: struct {
	binding: u32;
	stride: u32;
	inputRate: VkVertexInputRate;
}
VkVertexInputAttributeDescription :: struct {
	location: u32;
	binding: u32;
	format: VkFormat;
	offset: u32;
}
VkPipelineVertexInputStateCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkPipelineVertexInputStateCreateFlags;
	vertexBindingDescriptionCount: u32;
	pVertexBindingDescriptions: *VkVertexInputBindingDescription;
	vertexAttributeDescriptionCount: u32;
	pVertexAttributeDescriptions: *VkVertexInputAttributeDescription;
}
VkPipelineInputAssemblyStateCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkPipelineInputAssemblyStateCreateFlags;
	topology: VkPrimitiveTopology;
	primitiveRestartEnable: VkBool32;
}
VkPipelineTessellationStateCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkPipelineTessellationStateCreateFlags;
	patchControlPoints: u32;
}
VkViewport :: struct {
	x: f32;
	y: f32;
	width: f32;
	height: f32;
	minDepth: f32;
	maxDepth: f32;
}
VkPipelineViewportStateCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkPipelineViewportStateCreateFlags;
	viewportCount: u32;
	pViewports: *VkViewport;
	scissorCount: u32;
	pScissors: *VkRect2D;
}
VkPipelineRasterizationStateCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkPipelineRasterizationStateCreateFlags;
	depthClampEnable: VkBool32;
	rasterizerDiscardEnable: VkBool32;
	polygonMode: VkPolygonMode;
	cullMode: VkCullModeFlags;
	frontFace: VkFrontFace;
	depthBiasEnable: VkBool32;
	depthBiasConstantFactor: f32;
	depthBiasClamp: f32;
	depthBiasSlopeFactor: f32;
	lineWidth: f32;
}
VkPipelineMultisampleStateCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkPipelineMultisampleStateCreateFlags;
	rasterizationSamples: VkSampleCountFlagBits;
	sampleShadingEnable: VkBool32;
	minSampleShading: f32;
	pSampleMask: *VkSampleMask;
	alphaToCoverageEnable: VkBool32;
	alphaToOneEnable: VkBool32;
}
VkStencilOpState :: struct {
	failOp: VkStencilOp;
	passOp: VkStencilOp;
	depthFailOp: VkStencilOp;
	compareOp: VkCompareOp;
	compareMask: u32;
	writeMask: u32;
	reference: u32;
}
VkPipelineDepthStencilStateCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkPipelineDepthStencilStateCreateFlags;
	depthTestEnable: VkBool32;
	depthWriteEnable: VkBool32;
	depthCompareOp: VkCompareOp;
	depthBoundsTestEnable: VkBool32;
	stencilTestEnable: VkBool32;
	front: VkStencilOpState;
	back: VkStencilOpState;
	minDepthBounds: f32;
	maxDepthBounds: f32;
}
VkPipelineColorBlendAttachmentState :: struct {
	blendEnable: VkBool32;
	srcColorBlendFactor: VkBlendFactor;
	dstColorBlendFactor: VkBlendFactor;
	colorBlendOp: VkBlendOp;
	srcAlphaBlendFactor: VkBlendFactor;
	dstAlphaBlendFactor: VkBlendFactor;
	alphaBlendOp: VkBlendOp;
	colorWriteMask: VkColorComponentFlags;
}
VkPipelineColorBlendStateCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkPipelineColorBlendStateCreateFlags;
	logicOpEnable: VkBool32;
	logicOp: VkLogicOp;
	attachmentCount: u32;
	pAttachments: *VkPipelineColorBlendAttachmentState;
	blendConstants: [4]f32;
}
VkPipelineDynamicStateCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkPipelineDynamicStateCreateFlags;
	dynamicStateCount: u32;
	pDynamicStates: *VkDynamicState;
}
VkGraphicsPipelineCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkPipelineCreateFlags;
	stageCount: u32;
	pStages: *VkPipelineShaderStageCreateInfo;
	pVertexInputState: *VkPipelineVertexInputStateCreateInfo;
	pInputAssemblyState: *VkPipelineInputAssemblyStateCreateInfo;
	pTessellationState: *VkPipelineTessellationStateCreateInfo;
	pViewportState: *VkPipelineViewportStateCreateInfo;
	pRasterizationState: *VkPipelineRasterizationStateCreateInfo;
	pMultisampleState: *VkPipelineMultisampleStateCreateInfo;
	pDepthStencilState: *VkPipelineDepthStencilStateCreateInfo;
	pColorBlendState: *VkPipelineColorBlendStateCreateInfo;
	pDynamicState: *VkPipelineDynamicStateCreateInfo;
	layout: VkPipelineLayout;
	renderPass: VkRenderPass;
	subpass: u32;
	basePipelineHandle: VkPipeline;
	basePipelineIndex: s32;
}
VkPushConstantRange :: struct {
	stageFlags: VkShaderStageFlags;
	offset: u32;
	size: u32;
}
VkPipelineLayoutCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkPipelineLayoutCreateFlags;
	setLayoutCount: u32;
	pSetLayouts: *VkDescriptorSetLayout;
	pushConstantRangeCount: u32;
	pPushConstantRanges: *VkPushConstantRange;
}
VkSamplerCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkSamplerCreateFlags;
	magFilter: VkFilter;
	minFilter: VkFilter;
	mipmapMode: VkSamplerMipmapMode;
	addressModeU: VkSamplerAddressMode;
	addressModeV: VkSamplerAddressMode;
	addressModeW: VkSamplerAddressMode;
	mipLodBias: f32;
	anisotropyEnable: VkBool32;
	maxAnisotropy: f32;
	compareEnable: VkBool32;
	compareOp: VkCompareOp;
	minLod: f32;
	maxLod: f32;
	borderColor: VkBorderColor;
	unnormalizedCoordinates: VkBool32;
}
VkCopyDescriptorSet :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	srcSet: VkDescriptorSet;
	srcBinding: u32;
	srcArrayElement: u32;
	dstSet: VkDescriptorSet;
	dstBinding: u32;
	dstArrayElement: u32;
	descriptorCount: u32;
}
VkDescriptorBufferInfo :: struct {
	buffer: VkBuffer;
	offset: VkDeviceSize;
	range: VkDeviceSize;
}
VkDescriptorImageInfo :: struct {
	sampler: VkSampler;
	imageView: VkImageView;
	imageLayout: VkImageLayout;
}
VkDescriptorPoolSize :: struct {
	t: VkDescriptorType;
	descriptorCount: u32;
}
VkDescriptorPoolCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkDescriptorPoolCreateFlags;
	maxSets: u32;
	poolSizeCount: u32;
	pPoolSizes: *VkDescriptorPoolSize;
}
VkDescriptorSetAllocateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	descriptorPool: VkDescriptorPool;
	descriptorSetCount: u32;
	pSetLayouts: *VkDescriptorSetLayout;
}
VkDescriptorSetLayoutBinding :: struct {
	binding: u32;
	descriptorType: VkDescriptorType;
	descriptorCount: u32;
	stageFlags: VkShaderStageFlags;
	pImmutableSamplers: *VkSampler;
}
VkDescriptorSetLayoutCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkDescriptorSetLayoutCreateFlags;
	bindingCount: u32;
	pBindings: *VkDescriptorSetLayoutBinding;
}
VkWriteDescriptorSet :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	dstSet: VkDescriptorSet;
	dstBinding: u32;
	dstArrayElement: u32;
	descriptorCount: u32;
	descriptorType: VkDescriptorType;
	pImageInfo: *VkDescriptorImageInfo;
	pBufferInfo: *VkDescriptorBufferInfo;
	pTexelBufferView: *VkBufferView;
}
VkAttachmentDescription :: struct {
	flags: VkAttachmentDescriptionFlags;
	format: VkFormat;
	samples: VkSampleCountFlagBits;
	loadOp: VkAttachmentLoadOp;
	storeOp: VkAttachmentStoreOp;
	stencilLoadOp: VkAttachmentLoadOp;
	stencilStoreOp: VkAttachmentStoreOp;
	initialLayout: VkImageLayout;
	finalLayout: VkImageLayout;
}
VkAttachmentReference :: struct {
	attachment: u32;
	layout: VkImageLayout;
}
VkFramebufferCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkFramebufferCreateFlags;
	renderPass: VkRenderPass;
	attachmentCount: u32;
	pAttachments: *VkImageView;
	width: u32;
	height: u32;
	layers: u32;
}
VkSubpassDescription :: struct {
	flags: VkSubpassDescriptionFlags;
	pipelineBindPoint: VkPipelineBindPoint;
	inputAttachmentCount: u32;
	pInputAttachments: *VkAttachmentReference;
	colorAttachmentCount: u32;
	pColorAttachments: *VkAttachmentReference;
	pResolveAttachments: *VkAttachmentReference;
	pDepthStencilAttachment: *VkAttachmentReference;
	preserveAttachmentCount: u32;
	pPreserveAttachments: *u32;
}
VkSubpassDependency :: struct {
	srcSubpass: u32;
	dstSubpass: u32;
	srcStageMask: VkPipelineStageFlags;
	dstStageMask: VkPipelineStageFlags;
	srcAccessMask: VkAccessFlags;
	dstAccessMask: VkAccessFlags;
	dependencyFlags: VkDependencyFlags;
}
VkRenderPassCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkRenderPassCreateFlags;
	attachmentCount: u32;
	pAttachments: *VkAttachmentDescription;
	subpassCount: u32;
	pSubpasses: *VkSubpassDescription;
	dependencyCount: u32;
	pDependencies: *VkSubpassDependency;
}
VkCommandPoolCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkCommandPoolCreateFlags;
	queueFamilyIndex: u32;
}
VkCommandBufferAllocateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	commandPool: VkCommandPool;
	level: VkCommandBufferLevel;
	commandBufferCount: u32;
}
VkCommandBufferInheritanceInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	renderPass: VkRenderPass;
	subpass: u32;
	framebuffer: VkFramebuffer;
	occlusionQueryEnable: VkBool32;
	queryFlags: VkQueryControlFlags;
	pipelineStatistics: VkQueryPipelineStatisticFlags;
}
VkCommandBufferBeginInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkCommandBufferUsageFlags;
	pInheritanceInfo: *VkCommandBufferInheritanceInfo;
}
VkBufferCopy :: struct {
	srcOffset: VkDeviceSize;
	dstOffset: VkDeviceSize;
	size: VkDeviceSize;
}
VkImageSubresourceLayers :: struct {
	aspectMask: VkImageAspectFlags;
	mipLevel: u32;
	baseArrayLayer: u32;
	layerCount: u32;
}
VkBufferImageCopy :: struct {
	bufferOffset: VkDeviceSize;
	bufferRowLength: u32;
	bufferImageHeight: u32;
	imageSubresource: VkImageSubresourceLayers;
	imageOffset: VkOffset3D;
	imageExtent: VkExtent3D;
}
VkClearColorValue :: union {
	float32: [4]f32;
	int32: [4]s32;
	uint32: [4]u32;
}
VkClearDepthStencilValue :: struct {
	depth: f32;
	stencil: u32;
}
VkClearValue :: union {
	color: VkClearColorValue;
	depthStencil: VkClearDepthStencilValue;
}
VkClearAttachment :: struct {
	aspectMask: VkImageAspectFlags;
	colorAttachment: u32;
	clearValue: VkClearValue;
}
VkClearRect :: struct {
	rect: VkRect2D;
	baseArrayLayer: u32;
	layerCount: u32;
}
VkImageBlit :: struct {
	srcSubresource: VkImageSubresourceLayers;
	srcOffsets: [2]VkOffset3D;
	dstSubresource: VkImageSubresourceLayers;
	dstOffsets: [2]VkOffset3D;
}
VkImageCopy :: struct {
	srcSubresource: VkImageSubresourceLayers;
	srcOffset: VkOffset3D;
	dstSubresource: VkImageSubresourceLayers;
	dstOffset: VkOffset3D;
	extent: VkExtent3D;
}
VkImageResolve :: struct {
	srcSubresource: VkImageSubresourceLayers;
	srcOffset: VkOffset3D;
	dstSubresource: VkImageSubresourceLayers;
	dstOffset: VkOffset3D;
	extent: VkExtent3D;
}
VkRenderPassBeginInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	renderPass: VkRenderPass;
	framebuffer: VkFramebuffer;
	renderArea: VkRect2D;
	clearValueCount: u32;
	pClearValues: *VkClearValue;
}
PFN_vkCreateInstance :: *fn (*VkInstanceCreateInfo, *VkAllocationCallbacks, *VkInstance) VkResult;
PFN_vkDestroyInstance :: *fn (VkInstance, *VkAllocationCallbacks);
PFN_vkEnumeratePhysicalDevices :: *fn (VkInstance, *u32, *VkPhysicalDevice) VkResult;
PFN_vkGetPhysicalDeviceFeatures :: *fn (VkPhysicalDevice, *VkPhysicalDeviceFeatures);
PFN_vkGetPhysicalDeviceFormatProperties :: *fn (VkPhysicalDevice, VkFormat, *VkFormatProperties);
PFN_vkGetPhysicalDeviceImageFormatProperties :: *fn (VkPhysicalDevice, VkFormat, VkImageType, VkImageTiling, VkImageUsageFlags, VkImageCreateFlags, *VkImageFormatProperties) VkResult;
PFN_vkGetPhysicalDeviceProperties :: *fn (VkPhysicalDevice, *VkPhysicalDeviceProperties);
PFN_vkGetPhysicalDeviceQueueFamilyProperties :: *fn (VkPhysicalDevice, *u32, *VkQueueFamilyProperties);
PFN_vkGetPhysicalDeviceMemoryProperties :: *fn (VkPhysicalDevice, *VkPhysicalDeviceMemoryProperties);
PFN_vkGetInstanceProcAddr :: *fn (VkInstance, *C.char) PFN_vkVoidFunction;
PFN_vkGetDeviceProcAddr :: *fn (VkDevice, *C.char) PFN_vkVoidFunction;
PFN_vkCreateDevice :: *fn (VkPhysicalDevice, *VkDeviceCreateInfo, *VkAllocationCallbacks, *VkDevice) VkResult;
PFN_vkDestroyDevice :: *fn (VkDevice, *VkAllocationCallbacks);
PFN_vkEnumerateInstanceExtensionProperties :: *fn (*C.char, *u32, *VkExtensionProperties) VkResult;
PFN_vkEnumerateDeviceExtensionProperties :: *fn (VkPhysicalDevice, *C.char, *u32, *VkExtensionProperties) VkResult;
PFN_vkEnumerateInstanceLayerProperties :: *fn (*u32, *VkLayerProperties) VkResult;
PFN_vkEnumerateDeviceLayerProperties :: *fn (VkPhysicalDevice, *u32, *VkLayerProperties) VkResult;
PFN_vkGetDeviceQueue :: *fn (VkDevice, u32, u32, *VkQueue);
PFN_vkQueueSubmit :: *fn (VkQueue, u32, *VkSubmitInfo, VkFence) VkResult;
PFN_vkQueueWaitIdle :: *fn (VkQueue) VkResult;
PFN_vkDeviceWaitIdle :: *fn (VkDevice) VkResult;
PFN_vkAllocateMemory :: *fn (VkDevice, *VkMemoryAllocateInfo, *VkAllocationCallbacks, *VkDeviceMemory) VkResult;
PFN_vkFreeMemory :: *fn (VkDevice, VkDeviceMemory, *VkAllocationCallbacks);
PFN_vkMapMemory :: *fn (VkDevice, VkDeviceMemory, VkDeviceSize, VkDeviceSize, VkMemoryMapFlags, *C.void_ptr) VkResult;
PFN_vkUnmapMemory :: *fn (VkDevice, VkDeviceMemory);
PFN_vkFlushMappedMemoryRanges :: *fn (VkDevice, u32, *VkMappedMemoryRange) VkResult;
PFN_vkInvalidateMappedMemoryRanges :: *fn (VkDevice, u32, *VkMappedMemoryRange) VkResult;
PFN_vkGetDeviceMemoryCommitment :: *fn (VkDevice, VkDeviceMemory, *VkDeviceSize);
PFN_vkBindBufferMemory :: *fn (VkDevice, VkBuffer, VkDeviceMemory, VkDeviceSize) VkResult;
PFN_vkBindImageMemory :: *fn (VkDevice, VkImage, VkDeviceMemory, VkDeviceSize) VkResult;
PFN_vkGetBufferMemoryRequirements :: *fn (VkDevice, VkBuffer, *VkMemoryRequirements);
PFN_vkGetImageMemoryRequirements :: *fn (VkDevice, VkImage, *VkMemoryRequirements);
PFN_vkGetImageSparseMemoryRequirements :: *fn (VkDevice, VkImage, *u32, *VkSparseImageMemoryRequirements);
PFN_vkGetPhysicalDeviceSparseImageFormatProperties :: *fn (VkPhysicalDevice, VkFormat, VkImageType, VkSampleCountFlagBits, VkImageUsageFlags, VkImageTiling, *u32, *VkSparseImageFormatProperties);
PFN_vkQueueBindSparse :: *fn (VkQueue, u32, *VkBindSparseInfo, VkFence) VkResult;
PFN_vkCreateFence :: *fn (VkDevice, *VkFenceCreateInfo, *VkAllocationCallbacks, *VkFence) VkResult;
PFN_vkDestroyFence :: *fn (VkDevice, VkFence, *VkAllocationCallbacks);
PFN_vkResetFences :: *fn (VkDevice, u32, *VkFence) VkResult;
PFN_vkGetFenceStatus :: *fn (VkDevice, VkFence) VkResult;
PFN_vkWaitForFences :: *fn (VkDevice, u32, *VkFence, VkBool32, u64) VkResult;
PFN_vkCreateSemaphore :: *fn (VkDevice, *VkSemaphoreCreateInfo, *VkAllocationCallbacks, *VkSemaphore) VkResult;
PFN_vkDestroySemaphore :: *fn (VkDevice, VkSemaphore, *VkAllocationCallbacks);
PFN_vkCreateEvent :: *fn (VkDevice, *VkEventCreateInfo, *VkAllocationCallbacks, *VkEvent) VkResult;
PFN_vkDestroyEvent :: *fn (VkDevice, VkEvent, *VkAllocationCallbacks);
PFN_vkGetEventStatus :: *fn (VkDevice, VkEvent) VkResult;
PFN_vkSetEvent :: *fn (VkDevice, VkEvent) VkResult;
PFN_vkResetEvent :: *fn (VkDevice, VkEvent) VkResult;
PFN_vkCreateQueryPool :: *fn (VkDevice, *VkQueryPoolCreateInfo, *VkAllocationCallbacks, *VkQueryPool) VkResult;
PFN_vkDestroyQueryPool :: *fn (VkDevice, VkQueryPool, *VkAllocationCallbacks);
PFN_vkGetQueryPoolResults :: *fn (VkDevice, VkQueryPool, u32, u32, usize, C.void_ptr, VkDeviceSize, VkQueryResultFlags) VkResult;
PFN_vkCreateBuffer :: *fn (VkDevice, *VkBufferCreateInfo, *VkAllocationCallbacks, *VkBuffer) VkResult;
PFN_vkDestroyBuffer :: *fn (VkDevice, VkBuffer, *VkAllocationCallbacks);
PFN_vkCreateBufferView :: *fn (VkDevice, *VkBufferViewCreateInfo, *VkAllocationCallbacks, *VkBufferView) VkResult;
PFN_vkDestroyBufferView :: *fn (VkDevice, VkBufferView, *VkAllocationCallbacks);
PFN_vkCreateImage :: *fn (VkDevice, *VkImageCreateInfo, *VkAllocationCallbacks, *VkImage) VkResult;
PFN_vkDestroyImage :: *fn (VkDevice, VkImage, *VkAllocationCallbacks);
PFN_vkGetImageSubresourceLayout :: *fn (VkDevice, VkImage, *VkImageSubresource, *VkSubresourceLayout);
PFN_vkCreateImageView :: *fn (VkDevice, *VkImageViewCreateInfo, *VkAllocationCallbacks, *VkImageView) VkResult;
PFN_vkDestroyImageView :: *fn (VkDevice, VkImageView, *VkAllocationCallbacks);
PFN_vkCreateShaderModule :: *fn (VkDevice, *VkShaderModuleCreateInfo, *VkAllocationCallbacks, *VkShaderModule) VkResult;
PFN_vkDestroyShaderModule :: *fn (VkDevice, VkShaderModule, *VkAllocationCallbacks);
PFN_vkCreatePipelineCache :: *fn (VkDevice, *VkPipelineCacheCreateInfo, *VkAllocationCallbacks, *VkPipelineCache) VkResult;
PFN_vkDestroyPipelineCache :: *fn (VkDevice, VkPipelineCache, *VkAllocationCallbacks);
PFN_vkGetPipelineCacheData :: *fn (VkDevice, VkPipelineCache, *usize, C.void_ptr) VkResult;
PFN_vkMergePipelineCaches :: *fn (VkDevice, VkPipelineCache, u32, *VkPipelineCache) VkResult;
PFN_vkCreateGraphicsPipelines :: *fn (VkDevice, VkPipelineCache, u32, *VkGraphicsPipelineCreateInfo, *VkAllocationCallbacks, *VkPipeline) VkResult;
PFN_vkCreateComputePipelines :: *fn (VkDevice, VkPipelineCache, u32, *VkComputePipelineCreateInfo, *VkAllocationCallbacks, *VkPipeline) VkResult;
PFN_vkDestroyPipeline :: *fn (VkDevice, VkPipeline, *VkAllocationCallbacks);
PFN_vkCreatePipelineLayout :: *fn (VkDevice, *VkPipelineLayoutCreateInfo, *VkAllocationCallbacks, *VkPipelineLayout) VkResult;
PFN_vkDestroyPipelineLayout :: *fn (VkDevice, VkPipelineLayout, *VkAllocationCallbacks);
PFN_vkCreateSampler :: *fn (VkDevice, *VkSamplerCreateInfo, *VkAllocationCallbacks, *VkSampler) VkResult;
PFN_vkDestroySampler :: *fn (VkDevice, VkSampler, *VkAllocationCallbacks);
PFN_vkCreateDescriptorSetLayout :: *fn (VkDevice, *VkDescriptorSetLayoutCreateInfo, *VkAllocationCallbacks, *VkDescriptorSetLayout) VkResult;
PFN_vkDestroyDescriptorSetLayout :: *fn (VkDevice, VkDescriptorSetLayout, *VkAllocationCallbacks);
PFN_vkCreateDescriptorPool :: *fn (VkDevice, *VkDescriptorPoolCreateInfo, *VkAllocationCallbacks, *VkDescriptorPool) VkResult;
PFN_vkDestroyDescriptorPool :: *fn (VkDevice, VkDescriptorPool, *VkAllocationCallbacks);
PFN_vkResetDescriptorPool :: *fn (VkDevice, VkDescriptorPool, VkDescriptorPoolResetFlags) VkResult;
PFN_vkAllocateDescriptorSets :: *fn (VkDevice, *VkDescriptorSetAllocateInfo, *VkDescriptorSet) VkResult;
PFN_vkFreeDescriptorSets :: *fn (VkDevice, VkDescriptorPool, u32, *VkDescriptorSet) VkResult;
PFN_vkUpdateDescriptorSets :: *fn (VkDevice, u32, *VkWriteDescriptorSet, u32, *VkCopyDescriptorSet);
PFN_vkCreateFramebuffer :: *fn (VkDevice, *VkFramebufferCreateInfo, *VkAllocationCallbacks, *VkFramebuffer) VkResult;
PFN_vkDestroyFramebuffer :: *fn (VkDevice, VkFramebuffer, *VkAllocationCallbacks);
PFN_vkCreateRenderPass :: *fn (VkDevice, *VkRenderPassCreateInfo, *VkAllocationCallbacks, *VkRenderPass) VkResult;
PFN_vkDestroyRenderPass :: *fn (VkDevice, VkRenderPass, *VkAllocationCallbacks);
PFN_vkGetRenderAreaGranularity :: *fn (VkDevice, VkRenderPass, *VkExtent2D);
PFN_vkCreateCommandPool :: *fn (VkDevice, *VkCommandPoolCreateInfo, *VkAllocationCallbacks, *VkCommandPool) VkResult;
PFN_vkDestroyCommandPool :: *fn (VkDevice, VkCommandPool, *VkAllocationCallbacks);
PFN_vkResetCommandPool :: *fn (VkDevice, VkCommandPool, VkCommandPoolResetFlags) VkResult;
PFN_vkAllocateCommandBuffers :: *fn (VkDevice, *VkCommandBufferAllocateInfo, *VkCommandBuffer) VkResult;
PFN_vkFreeCommandBuffers :: *fn (VkDevice, VkCommandPool, u32, *VkCommandBuffer);
PFN_vkBeginCommandBuffer :: *fn (VkCommandBuffer, *VkCommandBufferBeginInfo) VkResult;
PFN_vkEndCommandBuffer :: *fn (VkCommandBuffer) VkResult;
PFN_vkResetCommandBuffer :: *fn (VkCommandBuffer, VkCommandBufferResetFlags) VkResult;
PFN_vkCmdBindPipeline :: *fn (VkCommandBuffer, VkPipelineBindPoint, VkPipeline);
PFN_vkCmdSetViewport :: *fn (VkCommandBuffer, u32, u32, *VkViewport);
PFN_vkCmdSetScissor :: *fn (VkCommandBuffer, u32, u32, *VkRect2D);
PFN_vkCmdSetLineWidth :: *fn (VkCommandBuffer, f32);
PFN_vkCmdSetDepthBias :: *fn (VkCommandBuffer, f32, f32, f32);
PFN_vkCmdSetBlendConstants :: *fn (VkCommandBuffer, [4]f32);
PFN_vkCmdSetDepthBounds :: *fn (VkCommandBuffer, f32, f32);
PFN_vkCmdSetStencilCompareMask :: *fn (VkCommandBuffer, VkStencilFaceFlags, u32);
PFN_vkCmdSetStencilWriteMask :: *fn (VkCommandBuffer, VkStencilFaceFlags, u32);
PFN_vkCmdSetStencilReference :: *fn (VkCommandBuffer, VkStencilFaceFlags, u32);
PFN_vkCmdBindDescriptorSets :: *fn (VkCommandBuffer, VkPipelineBindPoint, VkPipelineLayout, u32, u32, *VkDescriptorSet, u32, *u32);
PFN_vkCmdBindIndexBuffer :: *fn (VkCommandBuffer, VkBuffer, VkDeviceSize, VkIndexType);
PFN_vkCmdBindVertexBuffers :: *fn (VkCommandBuffer, u32, u32, *VkBuffer, *VkDeviceSize);
PFN_vkCmdDraw :: *fn (VkCommandBuffer, u32, u32, u32, u32);
PFN_vkCmdDrawIndexed :: *fn (VkCommandBuffer, u32, u32, u32, s32, u32);
PFN_vkCmdDrawIndirect :: *fn (VkCommandBuffer, VkBuffer, VkDeviceSize, u32, u32);
PFN_vkCmdDrawIndexedIndirect :: *fn (VkCommandBuffer, VkBuffer, VkDeviceSize, u32, u32);
PFN_vkCmdDispatch :: *fn (VkCommandBuffer, u32, u32, u32);
PFN_vkCmdDispatchIndirect :: *fn (VkCommandBuffer, VkBuffer, VkDeviceSize);
PFN_vkCmdCopyBuffer :: *fn (VkCommandBuffer, VkBuffer, VkBuffer, u32, *VkBufferCopy);
PFN_vkCmdCopyImage :: *fn (VkCommandBuffer, VkImage, VkImageLayout, VkImage, VkImageLayout, u32, *VkImageCopy);
PFN_vkCmdBlitImage :: *fn (VkCommandBuffer, VkImage, VkImageLayout, VkImage, VkImageLayout, u32, *VkImageBlit, VkFilter);
PFN_vkCmdCopyBufferToImage :: *fn (VkCommandBuffer, VkBuffer, VkImage, VkImageLayout, u32, *VkBufferImageCopy);
PFN_vkCmdCopyImageToBuffer :: *fn (VkCommandBuffer, VkImage, VkImageLayout, VkBuffer, u32, *VkBufferImageCopy);
PFN_vkCmdUpdateBuffer :: *fn (VkCommandBuffer, VkBuffer, VkDeviceSize, VkDeviceSize, C.void_ptr);
PFN_vkCmdFillBuffer :: *fn (VkCommandBuffer, VkBuffer, VkDeviceSize, VkDeviceSize, u32);
PFN_vkCmdClearColorImage :: *fn (VkCommandBuffer, VkImage, VkImageLayout, *VkClearColorValue, u32, *VkImageSubresourceRange);
PFN_vkCmdClearDepthStencilImage :: *fn (VkCommandBuffer, VkImage, VkImageLayout, *VkClearDepthStencilValue, u32, *VkImageSubresourceRange);
PFN_vkCmdClearAttachments :: *fn (VkCommandBuffer, u32, *VkClearAttachment, u32, *VkClearRect);
PFN_vkCmdResolveImage :: *fn (VkCommandBuffer, VkImage, VkImageLayout, VkImage, VkImageLayout, u32, *VkImageResolve);
PFN_vkCmdSetEvent :: *fn (VkCommandBuffer, VkEvent, VkPipelineStageFlags);
PFN_vkCmdResetEvent :: *fn (VkCommandBuffer, VkEvent, VkPipelineStageFlags);
PFN_vkCmdWaitEvents :: *fn (VkCommandBuffer, u32, *VkEvent, VkPipelineStageFlags, VkPipelineStageFlags, u32, *VkMemoryBarrier, u32, *VkBufferMemoryBarrier, u32, *VkImageMemoryBarrier);
PFN_vkCmdPipelineBarrier :: *fn (VkCommandBuffer, VkPipelineStageFlags, VkPipelineStageFlags, VkDependencyFlags, u32, *VkMemoryBarrier, u32, *VkBufferMemoryBarrier, u32, *VkImageMemoryBarrier);
PFN_vkCmdBeginQuery :: *fn (VkCommandBuffer, VkQueryPool, u32, VkQueryControlFlags);
PFN_vkCmdEndQuery :: *fn (VkCommandBuffer, VkQueryPool, u32);
PFN_vkCmdResetQueryPool :: *fn (VkCommandBuffer, VkQueryPool, u32, u32);
PFN_vkCmdWriteTimestamp :: *fn (VkCommandBuffer, VkPipelineStageFlagBits, VkQueryPool, u32);
PFN_vkCmdCopyQueryPoolResults :: *fn (VkCommandBuffer, VkQueryPool, u32, u32, VkBuffer, VkDeviceSize, VkDeviceSize, VkQueryResultFlags);
PFN_vkCmdPushConstants :: *fn (VkCommandBuffer, VkPipelineLayout, VkShaderStageFlags, u32, u32, C.void_ptr);
PFN_vkCmdBeginRenderPass :: *fn (VkCommandBuffer, *VkRenderPassBeginInfo, VkSubpassContents);
PFN_vkCmdNextSubpass :: *fn (VkCommandBuffer, VkSubpassContents);
PFN_vkCmdEndRenderPass :: *fn (VkCommandBuffer);
PFN_vkCmdExecuteCommands :: *fn (VkCommandBuffer, u32, *VkCommandBuffer);
vkCreateInstance :: fn (pCreateInfo: *VkInstanceCreateInfo, pAllocator: *VkAllocationCallbacks, pInstance: *VkInstance) VkResult #extern;
vkDestroyInstance :: fn (instance: VkInstance, pAllocator: *VkAllocationCallbacks) #extern;
vkEnumeratePhysicalDevices :: fn (instance: VkInstance, pPhysicalDeviceCount: *u32, pPhysicalDevices: *VkPhysicalDevice) VkResult #extern;
vkGetPhysicalDeviceFeatures :: fn (physicalDevice: VkPhysicalDevice, pFeatures: *VkPhysicalDeviceFeatures) #extern;
vkGetPhysicalDeviceFormatProperties :: fn (physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *VkFormatProperties) #extern;
vkGetPhysicalDeviceImageFormatProperties :: fn (physicalDevice: VkPhysicalDevice, format: VkFormat, t: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, pImageFormatProperties: *VkImageFormatProperties) VkResult #extern;
vkGetPhysicalDeviceProperties :: fn (physicalDevice: VkPhysicalDevice, pProperties: *VkPhysicalDeviceProperties) #extern;
vkGetPhysicalDeviceQueueFamilyProperties :: fn (physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *u32, pQueueFamilyProperties: *VkQueueFamilyProperties) #extern;
vkGetPhysicalDeviceMemoryProperties :: fn (physicalDevice: VkPhysicalDevice, pMemoryProperties: *VkPhysicalDeviceMemoryProperties) #extern;
vkGetInstanceProcAddr :: fn (instance: VkInstance, pName: *C.char) PFN_vkVoidFunction #extern;
vkGetDeviceProcAddr :: fn (device: VkDevice, pName: *C.char) PFN_vkVoidFunction #extern;
vkCreateDevice :: fn (physicalDevice: VkPhysicalDevice, pCreateInfo: *VkDeviceCreateInfo, pAllocator: *VkAllocationCallbacks, pDevice: *VkDevice) VkResult #extern;
vkDestroyDevice :: fn (device: VkDevice, pAllocator: *VkAllocationCallbacks) #extern;
vkEnumerateInstanceExtensionProperties :: fn (pLayerName: *C.char, pPropertyCount: *u32, pProperties: *VkExtensionProperties) VkResult #extern;
vkEnumerateDeviceExtensionProperties :: fn (physicalDevice: VkPhysicalDevice, pLayerName: *C.char, pPropertyCount: *u32, pProperties: *VkExtensionProperties) VkResult #extern;
vkEnumerateInstanceLayerProperties :: fn (pPropertyCount: *u32, pProperties: *VkLayerProperties) VkResult #extern;
vkEnumerateDeviceLayerProperties :: fn (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkLayerProperties) VkResult #extern;
vkGetDeviceQueue :: fn (device: VkDevice, queueFamilyIndex: u32, queueIndex: u32, pQueue: *VkQueue) #extern;
vkQueueSubmit :: fn (queue: VkQueue, submitCount: u32, pSubmits: *VkSubmitInfo, fence: VkFence) VkResult #extern;
vkQueueWaitIdle :: fn (queue: VkQueue) VkResult #extern;
vkDeviceWaitIdle :: fn (device: VkDevice) VkResult #extern;
vkAllocateMemory :: fn (device: VkDevice, pAllocateInfo: *VkMemoryAllocateInfo, pAllocator: *VkAllocationCallbacks, pMemory: *VkDeviceMemory) VkResult #extern;
vkFreeMemory :: fn (device: VkDevice, memory: VkDeviceMemory, pAllocator: *VkAllocationCallbacks) #extern;
vkMapMemory :: fn (device: VkDevice, memory: VkDeviceMemory, offset: VkDeviceSize, size: VkDeviceSize, flags: VkMemoryMapFlags, ppData: *C.void_ptr) VkResult #extern;
vkUnmapMemory :: fn (device: VkDevice, memory: VkDeviceMemory) #extern;
vkFlushMappedMemoryRanges :: fn (device: VkDevice, memoryRangeCount: u32, pMemoryRanges: *VkMappedMemoryRange) VkResult #extern;
vkInvalidateMappedMemoryRanges :: fn (device: VkDevice, memoryRangeCount: u32, pMemoryRanges: *VkMappedMemoryRange) VkResult #extern;
vkGetDeviceMemoryCommitment :: fn (device: VkDevice, memory: VkDeviceMemory, pCommittedMemoryInBytes: *VkDeviceSize) #extern;
vkBindBufferMemory :: fn (device: VkDevice, buffer: VkBuffer, memory: VkDeviceMemory, memoryOffset: VkDeviceSize) VkResult #extern;
vkBindImageMemory :: fn (device: VkDevice, image: VkImage, memory: VkDeviceMemory, memoryOffset: VkDeviceSize) VkResult #extern;
vkGetBufferMemoryRequirements :: fn (device: VkDevice, buffer: VkBuffer, pMemoryRequirements: *VkMemoryRequirements) #extern;
vkGetImageMemoryRequirements :: fn (device: VkDevice, image: VkImage, pMemoryRequirements: *VkMemoryRequirements) #extern;
vkGetImageSparseMemoryRequirements :: fn (device: VkDevice, image: VkImage, pSparseMemoryRequirementCount: *u32, pSparseMemoryRequirements: *VkSparseImageMemoryRequirements) #extern;
vkGetPhysicalDeviceSparseImageFormatProperties :: fn (physicalDevice: VkPhysicalDevice, format: VkFormat, t: VkImageType, samples: VkSampleCountFlagBits, usage: VkImageUsageFlags, tiling: VkImageTiling, pPropertyCount: *u32, pProperties: *VkSparseImageFormatProperties) #extern;
vkQueueBindSparse :: fn (queue: VkQueue, bindInfoCount: u32, pBindInfo: *VkBindSparseInfo, fence: VkFence) VkResult #extern;
vkCreateFence :: fn (device: VkDevice, pCreateInfo: *VkFenceCreateInfo, pAllocator: *VkAllocationCallbacks, pFence: *VkFence) VkResult #extern;
vkDestroyFence :: fn (device: VkDevice, fence: VkFence, pAllocator: *VkAllocationCallbacks) #extern;
vkResetFences :: fn (device: VkDevice, fenceCount: u32, pFences: *VkFence) VkResult #extern;
vkGetFenceStatus :: fn (device: VkDevice, fence: VkFence) VkResult #extern;
vkWaitForFences :: fn (device: VkDevice, fenceCount: u32, pFences: *VkFence, waitAll: VkBool32, timeout: u64) VkResult #extern;
vkCreateSemaphore :: fn (device: VkDevice, pCreateInfo: *VkSemaphoreCreateInfo, pAllocator: *VkAllocationCallbacks, pSemaphore: *VkSemaphore) VkResult #extern;
vkDestroySemaphore :: fn (device: VkDevice, semaphore: VkSemaphore, pAllocator: *VkAllocationCallbacks) #extern;
vkCreateEvent :: fn (device: VkDevice, pCreateInfo: *VkEventCreateInfo, pAllocator: *VkAllocationCallbacks, pEvent: *VkEvent) VkResult #extern;
vkDestroyEvent :: fn (device: VkDevice, event: VkEvent, pAllocator: *VkAllocationCallbacks) #extern;
vkGetEventStatus :: fn (device: VkDevice, event: VkEvent) VkResult #extern;
vkSetEvent :: fn (device: VkDevice, event: VkEvent) VkResult #extern;
vkResetEvent :: fn (device: VkDevice, event: VkEvent) VkResult #extern;
vkCreateQueryPool :: fn (device: VkDevice, pCreateInfo: *VkQueryPoolCreateInfo, pAllocator: *VkAllocationCallbacks, pQueryPool: *VkQueryPool) VkResult #extern;
vkDestroyQueryPool :: fn (device: VkDevice, queryPool: VkQueryPool, pAllocator: *VkAllocationCallbacks) #extern;
vkGetQueryPoolResults :: fn (device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32, dataSize: usize, pData: C.void_ptr, stride: VkDeviceSize, flags: VkQueryResultFlags) VkResult #extern;
vkCreateBuffer :: fn (device: VkDevice, pCreateInfo: *VkBufferCreateInfo, pAllocator: *VkAllocationCallbacks, pBuffer: *VkBuffer) VkResult #extern;
vkDestroyBuffer :: fn (device: VkDevice, buffer: VkBuffer, pAllocator: *VkAllocationCallbacks) #extern;
vkCreateBufferView :: fn (device: VkDevice, pCreateInfo: *VkBufferViewCreateInfo, pAllocator: *VkAllocationCallbacks, pView: *VkBufferView) VkResult #extern;
vkDestroyBufferView :: fn (device: VkDevice, bufferView: VkBufferView, pAllocator: *VkAllocationCallbacks) #extern;
vkCreateImage :: fn (device: VkDevice, pCreateInfo: *VkImageCreateInfo, pAllocator: *VkAllocationCallbacks, pImage: *VkImage) VkResult #extern;
vkDestroyImage :: fn (device: VkDevice, image: VkImage, pAllocator: *VkAllocationCallbacks) #extern;
vkGetImageSubresourceLayout :: fn (device: VkDevice, image: VkImage, pSubresource: *VkImageSubresource, pLayout: *VkSubresourceLayout) #extern;
vkCreateImageView :: fn (device: VkDevice, pCreateInfo: *VkImageViewCreateInfo, pAllocator: *VkAllocationCallbacks, pView: *VkImageView) VkResult #extern;
vkDestroyImageView :: fn (device: VkDevice, imageView: VkImageView, pAllocator: *VkAllocationCallbacks) #extern;
vkCreateShaderModule :: fn (device: VkDevice, pCreateInfo: *VkShaderModuleCreateInfo, pAllocator: *VkAllocationCallbacks, pShaderModule: *VkShaderModule) VkResult #extern;
vkDestroyShaderModule :: fn (device: VkDevice, shaderModule: VkShaderModule, pAllocator: *VkAllocationCallbacks) #extern;
vkCreatePipelineCache :: fn (device: VkDevice, pCreateInfo: *VkPipelineCacheCreateInfo, pAllocator: *VkAllocationCallbacks, pPipelineCache: *VkPipelineCache) VkResult #extern;
vkDestroyPipelineCache :: fn (device: VkDevice, pipelineCache: VkPipelineCache, pAllocator: *VkAllocationCallbacks) #extern;
vkGetPipelineCacheData :: fn (device: VkDevice, pipelineCache: VkPipelineCache, pDataSize: *usize, pData: C.void_ptr) VkResult #extern;
vkMergePipelineCaches :: fn (device: VkDevice, dstCache: VkPipelineCache, srcCacheCount: u32, pSrcCaches: *VkPipelineCache) VkResult #extern;
vkCreateGraphicsPipelines :: fn (device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *VkGraphicsPipelineCreateInfo, pAllocator: *VkAllocationCallbacks, pPipelines: *VkPipeline) VkResult #extern;
vkCreateComputePipelines :: fn (device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *VkComputePipelineCreateInfo, pAllocator: *VkAllocationCallbacks, pPipelines: *VkPipeline) VkResult #extern;
vkDestroyPipeline :: fn (device: VkDevice, pipeline: VkPipeline, pAllocator: *VkAllocationCallbacks) #extern;
vkCreatePipelineLayout :: fn (device: VkDevice, pCreateInfo: *VkPipelineLayoutCreateInfo, pAllocator: *VkAllocationCallbacks, pPipelineLayout: *VkPipelineLayout) VkResult #extern;
vkDestroyPipelineLayout :: fn (device: VkDevice, pipelineLayout: VkPipelineLayout, pAllocator: *VkAllocationCallbacks) #extern;
vkCreateSampler :: fn (device: VkDevice, pCreateInfo: *VkSamplerCreateInfo, pAllocator: *VkAllocationCallbacks, pSampler: *VkSampler) VkResult #extern;
vkDestroySampler :: fn (device: VkDevice, sampler: VkSampler, pAllocator: *VkAllocationCallbacks) #extern;
vkCreateDescriptorSetLayout :: fn (device: VkDevice, pCreateInfo: *VkDescriptorSetLayoutCreateInfo, pAllocator: *VkAllocationCallbacks, pSetLayout: *VkDescriptorSetLayout) VkResult #extern;
vkDestroyDescriptorSetLayout :: fn (device: VkDevice, descriptorSetLayout: VkDescriptorSetLayout, pAllocator: *VkAllocationCallbacks) #extern;
vkCreateDescriptorPool :: fn (device: VkDevice, pCreateInfo: *VkDescriptorPoolCreateInfo, pAllocator: *VkAllocationCallbacks, pDescriptorPool: *VkDescriptorPool) VkResult #extern;
vkDestroyDescriptorPool :: fn (device: VkDevice, descriptorPool: VkDescriptorPool, pAllocator: *VkAllocationCallbacks) #extern;
vkResetDescriptorPool :: fn (device: VkDevice, descriptorPool: VkDescriptorPool, flags: VkDescriptorPoolResetFlags) VkResult #extern;
vkAllocateDescriptorSets :: fn (device: VkDevice, pAllocateInfo: *VkDescriptorSetAllocateInfo, pDescriptorSets: *VkDescriptorSet) VkResult #extern;
vkFreeDescriptorSets :: fn (device: VkDevice, descriptorPool: VkDescriptorPool, descriptorSetCount: u32, pDescriptorSets: *VkDescriptorSet) VkResult #extern;
vkUpdateDescriptorSets :: fn (device: VkDevice, descriptorWriteCount: u32, pDescriptorWrites: *VkWriteDescriptorSet, descriptorCopyCount: u32, pDescriptorCopies: *VkCopyDescriptorSet) #extern;
vkCreateFramebuffer :: fn (device: VkDevice, pCreateInfo: *VkFramebufferCreateInfo, pAllocator: *VkAllocationCallbacks, pFramebuffer: *VkFramebuffer) VkResult #extern;
vkDestroyFramebuffer :: fn (device: VkDevice, framebuffer: VkFramebuffer, pAllocator: *VkAllocationCallbacks) #extern;
vkCreateRenderPass :: fn (device: VkDevice, pCreateInfo: *VkRenderPassCreateInfo, pAllocator: *VkAllocationCallbacks, pRenderPass: *VkRenderPass) VkResult #extern;
vkDestroyRenderPass :: fn (device: VkDevice, renderPass: VkRenderPass, pAllocator: *VkAllocationCallbacks) #extern;
vkGetRenderAreaGranularity :: fn (device: VkDevice, renderPass: VkRenderPass, pGranularity: *VkExtent2D) #extern;
vkCreateCommandPool :: fn (device: VkDevice, pCreateInfo: *VkCommandPoolCreateInfo, pAllocator: *VkAllocationCallbacks, pCommandPool: *VkCommandPool) VkResult #extern;
vkDestroyCommandPool :: fn (device: VkDevice, commandPool: VkCommandPool, pAllocator: *VkAllocationCallbacks) #extern;
vkResetCommandPool :: fn (device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolResetFlags) VkResult #extern;
vkAllocateCommandBuffers :: fn (device: VkDevice, pAllocateInfo: *VkCommandBufferAllocateInfo, pCommandBuffers: *VkCommandBuffer) VkResult #extern;
vkFreeCommandBuffers :: fn (device: VkDevice, commandPool: VkCommandPool, commandBufferCount: u32, pCommandBuffers: *VkCommandBuffer) #extern;
vkBeginCommandBuffer :: fn (commandBuffer: VkCommandBuffer, pBeginInfo: *VkCommandBufferBeginInfo) VkResult #extern;
vkEndCommandBuffer :: fn (commandBuffer: VkCommandBuffer) VkResult #extern;
vkResetCommandBuffer :: fn (commandBuffer: VkCommandBuffer, flags: VkCommandBufferResetFlags) VkResult #extern;
vkCmdBindPipeline :: fn (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline) #extern;
vkCmdSetViewport :: fn (commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewports: *VkViewport) #extern;
vkCmdSetScissor :: fn (commandBuffer: VkCommandBuffer, firstScissor: u32, scissorCount: u32, pScissors: *VkRect2D) #extern;
vkCmdSetLineWidth :: fn (commandBuffer: VkCommandBuffer, lineWidth: f32) #extern;
vkCmdSetDepthBias :: fn (commandBuffer: VkCommandBuffer, depthBiasConstantFactor: f32, depthBiasClamp: f32, depthBiasSlopeFactor: f32) #extern;
vkCmdSetBlendConstants :: fn (commandBuffer: VkCommandBuffer, blendConstants: [4]f32) #extern;
vkCmdSetDepthBounds :: fn (commandBuffer: VkCommandBuffer, minDepthBounds: f32, maxDepthBounds: f32) #extern;
vkCmdSetStencilCompareMask :: fn (commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, compareMask: u32) #extern;
vkCmdSetStencilWriteMask :: fn (commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, writeMask: u32) #extern;
vkCmdSetStencilReference :: fn (commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, reference: u32) #extern;
vkCmdBindDescriptorSets :: fn (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, firstSet: u32, descriptorSetCount: u32, pDescriptorSets: *VkDescriptorSet, dynamicOffsetCount: u32, pDynamicOffsets: *u32) #extern;
vkCmdBindIndexBuffer :: fn (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, indexType: VkIndexType) #extern;
vkCmdBindVertexBuffers :: fn (commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *VkBuffer, pOffsets: *VkDeviceSize) #extern;
vkCmdDraw :: fn (commandBuffer: VkCommandBuffer, vertexCount: u32, instanceCount: u32, firstVertex: u32, firstInstance: u32) #extern;
vkCmdDrawIndexed :: fn (commandBuffer: VkCommandBuffer, indexCount: u32, instanceCount: u32, firstIndex: u32, vertexOffset: s32, firstInstance: u32) #extern;
vkCmdDrawIndirect :: fn (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32) #extern;
vkCmdDrawIndexedIndirect :: fn (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32) #extern;
vkCmdDispatch :: fn (commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32) #extern;
vkCmdDispatchIndirect :: fn (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize) #extern;
vkCmdCopyBuffer :: fn (commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstBuffer: VkBuffer, regionCount: u32, pRegions: *VkBufferCopy) #extern;
vkCmdCopyImage :: fn (commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *VkImageCopy) #extern;
vkCmdBlitImage :: fn (commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *VkImageBlit, filter: VkFilter) #extern;
vkCmdCopyBufferToImage :: fn (commandBuffer: VkCommandBuffer, srcBuffer: VkBuffer, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *VkBufferImageCopy) #extern;
vkCmdCopyImageToBuffer :: fn (commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstBuffer: VkBuffer, regionCount: u32, pRegions: *VkBufferImageCopy) #extern;
vkCmdUpdateBuffer :: fn (commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, dataSize: VkDeviceSize, pData: C.void_ptr) #extern;
vkCmdFillBuffer :: fn (commandBuffer: VkCommandBuffer, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, size: VkDeviceSize, data: u32) #extern;
vkCmdClearColorImage :: fn (commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pColor: *VkClearColorValue, rangeCount: u32, pRanges: *VkImageSubresourceRange) #extern;
vkCmdClearDepthStencilImage :: fn (commandBuffer: VkCommandBuffer, image: VkImage, imageLayout: VkImageLayout, pDepthStencil: *VkClearDepthStencilValue, rangeCount: u32, pRanges: *VkImageSubresourceRange) #extern;
vkCmdClearAttachments :: fn (commandBuffer: VkCommandBuffer, attachmentCount: u32, pAttachments: *VkClearAttachment, rectCount: u32, pRects: *VkClearRect) #extern;
vkCmdResolveImage :: fn (commandBuffer: VkCommandBuffer, srcImage: VkImage, srcImageLayout: VkImageLayout, dstImage: VkImage, dstImageLayout: VkImageLayout, regionCount: u32, pRegions: *VkImageResolve) #extern;
vkCmdSetEvent :: fn (commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags) #extern;
vkCmdResetEvent :: fn (commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags) #extern;
vkCmdWaitEvents :: fn (commandBuffer: VkCommandBuffer, eventCount: u32, pEvents: *VkEvent, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, memoryBarrierCount: u32, pMemoryBarriers: *VkMemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *VkBufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *VkImageMemoryBarrier) #extern;
vkCmdPipelineBarrier :: fn (commandBuffer: VkCommandBuffer, srcStageMask: VkPipelineStageFlags, dstStageMask: VkPipelineStageFlags, dependencyFlags: VkDependencyFlags, memoryBarrierCount: u32, pMemoryBarriers: *VkMemoryBarrier, bufferMemoryBarrierCount: u32, pBufferMemoryBarriers: *VkBufferMemoryBarrier, imageMemoryBarrierCount: u32, pImageMemoryBarriers: *VkImageMemoryBarrier) #extern;
vkCmdBeginQuery :: fn (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32, flags: VkQueryControlFlags) #extern;
vkCmdEndQuery :: fn (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32) #extern;
vkCmdResetQueryPool :: fn (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32) #extern;
vkCmdWriteTimestamp :: fn (commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, queryPool: VkQueryPool, query: u32) #extern;
vkCmdCopyQueryPoolResults :: fn (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, stride: VkDeviceSize, flags: VkQueryResultFlags) #extern;
vkCmdPushConstants :: fn (commandBuffer: VkCommandBuffer, layout: VkPipelineLayout, stageFlags: VkShaderStageFlags, offset: u32, size: u32, pValues: C.void_ptr) #extern;
vkCmdBeginRenderPass :: fn (commandBuffer: VkCommandBuffer, pRenderPassBegin: *VkRenderPassBeginInfo, contents: VkSubpassContents) #extern;
vkCmdNextSubpass :: fn (commandBuffer: VkCommandBuffer, contents: VkSubpassContents) #extern;
vkCmdEndRenderPass :: fn (commandBuffer: VkCommandBuffer) #extern;
vkCmdExecuteCommands :: fn (commandBuffer: VkCommandBuffer, commandBufferCount: u32, pCommandBuffers: *VkCommandBuffer) #extern;
VkPointClippingBehavior :: enum s32 {
	VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES = 0x0;
	VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY = 0x1;
	VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR = 0x0;
	VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR = 0x1;
	VK_POINT_CLIPPING_BEHAVIOR_MAX_ENUM = 0x7fffffff;
}
VkTessellationDomainOrigin :: enum s32 {
	VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT = 0x0;
	VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT = 0x1;
	VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR = 0x0;
	VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR = 0x1;
	VK_TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM = 0x7fffffff;
}
VkSamplerYcbcrModelConversion :: enum s32 {
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY = 0x0;
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY = 0x1;
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 = 0x2;
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 = 0x3;
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 = 0x4;
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR = 0x0;
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR = 0x1;
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR = 0x2;
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR = 0x3;
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR = 0x4;
	VK_SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM = 0x7fffffff;
}
VkSamplerYcbcrRange :: enum s32 {
	VK_SAMPLER_YCBCR_RANGE_ITU_FULL = 0x0;
	VK_SAMPLER_YCBCR_RANGE_ITU_NARROW = 0x1;
	VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR = 0x0;
	VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR = 0x1;
	VK_SAMPLER_YCBCR_RANGE_MAX_ENUM = 0x7fffffff;
}
VkChromaLocation :: enum s32 {
	VK_CHROMA_LOCATION_COSITED_EVEN = 0x0;
	VK_CHROMA_LOCATION_MIDPOINT = 0x1;
	VK_CHROMA_LOCATION_COSITED_EVEN_KHR = 0x0;
	VK_CHROMA_LOCATION_MIDPOINT_KHR = 0x1;
	VK_CHROMA_LOCATION_MAX_ENUM = 0x7fffffff;
}
VkDescriptorUpdateTemplateType :: enum s32 {
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = 0x0;
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = 0x1;
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR = 0x0;
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM = 0x7fffffff;
}
VkSubgroupFeatureFlagBits :: enum u32 #flags {
	VK_SUBGROUP_FEATURE_BASIC_BIT = 0x1;
	VK_SUBGROUP_FEATURE_VOTE_BIT = 0x2;
	VK_SUBGROUP_FEATURE_ARITHMETIC_BIT = 0x4;
	VK_SUBGROUP_FEATURE_BALLOT_BIT = 0x8;
	VK_SUBGROUP_FEATURE_SHUFFLE_BIT = 0x10;
	VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT = 0x20;
	VK_SUBGROUP_FEATURE_CLUSTERED_BIT = 0x40;
	VK_SUBGROUP_FEATURE_QUAD_BIT = 0x80;
	VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV = 0x100;
	VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkSubgroupFeatureFlags :: VkFlags;
VkPeerMemoryFeatureFlagBits :: enum u32 #flags {
	VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT = 0x1;
	VK_PEER_MEMORY_FEATURE_COPY_DST_BIT = 0x2;
	VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT = 0x4;
	VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT = 0x8;
	VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR = 0x1;
	VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR = 0x2;
	VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR = 0x4;
	VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR = 0x8;
	VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkPeerMemoryFeatureFlags :: VkFlags;
VkMemoryAllocateFlagBits :: enum u32 #flags {
	VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT = 0x1;
	VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT = 0x2;
	VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 0x4;
	VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR = 0x1;
	VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR = 0x2;
	VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = 0x4;
	VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkMemoryAllocateFlags :: VkFlags;
VkCommandPoolTrimFlags :: VkFlags;
VkDescriptorUpdateTemplateCreateFlags :: VkFlags;
VkExternalMemoryHandleTypeFlagBits :: enum u32 #flags {
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT = 0x1;
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x2;
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x4;
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT = 0x8;
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT = 0x10;
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT = 0x20;
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = 0x40;
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT = 0x200;
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID = 0x400;
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT = 0x80;
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = 0x100;
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA = 0x800;
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV = 0x1000;
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = 0x1;
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = 0x2;
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = 0x4;
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR = 0x8;
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR = 0x10;
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR = 0x20;
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR = 0x40;
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkExternalMemoryHandleTypeFlags :: VkFlags;
VkExternalMemoryFeatureFlagBits :: enum u32 #flags {
	VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT = 0x1;
	VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT = 0x2;
	VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT = 0x4;
	VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR = 0x1;
	VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR = 0x2;
	VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR = 0x4;
	VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkExternalMemoryFeatureFlags :: VkFlags;
VkExternalFenceHandleTypeFlagBits :: enum u32 #flags {
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x1;
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x2;
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x4;
	VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x8;
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = 0x1;
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = 0x2;
	VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = 0x4;
	VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR = 0x8;
	VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkExternalFenceHandleTypeFlags :: VkFlags;
VkExternalFenceFeatureFlagBits :: enum u32 #flags {
	VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT = 0x1;
	VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT = 0x2;
	VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR = 0x1;
	VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR = 0x2;
	VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkExternalFenceFeatureFlags :: VkFlags;
VkFenceImportFlagBits :: enum u32 #flags {
	VK_FENCE_IMPORT_TEMPORARY_BIT = 0x1;
	VK_FENCE_IMPORT_TEMPORARY_BIT_KHR = 0x1;
	VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkFenceImportFlags :: VkFlags;
VkSemaphoreImportFlagBits :: enum u32 #flags {
	VK_SEMAPHORE_IMPORT_TEMPORARY_BIT = 0x1;
	VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR = 0x1;
	VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkSemaphoreImportFlags :: VkFlags;
VkExternalSemaphoreHandleTypeFlagBits :: enum u32 #flags {
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x1;
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x2;
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x4;
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT = 0x8;
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x10;
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA = 0x80;
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT = 0x8;
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = 0x1;
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = 0x2;
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = 0x4;
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR = 0x8;
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR = 0x10;
	VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkExternalSemaphoreHandleTypeFlags :: VkFlags;
VkExternalSemaphoreFeatureFlagBits :: enum u32 #flags {
	VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT = 0x1;
	VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT = 0x2;
	VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR = 0x1;
	VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR = 0x2;
	VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkExternalSemaphoreFeatureFlags :: VkFlags;
VkPhysicalDeviceSubgroupProperties :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	subgroupSize: u32;
	supportedStages: VkShaderStageFlags;
	supportedOperations: VkSubgroupFeatureFlags;
	quadOperationsInAllStages: VkBool32;
}
VkBindBufferMemoryInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	buffer: VkBuffer;
	memory: VkDeviceMemory;
	memoryOffset: VkDeviceSize;
}
VkBindImageMemoryInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	image: VkImage;
	memory: VkDeviceMemory;
	memoryOffset: VkDeviceSize;
}
VkPhysicalDevice16BitStorageFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	storageBuffer16BitAccess: VkBool32;
	uniformAndStorageBuffer16BitAccess: VkBool32;
	storagePushConstant16: VkBool32;
	storageInputOutput16: VkBool32;
}
VkMemoryDedicatedRequirements :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	prefersDedicatedAllocation: VkBool32;
	requiresDedicatedAllocation: VkBool32;
}
VkMemoryDedicatedAllocateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	image: VkImage;
	buffer: VkBuffer;
}
VkMemoryAllocateFlagsInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkMemoryAllocateFlags;
	deviceMask: u32;
}
VkDeviceGroupRenderPassBeginInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	deviceMask: u32;
	deviceRenderAreaCount: u32;
	pDeviceRenderAreas: *VkRect2D;
}
VkDeviceGroupCommandBufferBeginInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	deviceMask: u32;
}
VkDeviceGroupSubmitInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	waitSemaphoreCount: u32;
	pWaitSemaphoreDeviceIndices: *u32;
	commandBufferCount: u32;
	pCommandBufferDeviceMasks: *u32;
	signalSemaphoreCount: u32;
	pSignalSemaphoreDeviceIndices: *u32;
}
VkDeviceGroupBindSparseInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	resourceDeviceIndex: u32;
	memoryDeviceIndex: u32;
}
VkBindBufferMemoryDeviceGroupInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	deviceIndexCount: u32;
	pDeviceIndices: *u32;
}
VkBindImageMemoryDeviceGroupInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	deviceIndexCount: u32;
	pDeviceIndices: *u32;
	splitInstanceBindRegionCount: u32;
	pSplitInstanceBindRegions: *VkRect2D;
}
VkPhysicalDeviceGroupProperties :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	physicalDeviceCount: u32;
	physicalDevices: [32]VkPhysicalDevice;
	subsetAllocation: VkBool32;
}
VkDeviceGroupDeviceCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	physicalDeviceCount: u32;
	pPhysicalDevices: *VkPhysicalDevice;
}
VkBufferMemoryRequirementsInfo2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	buffer: VkBuffer;
}
VkImageMemoryRequirementsInfo2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	image: VkImage;
}
VkImageSparseMemoryRequirementsInfo2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	image: VkImage;
}
VkMemoryRequirements2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	memoryRequirements: VkMemoryRequirements;
}
VkSparseImageMemoryRequirements2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	memoryRequirements: VkSparseImageMemoryRequirements;
}
VkPhysicalDeviceFeatures2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	features: VkPhysicalDeviceFeatures;
}
VkPhysicalDeviceProperties2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	properties: VkPhysicalDeviceProperties;
}
VkFormatProperties2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	formatProperties: VkFormatProperties;
}
VkImageFormatProperties2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	imageFormatProperties: VkImageFormatProperties;
}
VkPhysicalDeviceImageFormatInfo2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	format: VkFormat;
	t: VkImageType;
	tiling: VkImageTiling;
	usage: VkImageUsageFlags;
	flags: VkImageCreateFlags;
}
VkQueueFamilyProperties2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	queueFamilyProperties: VkQueueFamilyProperties;
}
VkPhysicalDeviceMemoryProperties2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	memoryProperties: VkPhysicalDeviceMemoryProperties;
}
VkSparseImageFormatProperties2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	properties: VkSparseImageFormatProperties;
}
VkPhysicalDeviceSparseImageFormatInfo2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	format: VkFormat;
	t: VkImageType;
	samples: VkSampleCountFlagBits;
	usage: VkImageUsageFlags;
	tiling: VkImageTiling;
}
VkPhysicalDevicePointClippingProperties :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	pointClippingBehavior: VkPointClippingBehavior;
}
VkInputAttachmentAspectReference :: struct {
	subpass: u32;
	inputAttachmentIndex: u32;
	aspectMask: VkImageAspectFlags;
}
VkRenderPassInputAttachmentAspectCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	aspectReferenceCount: u32;
	pAspectReferences: *VkInputAttachmentAspectReference;
}
VkImageViewUsageCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	usage: VkImageUsageFlags;
}
VkPipelineTessellationDomainOriginStateCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	domainOrigin: VkTessellationDomainOrigin;
}
VkRenderPassMultiviewCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	subpassCount: u32;
	pViewMasks: *u32;
	dependencyCount: u32;
	pViewOffsets: *s32;
	correlationMaskCount: u32;
	pCorrelationMasks: *u32;
}
VkPhysicalDeviceMultiviewFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	multiview: VkBool32;
	multiviewGeometryShader: VkBool32;
	multiviewTessellationShader: VkBool32;
}
VkPhysicalDeviceMultiviewProperties :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	maxMultiviewViewCount: u32;
	maxMultiviewInstanceIndex: u32;
}
VkPhysicalDeviceVariablePointersFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	variablePointersStorageBuffer: VkBool32;
	variablePointers: VkBool32;
}
VkPhysicalDeviceVariablePointerFeatures :: VkPhysicalDeviceVariablePointersFeatures;
VkPhysicalDeviceProtectedMemoryFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	protectedMemory: VkBool32;
}
VkPhysicalDeviceProtectedMemoryProperties :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	protectedNoFault: VkBool32;
}
VkDeviceQueueInfo2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkDeviceQueueCreateFlags;
	queueFamilyIndex: u32;
	queueIndex: u32;
}
VkProtectedSubmitInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	protectedSubmit: VkBool32;
}
VkSamplerYcbcrConversionCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	format: VkFormat;
	ycbcrModel: VkSamplerYcbcrModelConversion;
	ycbcrRange: VkSamplerYcbcrRange;
	components: VkComponentMapping;
	xChromaOffset: VkChromaLocation;
	yChromaOffset: VkChromaLocation;
	chromaFilter: VkFilter;
	forceExplicitReconstruction: VkBool32;
}
VkSamplerYcbcrConversionInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	conversion: VkSamplerYcbcrConversion;
}
VkBindImagePlaneMemoryInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	planeAspect: VkImageAspectFlagBits;
}
VkImagePlaneMemoryRequirementsInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	planeAspect: VkImageAspectFlagBits;
}
VkPhysicalDeviceSamplerYcbcrConversionFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	samplerYcbcrConversion: VkBool32;
}
VkSamplerYcbcrConversionImageFormatProperties :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	combinedImageSamplerDescriptorCount: u32;
}
VkDescriptorUpdateTemplateEntry :: struct {
	dstBinding: u32;
	dstArrayElement: u32;
	descriptorCount: u32;
	descriptorType: VkDescriptorType;
	offset: usize;
	stride: usize;
}
VkDescriptorUpdateTemplateCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkDescriptorUpdateTemplateCreateFlags;
	descriptorUpdateEntryCount: u32;
	pDescriptorUpdateEntries: *VkDescriptorUpdateTemplateEntry;
	templateType: VkDescriptorUpdateTemplateType;
	descriptorSetLayout: VkDescriptorSetLayout;
	pipelineBindPoint: VkPipelineBindPoint;
	pipelineLayout: VkPipelineLayout;
	set: u32;
}
VkExternalMemoryProperties :: struct {
	externalMemoryFeatures: VkExternalMemoryFeatureFlags;
	exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlags;
	compatibleHandleTypes: VkExternalMemoryHandleTypeFlags;
}
VkPhysicalDeviceExternalImageFormatInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	handleType: VkExternalMemoryHandleTypeFlagBits;
}
VkExternalImageFormatProperties :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	externalMemoryProperties: VkExternalMemoryProperties;
}
VkPhysicalDeviceExternalBufferInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkBufferCreateFlags;
	usage: VkBufferUsageFlags;
	handleType: VkExternalMemoryHandleTypeFlagBits;
}
VkExternalBufferProperties :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	externalMemoryProperties: VkExternalMemoryProperties;
}
VkPhysicalDeviceIDProperties :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	deviceUUID: [16]u8;
	driverUUID: [16]u8;
	deviceLUID: [8]u8;
	deviceNodeMask: u32;
	deviceLUIDValid: VkBool32;
}
VkExternalMemoryImageCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	handleTypes: VkExternalMemoryHandleTypeFlags;
}
VkExternalMemoryBufferCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	handleTypes: VkExternalMemoryHandleTypeFlags;
}
VkExportMemoryAllocateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	handleTypes: VkExternalMemoryHandleTypeFlags;
}
VkPhysicalDeviceExternalFenceInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	handleType: VkExternalFenceHandleTypeFlagBits;
}
VkExternalFenceProperties :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	exportFromImportedHandleTypes: VkExternalFenceHandleTypeFlags;
	compatibleHandleTypes: VkExternalFenceHandleTypeFlags;
	externalFenceFeatures: VkExternalFenceFeatureFlags;
}
VkExportFenceCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	handleTypes: VkExternalFenceHandleTypeFlags;
}
VkExportSemaphoreCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	handleTypes: VkExternalSemaphoreHandleTypeFlags;
}
VkPhysicalDeviceExternalSemaphoreInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	handleType: VkExternalSemaphoreHandleTypeFlagBits;
}
VkExternalSemaphoreProperties :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	exportFromImportedHandleTypes: VkExternalSemaphoreHandleTypeFlags;
	compatibleHandleTypes: VkExternalSemaphoreHandleTypeFlags;
	externalSemaphoreFeatures: VkExternalSemaphoreFeatureFlags;
}
VkPhysicalDeviceMaintenance3Properties :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	maxPerSetDescriptors: u32;
	maxMemoryAllocationSize: VkDeviceSize;
}
VkDescriptorSetLayoutSupport :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	supported: VkBool32;
}
VkPhysicalDeviceShaderDrawParametersFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shaderDrawParameters: VkBool32;
}
VkPhysicalDeviceShaderDrawParameterFeatures :: VkPhysicalDeviceShaderDrawParametersFeatures;
PFN_vkEnumerateInstanceVersion :: *fn (*u32) VkResult;
PFN_vkBindBufferMemory2 :: *fn (VkDevice, u32, *VkBindBufferMemoryInfo) VkResult;
PFN_vkBindImageMemory2 :: *fn (VkDevice, u32, *VkBindImageMemoryInfo) VkResult;
PFN_vkGetDeviceGroupPeerMemoryFeatures :: *fn (VkDevice, u32, u32, u32, *VkPeerMemoryFeatureFlags);
PFN_vkCmdSetDeviceMask :: *fn (VkCommandBuffer, u32);
PFN_vkCmdDispatchBase :: *fn (VkCommandBuffer, u32, u32, u32, u32, u32, u32);
PFN_vkEnumeratePhysicalDeviceGroups :: *fn (VkInstance, *u32, *VkPhysicalDeviceGroupProperties) VkResult;
PFN_vkGetImageMemoryRequirements2 :: *fn (VkDevice, *VkImageMemoryRequirementsInfo2, *VkMemoryRequirements2);
PFN_vkGetBufferMemoryRequirements2 :: *fn (VkDevice, *VkBufferMemoryRequirementsInfo2, *VkMemoryRequirements2);
PFN_vkGetImageSparseMemoryRequirements2 :: *fn (VkDevice, *VkImageSparseMemoryRequirementsInfo2, *u32, *VkSparseImageMemoryRequirements2);
PFN_vkGetPhysicalDeviceFeatures2 :: *fn (VkPhysicalDevice, *VkPhysicalDeviceFeatures2);
PFN_vkGetPhysicalDeviceProperties2 :: *fn (VkPhysicalDevice, *VkPhysicalDeviceProperties2);
PFN_vkGetPhysicalDeviceFormatProperties2 :: *fn (VkPhysicalDevice, VkFormat, *VkFormatProperties2);
PFN_vkGetPhysicalDeviceImageFormatProperties2 :: *fn (VkPhysicalDevice, *VkPhysicalDeviceImageFormatInfo2, *VkImageFormatProperties2) VkResult;
PFN_vkGetPhysicalDeviceQueueFamilyProperties2 :: *fn (VkPhysicalDevice, *u32, *VkQueueFamilyProperties2);
PFN_vkGetPhysicalDeviceMemoryProperties2 :: *fn (VkPhysicalDevice, *VkPhysicalDeviceMemoryProperties2);
PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 :: *fn (VkPhysicalDevice, *VkPhysicalDeviceSparseImageFormatInfo2, *u32, *VkSparseImageFormatProperties2);
PFN_vkTrimCommandPool :: *fn (VkDevice, VkCommandPool, VkCommandPoolTrimFlags);
PFN_vkGetDeviceQueue2 :: *fn (VkDevice, *VkDeviceQueueInfo2, *VkQueue);
PFN_vkCreateSamplerYcbcrConversion :: *fn (VkDevice, *VkSamplerYcbcrConversionCreateInfo, *VkAllocationCallbacks, *VkSamplerYcbcrConversion) VkResult;
PFN_vkDestroySamplerYcbcrConversion :: *fn (VkDevice, VkSamplerYcbcrConversion, *VkAllocationCallbacks);
PFN_vkCreateDescriptorUpdateTemplate :: *fn (VkDevice, *VkDescriptorUpdateTemplateCreateInfo, *VkAllocationCallbacks, *VkDescriptorUpdateTemplate) VkResult;
PFN_vkDestroyDescriptorUpdateTemplate :: *fn (VkDevice, VkDescriptorUpdateTemplate, *VkAllocationCallbacks);
PFN_vkUpdateDescriptorSetWithTemplate :: *fn (VkDevice, VkDescriptorSet, VkDescriptorUpdateTemplate, C.void_ptr);
PFN_vkGetPhysicalDeviceExternalBufferProperties :: *fn (VkPhysicalDevice, *VkPhysicalDeviceExternalBufferInfo, *VkExternalBufferProperties);
PFN_vkGetPhysicalDeviceExternalFenceProperties :: *fn (VkPhysicalDevice, *VkPhysicalDeviceExternalFenceInfo, *VkExternalFenceProperties);
PFN_vkGetPhysicalDeviceExternalSemaphoreProperties :: *fn (VkPhysicalDevice, *VkPhysicalDeviceExternalSemaphoreInfo, *VkExternalSemaphoreProperties);
PFN_vkGetDescriptorSetLayoutSupport :: *fn (VkDevice, *VkDescriptorSetLayoutCreateInfo, *VkDescriptorSetLayoutSupport);
vkEnumerateInstanceVersion :: fn (pApiVersion: *u32) VkResult #extern;
vkBindBufferMemory2 :: fn (device: VkDevice, bindInfoCount: u32, pBindInfos: *VkBindBufferMemoryInfo) VkResult #extern;
vkBindImageMemory2 :: fn (device: VkDevice, bindInfoCount: u32, pBindInfos: *VkBindImageMemoryInfo) VkResult #extern;
vkGetDeviceGroupPeerMemoryFeatures :: fn (device: VkDevice, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32, pPeerMemoryFeatures: *VkPeerMemoryFeatureFlags) #extern;
vkCmdSetDeviceMask :: fn (commandBuffer: VkCommandBuffer, deviceMask: u32) #extern;
vkCmdDispatchBase :: fn (commandBuffer: VkCommandBuffer, baseGroupX: u32, baseGroupY: u32, baseGroupZ: u32, groupCountX: u32, groupCountY: u32, groupCountZ: u32) #extern;
vkEnumeratePhysicalDeviceGroups :: fn (instance: VkInstance, pPhysicalDeviceGroupCount: *u32, pPhysicalDeviceGroupProperties: *VkPhysicalDeviceGroupProperties) VkResult #extern;
vkGetImageMemoryRequirements2 :: fn (device: VkDevice, pInfo: *VkImageMemoryRequirementsInfo2, pMemoryRequirements: *VkMemoryRequirements2) #extern;
vkGetBufferMemoryRequirements2 :: fn (device: VkDevice, pInfo: *VkBufferMemoryRequirementsInfo2, pMemoryRequirements: *VkMemoryRequirements2) #extern;
vkGetImageSparseMemoryRequirements2 :: fn (device: VkDevice, pInfo: *VkImageSparseMemoryRequirementsInfo2, pSparseMemoryRequirementCount: *u32, pSparseMemoryRequirements: *VkSparseImageMemoryRequirements2) #extern;
vkGetPhysicalDeviceFeatures2 :: fn (physicalDevice: VkPhysicalDevice, pFeatures: *VkPhysicalDeviceFeatures2) #extern;
vkGetPhysicalDeviceProperties2 :: fn (physicalDevice: VkPhysicalDevice, pProperties: *VkPhysicalDeviceProperties2) #extern;
vkGetPhysicalDeviceFormatProperties2 :: fn (physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *VkFormatProperties2) #extern;
vkGetPhysicalDeviceImageFormatProperties2 :: fn (physicalDevice: VkPhysicalDevice, pImageFormatInfo: *VkPhysicalDeviceImageFormatInfo2, pImageFormatProperties: *VkImageFormatProperties2) VkResult #extern;
vkGetPhysicalDeviceQueueFamilyProperties2 :: fn (physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *u32, pQueueFamilyProperties: *VkQueueFamilyProperties2) #extern;
vkGetPhysicalDeviceMemoryProperties2 :: fn (physicalDevice: VkPhysicalDevice, pMemoryProperties: *VkPhysicalDeviceMemoryProperties2) #extern;
vkGetPhysicalDeviceSparseImageFormatProperties2 :: fn (physicalDevice: VkPhysicalDevice, pFormatInfo: *VkPhysicalDeviceSparseImageFormatInfo2, pPropertyCount: *u32, pProperties: *VkSparseImageFormatProperties2) #extern;
vkTrimCommandPool :: fn (device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolTrimFlags) #extern;
vkGetDeviceQueue2 :: fn (device: VkDevice, pQueueInfo: *VkDeviceQueueInfo2, pQueue: *VkQueue) #extern;
vkCreateSamplerYcbcrConversion :: fn (device: VkDevice, pCreateInfo: *VkSamplerYcbcrConversionCreateInfo, pAllocator: *VkAllocationCallbacks, pYcbcrConversion: *VkSamplerYcbcrConversion) VkResult #extern;
vkDestroySamplerYcbcrConversion :: fn (device: VkDevice, ycbcrConversion: VkSamplerYcbcrConversion, pAllocator: *VkAllocationCallbacks) #extern;
vkCreateDescriptorUpdateTemplate :: fn (device: VkDevice, pCreateInfo: *VkDescriptorUpdateTemplateCreateInfo, pAllocator: *VkAllocationCallbacks, pDescriptorUpdateTemplate: *VkDescriptorUpdateTemplate) VkResult #extern;
vkDestroyDescriptorUpdateTemplate :: fn (device: VkDevice, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pAllocator: *VkAllocationCallbacks) #extern;
vkUpdateDescriptorSetWithTemplate :: fn (device: VkDevice, descriptorSet: VkDescriptorSet, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pData: C.void_ptr) #extern;
vkGetPhysicalDeviceExternalBufferProperties :: fn (physicalDevice: VkPhysicalDevice, pExternalBufferInfo: *VkPhysicalDeviceExternalBufferInfo, pExternalBufferProperties: *VkExternalBufferProperties) #extern;
vkGetPhysicalDeviceExternalFenceProperties :: fn (physicalDevice: VkPhysicalDevice, pExternalFenceInfo: *VkPhysicalDeviceExternalFenceInfo, pExternalFenceProperties: *VkExternalFenceProperties) #extern;
vkGetPhysicalDeviceExternalSemaphoreProperties :: fn (physicalDevice: VkPhysicalDevice, pExternalSemaphoreInfo: *VkPhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: *VkExternalSemaphoreProperties) #extern;
vkGetDescriptorSetLayoutSupport :: fn (device: VkDevice, pCreateInfo: *VkDescriptorSetLayoutCreateInfo, pSupport: *VkDescriptorSetLayoutSupport) #extern;
VkDriverId :: enum s32 {
	VK_DRIVER_ID_AMD_PROPRIETARY = 0x1;
	VK_DRIVER_ID_AMD_OPEN_SOURCE = 0x2;
	VK_DRIVER_ID_MESA_RADV = 0x3;
	VK_DRIVER_ID_NVIDIA_PROPRIETARY = 0x4;
	VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS = 0x5;
	VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA = 0x6;
	VK_DRIVER_ID_IMAGINATION_PROPRIETARY = 0x7;
	VK_DRIVER_ID_QUALCOMM_PROPRIETARY = 0x8;
	VK_DRIVER_ID_ARM_PROPRIETARY = 0x9;
	VK_DRIVER_ID_GOOGLE_SWIFTSHADER = 0xa;
	VK_DRIVER_ID_GGP_PROPRIETARY = 0xb;
	VK_DRIVER_ID_BROADCOM_PROPRIETARY = 0xc;
	VK_DRIVER_ID_MESA_LLVMPIPE = 0xd;
	VK_DRIVER_ID_MOLTENVK = 0xe;
	VK_DRIVER_ID_COREAVI_PROPRIETARY = 0xf;
	VK_DRIVER_ID_JUICE_PROPRIETARY = 0x10;
	VK_DRIVER_ID_VERISILICON_PROPRIETARY = 0x11;
	VK_DRIVER_ID_MESA_TURNIP = 0x12;
	VK_DRIVER_ID_MESA_V3DV = 0x13;
	VK_DRIVER_ID_MESA_PANVK = 0x14;
	VK_DRIVER_ID_SAMSUNG_PROPRIETARY = 0x15;
	VK_DRIVER_ID_MESA_VENUS = 0x16;
	VK_DRIVER_ID_MESA_DOZEN = 0x17;
	VK_DRIVER_ID_AMD_PROPRIETARY_KHR = 0x1;
	VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR = 0x2;
	VK_DRIVER_ID_MESA_RADV_KHR = 0x3;
	VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR = 0x4;
	VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR = 0x5;
	VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR = 0x6;
	VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR = 0x7;
	VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR = 0x8;
	VK_DRIVER_ID_ARM_PROPRIETARY_KHR = 0x9;
	VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR = 0xa;
	VK_DRIVER_ID_GGP_PROPRIETARY_KHR = 0xb;
	VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR = 0xc;
	VK_DRIVER_ID_MAX_ENUM = 0x7fffffff;
}
VkShaderFloatControlsIndependence :: enum s32 {
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY = 0x0;
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL = 0x1;
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE = 0x2;
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR = 0x0;
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR = 0x1;
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR = 0x2;
	VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_MAX_ENUM = 0x7fffffff;
}
VkSamplerReductionMode :: enum s32 {
	VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE = 0x0;
	VK_SAMPLER_REDUCTION_MODE_MIN = 0x1;
	VK_SAMPLER_REDUCTION_MODE_MAX = 0x2;
	VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT = 0x0;
	VK_SAMPLER_REDUCTION_MODE_MIN_EXT = 0x1;
	VK_SAMPLER_REDUCTION_MODE_MAX_EXT = 0x2;
	VK_SAMPLER_REDUCTION_MODE_MAX_ENUM = 0x7fffffff;
}
VkSemaphoreType :: enum s32 {
	VK_SEMAPHORE_TYPE_BINARY = 0x0;
	VK_SEMAPHORE_TYPE_TIMELINE = 0x1;
	VK_SEMAPHORE_TYPE_BINARY_KHR = 0x0;
	VK_SEMAPHORE_TYPE_TIMELINE_KHR = 0x1;
	VK_SEMAPHORE_TYPE_MAX_ENUM = 0x7fffffff;
}
VkResolveModeFlagBits :: enum u32 #flags {
	VK_RESOLVE_MODE_NONE = 0x0;
	VK_RESOLVE_MODE_SAMPLE_ZERO_BIT = 0x1;
	VK_RESOLVE_MODE_AVERAGE_BIT = 0x2;
	VK_RESOLVE_MODE_MIN_BIT = 0x4;
	VK_RESOLVE_MODE_MAX_BIT = 0x8;
	VK_RESOLVE_MODE_NONE_KHR = 0x0;
	VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR = 0x1;
	VK_RESOLVE_MODE_AVERAGE_BIT_KHR = 0x2;
	VK_RESOLVE_MODE_MIN_BIT_KHR = 0x4;
	VK_RESOLVE_MODE_MAX_BIT_KHR = 0x8;
	VK_RESOLVE_MODE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkResolveModeFlags :: VkFlags;
VkDescriptorBindingFlagBits :: enum u32 #flags {
	VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT = 0x1;
	VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT = 0x2;
	VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT = 0x4;
	VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT = 0x8;
	VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT = 0x1;
	VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT = 0x2;
	VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT = 0x4;
	VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT = 0x8;
	VK_DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkDescriptorBindingFlags :: VkFlags;
VkSemaphoreWaitFlagBits :: enum u32 #flags {
	VK_SEMAPHORE_WAIT_ANY_BIT = 0x1;
	VK_SEMAPHORE_WAIT_ANY_BIT_KHR = 0x1;
	VK_SEMAPHORE_WAIT_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkSemaphoreWaitFlags :: VkFlags;
VkPhysicalDeviceVulkan11Features :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	storageBuffer16BitAccess: VkBool32;
	uniformAndStorageBuffer16BitAccess: VkBool32;
	storagePushConstant16: VkBool32;
	storageInputOutput16: VkBool32;
	multiview: VkBool32;
	multiviewGeometryShader: VkBool32;
	multiviewTessellationShader: VkBool32;
	variablePointersStorageBuffer: VkBool32;
	variablePointers: VkBool32;
	protectedMemory: VkBool32;
	samplerYcbcrConversion: VkBool32;
	shaderDrawParameters: VkBool32;
}
VkPhysicalDeviceVulkan11Properties :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	deviceUUID: [16]u8;
	driverUUID: [16]u8;
	deviceLUID: [8]u8;
	deviceNodeMask: u32;
	deviceLUIDValid: VkBool32;
	subgroupSize: u32;
	subgroupSupportedStages: VkShaderStageFlags;
	subgroupSupportedOperations: VkSubgroupFeatureFlags;
	subgroupQuadOperationsInAllStages: VkBool32;
	pointClippingBehavior: VkPointClippingBehavior;
	maxMultiviewViewCount: u32;
	maxMultiviewInstanceIndex: u32;
	protectedNoFault: VkBool32;
	maxPerSetDescriptors: u32;
	maxMemoryAllocationSize: VkDeviceSize;
}
VkPhysicalDeviceVulkan12Features :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	samplerMirrorClampToEdge: VkBool32;
	drawIndirectCount: VkBool32;
	storageBuffer8BitAccess: VkBool32;
	uniformAndStorageBuffer8BitAccess: VkBool32;
	storagePushConstant8: VkBool32;
	shaderBufferInt64Atomics: VkBool32;
	shaderSharedInt64Atomics: VkBool32;
	shaderFloat16: VkBool32;
	shaderInt8: VkBool32;
	descriptorIndexing: VkBool32;
	shaderInputAttachmentArrayDynamicIndexing: VkBool32;
	shaderUniformTexelBufferArrayDynamicIndexing: VkBool32;
	shaderStorageTexelBufferArrayDynamicIndexing: VkBool32;
	shaderUniformBufferArrayNonUniformIndexing: VkBool32;
	shaderSampledImageArrayNonUniformIndexing: VkBool32;
	shaderStorageBufferArrayNonUniformIndexing: VkBool32;
	shaderStorageImageArrayNonUniformIndexing: VkBool32;
	shaderInputAttachmentArrayNonUniformIndexing: VkBool32;
	shaderUniformTexelBufferArrayNonUniformIndexing: VkBool32;
	shaderStorageTexelBufferArrayNonUniformIndexing: VkBool32;
	descriptorBindingUniformBufferUpdateAfterBind: VkBool32;
	descriptorBindingSampledImageUpdateAfterBind: VkBool32;
	descriptorBindingStorageImageUpdateAfterBind: VkBool32;
	descriptorBindingStorageBufferUpdateAfterBind: VkBool32;
	descriptorBindingUniformTexelBufferUpdateAfterBind: VkBool32;
	descriptorBindingStorageTexelBufferUpdateAfterBind: VkBool32;
	descriptorBindingUpdateUnusedWhilePending: VkBool32;
	descriptorBindingPartiallyBound: VkBool32;
	descriptorBindingVariableDescriptorCount: VkBool32;
	runtimeDescriptorArray: VkBool32;
	samplerFilterMinmax: VkBool32;
	scalarBlockLayout: VkBool32;
	imagelessFramebuffer: VkBool32;
	uniformBufferStandardLayout: VkBool32;
	shaderSubgroupExtendedTypes: VkBool32;
	separateDepthStencilLayouts: VkBool32;
	hostQueryReset: VkBool32;
	timelineSemaphore: VkBool32;
	bufferDeviceAddress: VkBool32;
	bufferDeviceAddressCaptureReplay: VkBool32;
	bufferDeviceAddressMultiDevice: VkBool32;
	vulkanMemoryModel: VkBool32;
	vulkanMemoryModelDeviceScope: VkBool32;
	vulkanMemoryModelAvailabilityVisibilityChains: VkBool32;
	shaderOutputViewportIndex: VkBool32;
	shaderOutputLayer: VkBool32;
	subgroupBroadcastDynamicId: VkBool32;
}
VkConformanceVersion :: struct {
	major: u8;
	minor: u8;
	subminor: u8;
	patch: u8;
}
VkPhysicalDeviceVulkan12Properties :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	driverID: VkDriverId;
	driverName: [256]C.char;
	driverInfo: [256]C.char;
	conformanceVersion: VkConformanceVersion;
	denormBehaviorIndependence: VkShaderFloatControlsIndependence;
	roundingModeIndependence: VkShaderFloatControlsIndependence;
	shaderSignedZeroInfNanPreserveFloat16: VkBool32;
	shaderSignedZeroInfNanPreserveFloat32: VkBool32;
	shaderSignedZeroInfNanPreserveFloat64: VkBool32;
	shaderDenormPreserveFloat16: VkBool32;
	shaderDenormPreserveFloat32: VkBool32;
	shaderDenormPreserveFloat64: VkBool32;
	shaderDenormFlushToZeroFloat16: VkBool32;
	shaderDenormFlushToZeroFloat32: VkBool32;
	shaderDenormFlushToZeroFloat64: VkBool32;
	shaderRoundingModeRTEFloat16: VkBool32;
	shaderRoundingModeRTEFloat32: VkBool32;
	shaderRoundingModeRTEFloat64: VkBool32;
	shaderRoundingModeRTZFloat16: VkBool32;
	shaderRoundingModeRTZFloat32: VkBool32;
	shaderRoundingModeRTZFloat64: VkBool32;
	maxUpdateAfterBindDescriptorsInAllPools: u32;
	shaderUniformBufferArrayNonUniformIndexingNative: VkBool32;
	shaderSampledImageArrayNonUniformIndexingNative: VkBool32;
	shaderStorageBufferArrayNonUniformIndexingNative: VkBool32;
	shaderStorageImageArrayNonUniformIndexingNative: VkBool32;
	shaderInputAttachmentArrayNonUniformIndexingNative: VkBool32;
	robustBufferAccessUpdateAfterBind: VkBool32;
	quadDivergentImplicitLod: VkBool32;
	maxPerStageDescriptorUpdateAfterBindSamplers: u32;
	maxPerStageDescriptorUpdateAfterBindUniformBuffers: u32;
	maxPerStageDescriptorUpdateAfterBindStorageBuffers: u32;
	maxPerStageDescriptorUpdateAfterBindSampledImages: u32;
	maxPerStageDescriptorUpdateAfterBindStorageImages: u32;
	maxPerStageDescriptorUpdateAfterBindInputAttachments: u32;
	maxPerStageUpdateAfterBindResources: u32;
	maxDescriptorSetUpdateAfterBindSamplers: u32;
	maxDescriptorSetUpdateAfterBindUniformBuffers: u32;
	maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: u32;
	maxDescriptorSetUpdateAfterBindStorageBuffers: u32;
	maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: u32;
	maxDescriptorSetUpdateAfterBindSampledImages: u32;
	maxDescriptorSetUpdateAfterBindStorageImages: u32;
	maxDescriptorSetUpdateAfterBindInputAttachments: u32;
	supportedDepthResolveModes: VkResolveModeFlags;
	supportedStencilResolveModes: VkResolveModeFlags;
	independentResolveNone: VkBool32;
	independentResolve: VkBool32;
	filterMinmaxSingleComponentFormats: VkBool32;
	filterMinmaxImageComponentMapping: VkBool32;
	maxTimelineSemaphoreValueDifference: u64;
	framebufferIntegerColorSampleCounts: VkSampleCountFlags;
}
VkImageFormatListCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	viewFormatCount: u32;
	pViewFormats: *VkFormat;
}
VkAttachmentDescription2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkAttachmentDescriptionFlags;
	format: VkFormat;
	samples: VkSampleCountFlagBits;
	loadOp: VkAttachmentLoadOp;
	storeOp: VkAttachmentStoreOp;
	stencilLoadOp: VkAttachmentLoadOp;
	stencilStoreOp: VkAttachmentStoreOp;
	initialLayout: VkImageLayout;
	finalLayout: VkImageLayout;
}
VkAttachmentReference2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	attachment: u32;
	layout: VkImageLayout;
	aspectMask: VkImageAspectFlags;
}
VkSubpassDescription2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkSubpassDescriptionFlags;
	pipelineBindPoint: VkPipelineBindPoint;
	viewMask: u32;
	inputAttachmentCount: u32;
	pInputAttachments: *VkAttachmentReference2;
	colorAttachmentCount: u32;
	pColorAttachments: *VkAttachmentReference2;
	pResolveAttachments: *VkAttachmentReference2;
	pDepthStencilAttachment: *VkAttachmentReference2;
	preserveAttachmentCount: u32;
	pPreserveAttachments: *u32;
}
VkSubpassDependency2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	srcSubpass: u32;
	dstSubpass: u32;
	srcStageMask: VkPipelineStageFlags;
	dstStageMask: VkPipelineStageFlags;
	srcAccessMask: VkAccessFlags;
	dstAccessMask: VkAccessFlags;
	dependencyFlags: VkDependencyFlags;
	viewOffset: s32;
}
VkRenderPassCreateInfo2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkRenderPassCreateFlags;
	attachmentCount: u32;
	pAttachments: *VkAttachmentDescription2;
	subpassCount: u32;
	pSubpasses: *VkSubpassDescription2;
	dependencyCount: u32;
	pDependencies: *VkSubpassDependency2;
	correlatedViewMaskCount: u32;
	pCorrelatedViewMasks: *u32;
}
VkSubpassBeginInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	contents: VkSubpassContents;
}
VkSubpassEndInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
}
VkPhysicalDevice8BitStorageFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	storageBuffer8BitAccess: VkBool32;
	uniformAndStorageBuffer8BitAccess: VkBool32;
	storagePushConstant8: VkBool32;
}
VkPhysicalDeviceDriverProperties :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	driverID: VkDriverId;
	driverName: [256]C.char;
	driverInfo: [256]C.char;
	conformanceVersion: VkConformanceVersion;
}
VkPhysicalDeviceShaderAtomicInt64Features :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shaderBufferInt64Atomics: VkBool32;
	shaderSharedInt64Atomics: VkBool32;
}
VkPhysicalDeviceShaderFloat16Int8Features :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shaderFloat16: VkBool32;
	shaderInt8: VkBool32;
}
VkPhysicalDeviceFloatControlsProperties :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	denormBehaviorIndependence: VkShaderFloatControlsIndependence;
	roundingModeIndependence: VkShaderFloatControlsIndependence;
	shaderSignedZeroInfNanPreserveFloat16: VkBool32;
	shaderSignedZeroInfNanPreserveFloat32: VkBool32;
	shaderSignedZeroInfNanPreserveFloat64: VkBool32;
	shaderDenormPreserveFloat16: VkBool32;
	shaderDenormPreserveFloat32: VkBool32;
	shaderDenormPreserveFloat64: VkBool32;
	shaderDenormFlushToZeroFloat16: VkBool32;
	shaderDenormFlushToZeroFloat32: VkBool32;
	shaderDenormFlushToZeroFloat64: VkBool32;
	shaderRoundingModeRTEFloat16: VkBool32;
	shaderRoundingModeRTEFloat32: VkBool32;
	shaderRoundingModeRTEFloat64: VkBool32;
	shaderRoundingModeRTZFloat16: VkBool32;
	shaderRoundingModeRTZFloat32: VkBool32;
	shaderRoundingModeRTZFloat64: VkBool32;
}
VkDescriptorSetLayoutBindingFlagsCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	bindingCount: u32;
	pBindingFlags: *VkDescriptorBindingFlags;
}
VkPhysicalDeviceDescriptorIndexingFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shaderInputAttachmentArrayDynamicIndexing: VkBool32;
	shaderUniformTexelBufferArrayDynamicIndexing: VkBool32;
	shaderStorageTexelBufferArrayDynamicIndexing: VkBool32;
	shaderUniformBufferArrayNonUniformIndexing: VkBool32;
	shaderSampledImageArrayNonUniformIndexing: VkBool32;
	shaderStorageBufferArrayNonUniformIndexing: VkBool32;
	shaderStorageImageArrayNonUniformIndexing: VkBool32;
	shaderInputAttachmentArrayNonUniformIndexing: VkBool32;
	shaderUniformTexelBufferArrayNonUniformIndexing: VkBool32;
	shaderStorageTexelBufferArrayNonUniformIndexing: VkBool32;
	descriptorBindingUniformBufferUpdateAfterBind: VkBool32;
	descriptorBindingSampledImageUpdateAfterBind: VkBool32;
	descriptorBindingStorageImageUpdateAfterBind: VkBool32;
	descriptorBindingStorageBufferUpdateAfterBind: VkBool32;
	descriptorBindingUniformTexelBufferUpdateAfterBind: VkBool32;
	descriptorBindingStorageTexelBufferUpdateAfterBind: VkBool32;
	descriptorBindingUpdateUnusedWhilePending: VkBool32;
	descriptorBindingPartiallyBound: VkBool32;
	descriptorBindingVariableDescriptorCount: VkBool32;
	runtimeDescriptorArray: VkBool32;
}
VkPhysicalDeviceDescriptorIndexingProperties :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	maxUpdateAfterBindDescriptorsInAllPools: u32;
	shaderUniformBufferArrayNonUniformIndexingNative: VkBool32;
	shaderSampledImageArrayNonUniformIndexingNative: VkBool32;
	shaderStorageBufferArrayNonUniformIndexingNative: VkBool32;
	shaderStorageImageArrayNonUniformIndexingNative: VkBool32;
	shaderInputAttachmentArrayNonUniformIndexingNative: VkBool32;
	robustBufferAccessUpdateAfterBind: VkBool32;
	quadDivergentImplicitLod: VkBool32;
	maxPerStageDescriptorUpdateAfterBindSamplers: u32;
	maxPerStageDescriptorUpdateAfterBindUniformBuffers: u32;
	maxPerStageDescriptorUpdateAfterBindStorageBuffers: u32;
	maxPerStageDescriptorUpdateAfterBindSampledImages: u32;
	maxPerStageDescriptorUpdateAfterBindStorageImages: u32;
	maxPerStageDescriptorUpdateAfterBindInputAttachments: u32;
	maxPerStageUpdateAfterBindResources: u32;
	maxDescriptorSetUpdateAfterBindSamplers: u32;
	maxDescriptorSetUpdateAfterBindUniformBuffers: u32;
	maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: u32;
	maxDescriptorSetUpdateAfterBindStorageBuffers: u32;
	maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: u32;
	maxDescriptorSetUpdateAfterBindSampledImages: u32;
	maxDescriptorSetUpdateAfterBindStorageImages: u32;
	maxDescriptorSetUpdateAfterBindInputAttachments: u32;
}
VkDescriptorSetVariableDescriptorCountAllocateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	descriptorSetCount: u32;
	pDescriptorCounts: *u32;
}
VkDescriptorSetVariableDescriptorCountLayoutSupport :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	maxVariableDescriptorCount: u32;
}
VkSubpassDescriptionDepthStencilResolve :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	depthResolveMode: VkResolveModeFlagBits;
	stencilResolveMode: VkResolveModeFlagBits;
	pDepthStencilResolveAttachment: *VkAttachmentReference2;
}
VkPhysicalDeviceDepthStencilResolveProperties :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	supportedDepthResolveModes: VkResolveModeFlags;
	supportedStencilResolveModes: VkResolveModeFlags;
	independentResolveNone: VkBool32;
	independentResolve: VkBool32;
}
VkPhysicalDeviceScalarBlockLayoutFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	scalarBlockLayout: VkBool32;
}
VkImageStencilUsageCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	stencilUsage: VkImageUsageFlags;
}
VkSamplerReductionModeCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	reductionMode: VkSamplerReductionMode;
}
VkPhysicalDeviceSamplerFilterMinmaxProperties :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	filterMinmaxSingleComponentFormats: VkBool32;
	filterMinmaxImageComponentMapping: VkBool32;
}
VkPhysicalDeviceVulkanMemoryModelFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	vulkanMemoryModel: VkBool32;
	vulkanMemoryModelDeviceScope: VkBool32;
	vulkanMemoryModelAvailabilityVisibilityChains: VkBool32;
}
VkPhysicalDeviceImagelessFramebufferFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	imagelessFramebuffer: VkBool32;
}
VkFramebufferAttachmentImageInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkImageCreateFlags;
	usage: VkImageUsageFlags;
	width: u32;
	height: u32;
	layerCount: u32;
	viewFormatCount: u32;
	pViewFormats: *VkFormat;
}
VkFramebufferAttachmentsCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	attachmentImageInfoCount: u32;
	pAttachmentImageInfos: *VkFramebufferAttachmentImageInfo;
}
VkRenderPassAttachmentBeginInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	attachmentCount: u32;
	pAttachments: *VkImageView;
}
VkPhysicalDeviceUniformBufferStandardLayoutFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	uniformBufferStandardLayout: VkBool32;
}
VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shaderSubgroupExtendedTypes: VkBool32;
}
VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	separateDepthStencilLayouts: VkBool32;
}
VkAttachmentReferenceStencilLayout :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	stencilLayout: VkImageLayout;
}
VkAttachmentDescriptionStencilLayout :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	stencilInitialLayout: VkImageLayout;
	stencilFinalLayout: VkImageLayout;
}
VkPhysicalDeviceHostQueryResetFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	hostQueryReset: VkBool32;
}
VkPhysicalDeviceTimelineSemaphoreFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	timelineSemaphore: VkBool32;
}
VkPhysicalDeviceTimelineSemaphoreProperties :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	maxTimelineSemaphoreValueDifference: u64;
}
VkSemaphoreTypeCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	semaphoreType: VkSemaphoreType;
	initialValue: u64;
}
VkTimelineSemaphoreSubmitInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	waitSemaphoreValueCount: u32;
	pWaitSemaphoreValues: *u64;
	signalSemaphoreValueCount: u32;
	pSignalSemaphoreValues: *u64;
}
VkSemaphoreWaitInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkSemaphoreWaitFlags;
	semaphoreCount: u32;
	pSemaphores: *VkSemaphore;
	pValues: *u64;
}
VkSemaphoreSignalInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	semaphore: VkSemaphore;
	value: u64;
}
VkPhysicalDeviceBufferDeviceAddressFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	bufferDeviceAddress: VkBool32;
	bufferDeviceAddressCaptureReplay: VkBool32;
	bufferDeviceAddressMultiDevice: VkBool32;
}
VkBufferDeviceAddressInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	buffer: VkBuffer;
}
VkBufferOpaqueCaptureAddressCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	opaqueCaptureAddress: u64;
}
VkMemoryOpaqueCaptureAddressAllocateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	opaqueCaptureAddress: u64;
}
VkDeviceMemoryOpaqueCaptureAddressInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	memory: VkDeviceMemory;
}
PFN_vkCmdDrawIndirectCount :: *fn (VkCommandBuffer, VkBuffer, VkDeviceSize, VkBuffer, VkDeviceSize, u32, u32);
PFN_vkCmdDrawIndexedIndirectCount :: *fn (VkCommandBuffer, VkBuffer, VkDeviceSize, VkBuffer, VkDeviceSize, u32, u32);
PFN_vkCreateRenderPass2 :: *fn (VkDevice, *VkRenderPassCreateInfo2, *VkAllocationCallbacks, *VkRenderPass) VkResult;
PFN_vkCmdBeginRenderPass2 :: *fn (VkCommandBuffer, *VkRenderPassBeginInfo, *VkSubpassBeginInfo);
PFN_vkCmdNextSubpass2 :: *fn (VkCommandBuffer, *VkSubpassBeginInfo, *VkSubpassEndInfo);
PFN_vkCmdEndRenderPass2 :: *fn (VkCommandBuffer, *VkSubpassEndInfo);
PFN_vkResetQueryPool :: *fn (VkDevice, VkQueryPool, u32, u32);
PFN_vkGetSemaphoreCounterValue :: *fn (VkDevice, VkSemaphore, *u64) VkResult;
PFN_vkWaitSemaphores :: *fn (VkDevice, *VkSemaphoreWaitInfo, u64) VkResult;
PFN_vkSignalSemaphore :: *fn (VkDevice, *VkSemaphoreSignalInfo) VkResult;
PFN_vkGetBufferDeviceAddress :: *fn (VkDevice, *VkBufferDeviceAddressInfo) VkDeviceAddress;
PFN_vkGetBufferOpaqueCaptureAddress :: *fn (VkDevice, *VkBufferDeviceAddressInfo) u64;
PFN_vkGetDeviceMemoryOpaqueCaptureAddress :: *fn (VkDevice, *VkDeviceMemoryOpaqueCaptureAddressInfo) u64;
vkCmdDrawIndirectCount :: fn (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) #extern;
vkCmdDrawIndexedIndirectCount :: fn (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) #extern;
vkCreateRenderPass2 :: fn (device: VkDevice, pCreateInfo: *VkRenderPassCreateInfo2, pAllocator: *VkAllocationCallbacks, pRenderPass: *VkRenderPass) VkResult #extern;
vkCmdBeginRenderPass2 :: fn (commandBuffer: VkCommandBuffer, pRenderPassBegin: *VkRenderPassBeginInfo, pSubpassBeginInfo: *VkSubpassBeginInfo) #extern;
vkCmdNextSubpass2 :: fn (commandBuffer: VkCommandBuffer, pSubpassBeginInfo: *VkSubpassBeginInfo, pSubpassEndInfo: *VkSubpassEndInfo) #extern;
vkCmdEndRenderPass2 :: fn (commandBuffer: VkCommandBuffer, pSubpassEndInfo: *VkSubpassEndInfo) #extern;
vkResetQueryPool :: fn (device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32) #extern;
vkGetSemaphoreCounterValue :: fn (device: VkDevice, semaphore: VkSemaphore, pValue: *u64) VkResult #extern;
vkWaitSemaphores :: fn (device: VkDevice, pWaitInfo: *VkSemaphoreWaitInfo, timeout: u64) VkResult #extern;
vkSignalSemaphore :: fn (device: VkDevice, pSignalInfo: *VkSemaphoreSignalInfo) VkResult #extern;
vkGetBufferDeviceAddress :: fn (device: VkDevice, pInfo: *VkBufferDeviceAddressInfo) VkDeviceAddress #extern;
vkGetBufferOpaqueCaptureAddress :: fn (device: VkDevice, pInfo: *VkBufferDeviceAddressInfo) u64 #extern;
vkGetDeviceMemoryOpaqueCaptureAddress :: fn (device: VkDevice, pInfo: *VkDeviceMemoryOpaqueCaptureAddressInfo) u64 #extern;
VkFlags64 :: u64;
VkPipelineCreationFeedbackFlagBits :: enum u32 #flags {
	VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT = 0x1;
	VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT = 0x2;
	VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT = 0x4;
	VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT = 0x1;
	VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT = 0x2;
	VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT = 0x4;
	VK_PIPELINE_CREATION_FEEDBACK_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkPipelineCreationFeedbackFlags :: VkFlags;
VkToolPurposeFlagBits :: enum u32 #flags {
	VK_TOOL_PURPOSE_VALIDATION_BIT = 0x1;
	VK_TOOL_PURPOSE_PROFILING_BIT = 0x2;
	VK_TOOL_PURPOSE_TRACING_BIT = 0x4;
	VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT = 0x8;
	VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT = 0x10;
	VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT = 0x20;
	VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT = 0x40;
	VK_TOOL_PURPOSE_VALIDATION_BIT_EXT = 0x1;
	VK_TOOL_PURPOSE_PROFILING_BIT_EXT = 0x2;
	VK_TOOL_PURPOSE_TRACING_BIT_EXT = 0x4;
	VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT = 0x8;
	VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT = 0x10;
	VK_TOOL_PURPOSE_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkToolPurposeFlags :: VkFlags;
VkPrivateDataSlotCreateFlags :: VkFlags;
VkPipelineStageFlags2 :: VkFlags64;
VkPipelineStageFlagBits2 :: VkFlags64;

VK_PIPELINE_STAGE_2_NONE : VkPipelineStageFlagBits2 :0;
VK_PIPELINE_STAGE_2_NONE_KHR : VkPipelineStageFlagBits2 :0;
VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT : VkPipelineStageFlagBits2 :0x00000001;
VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR : VkPipelineStageFlagBits2 :0x00000001;
VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT : VkPipelineStageFlagBits2 :0x00000002;
VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR : VkPipelineStageFlagBits2 :0x00000002;
VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT : VkPipelineStageFlagBits2 :0x00000004;
VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR : VkPipelineStageFlagBits2 :0x00000004;
VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT : VkPipelineStageFlagBits2 :0x00000008;
VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR : VkPipelineStageFlagBits2 :0x00000008;
VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT : VkPipelineStageFlagBits2 :0x00000010;
VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR : VkPipelineStageFlagBits2 :0x00000010;
VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT : VkPipelineStageFlagBits2 :0x00000020;
VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR : VkPipelineStageFlagBits2 :0x00000020;
VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT : VkPipelineStageFlagBits2 :0x00000040;
VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR : VkPipelineStageFlagBits2 :0x00000040;
VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT : VkPipelineStageFlagBits2 :0x00000080;
VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR : VkPipelineStageFlagBits2 :0x00000080;
VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT : VkPipelineStageFlagBits2 :0x00000100;
VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR : VkPipelineStageFlagBits2 :0x00000100;
VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT : VkPipelineStageFlagBits2 :0x00000200;
VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR : VkPipelineStageFlagBits2 :0x00000200;
VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT : VkPipelineStageFlagBits2 :0x00000400;
VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR : VkPipelineStageFlagBits2 :0x00000400;
VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT : VkPipelineStageFlagBits2 :0x00000800;
VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR : VkPipelineStageFlagBits2 :0x00000800;
VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT : VkPipelineStageFlagBits2 :0x00001000;
VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR : VkPipelineStageFlagBits2 :0x00001000;
VK_PIPELINE_STAGE_2_TRANSFER_BIT : VkPipelineStageFlagBits2 :0x00001000;
VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR : VkPipelineStageFlagBits2 :0x00001000;
VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT : VkPipelineStageFlagBits2 :0x00002000;
VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR : VkPipelineStageFlagBits2 :0x00002000;
VK_PIPELINE_STAGE_2_HOST_BIT : VkPipelineStageFlagBits2 :0x00004000;
VK_PIPELINE_STAGE_2_HOST_BIT_KHR : VkPipelineStageFlagBits2 :0x00004000;
VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT : VkPipelineStageFlagBits2 :0x00008000;
VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR : VkPipelineStageFlagBits2 :0x00008000;
VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT : VkPipelineStageFlagBits2 :0x00010000;
VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR : VkPipelineStageFlagBits2 :0x00010000;
VK_PIPELINE_STAGE_2_COPY_BIT : VkPipelineStageFlagBits2 :0x100000000;
VK_PIPELINE_STAGE_2_COPY_BIT_KHR : VkPipelineStageFlagBits2 :0x100000000;
VK_PIPELINE_STAGE_2_RESOLVE_BIT : VkPipelineStageFlagBits2 :0x200000000;
VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR : VkPipelineStageFlagBits2 :0x200000000;
VK_PIPELINE_STAGE_2_BLIT_BIT : VkPipelineStageFlagBits2 :0x400000000;
VK_PIPELINE_STAGE_2_BLIT_BIT_KHR : VkPipelineStageFlagBits2 :0x400000000;
VK_PIPELINE_STAGE_2_CLEAR_BIT : VkPipelineStageFlagBits2 :0x800000000;
VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR : VkPipelineStageFlagBits2 :0x800000000;
VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT : VkPipelineStageFlagBits2 :0x1000000000;
VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR : VkPipelineStageFlagBits2 :0x1000000000;
VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT : VkPipelineStageFlagBits2 :0x2000000000;
VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR : VkPipelineStageFlagBits2 :0x2000000000;
VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT : VkPipelineStageFlagBits2 :0x4000000000;
VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR : VkPipelineStageFlagBits2 :0x4000000000;
VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR : VkPipelineStageFlagBits2 :0x04000000;
VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR : VkPipelineStageFlagBits2 :0x08000000;
VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT : VkPipelineStageFlagBits2 :0x01000000;
VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT : VkPipelineStageFlagBits2 :0x00040000;
VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV : VkPipelineStageFlagBits2 :0x00020000;
VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR : VkPipelineStageFlagBits2 :0x00400000;
VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV : VkPipelineStageFlagBits2 :0x00400000;
VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR : VkPipelineStageFlagBits2 :0x02000000;
VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR : VkPipelineStageFlagBits2 :0x00200000;
VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV : VkPipelineStageFlagBits2 :0x00200000;
VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV : VkPipelineStageFlagBits2 :0x02000000;
VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT : VkPipelineStageFlagBits2 :0x00800000;
VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV : VkPipelineStageFlagBits2 :0x00080000;
VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV : VkPipelineStageFlagBits2 :0x00100000;
VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT : VkPipelineStageFlagBits2 :0x00080000;
VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT : VkPipelineStageFlagBits2 :0x00100000;
VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI : VkPipelineStageFlagBits2 :0x8000000000;
VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI : VkPipelineStageFlagBits2 :0x8000000000;
VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI : VkPipelineStageFlagBits2 :0x10000000000;
VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR : VkPipelineStageFlagBits2 :0x10000000;
VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT : VkPipelineStageFlagBits2 :0x40000000;
VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI : VkPipelineStageFlagBits2 :0x20000000000;
VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV : VkPipelineStageFlagBits2 :0x20000000;

VkAccessFlags2 :: VkFlags64;
VkAccessFlagBits2 :: VkFlags64;

VK_ACCESS_2_NONE : VkAccessFlagBits2 : 0;
VK_ACCESS_2_NONE_KHR : VkAccessFlagBits2 : 0;
VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT : VkAccessFlagBits2 : 0x00000001;
VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR : VkAccessFlagBits2 : 0x00000001;
VK_ACCESS_2_INDEX_READ_BIT : VkAccessFlagBits2 : 0x00000002;
VK_ACCESS_2_INDEX_READ_BIT_KHR : VkAccessFlagBits2 : 0x00000002;
VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT : VkAccessFlagBits2 : 0x00000004;
VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR : VkAccessFlagBits2 : 0x00000004;
VK_ACCESS_2_UNIFORM_READ_BIT : VkAccessFlagBits2 : 0x00000008;
VK_ACCESS_2_UNIFORM_READ_BIT_KHR : VkAccessFlagBits2 : 0x00000008;
VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT : VkAccessFlagBits2 : 0x00000010;
VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR : VkAccessFlagBits2 : 0x00000010;
VK_ACCESS_2_SHADER_READ_BIT : VkAccessFlagBits2 : 0x00000020;
VK_ACCESS_2_SHADER_READ_BIT_KHR : VkAccessFlagBits2 : 0x00000020;
VK_ACCESS_2_SHADER_WRITE_BIT : VkAccessFlagBits2 : 0x00000040;
VK_ACCESS_2_SHADER_WRITE_BIT_KHR : VkAccessFlagBits2 : 0x00000040;
VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT : VkAccessFlagBits2 : 0x00000080;
VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR : VkAccessFlagBits2 : 0x00000080;
VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT : VkAccessFlagBits2 : 0x00000100;
VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR : VkAccessFlagBits2 : 0x00000100;
VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT : VkAccessFlagBits2 : 0x00000200;
VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR : VkAccessFlagBits2 : 0x00000200;
VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT : VkAccessFlagBits2 : 0x00000400;
VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR : VkAccessFlagBits2 : 0x00000400;
VK_ACCESS_2_TRANSFER_READ_BIT : VkAccessFlagBits2 : 0x00000800;
VK_ACCESS_2_TRANSFER_READ_BIT_KHR : VkAccessFlagBits2 : 0x00000800;
VK_ACCESS_2_TRANSFER_WRITE_BIT : VkAccessFlagBits2 : 0x00001000;
VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR : VkAccessFlagBits2 : 0x00001000;
VK_ACCESS_2_HOST_READ_BIT : VkAccessFlagBits2 : 0x00002000;
VK_ACCESS_2_HOST_READ_BIT_KHR : VkAccessFlagBits2 : 0x00002000;
VK_ACCESS_2_HOST_WRITE_BIT : VkAccessFlagBits2 : 0x00004000;
VK_ACCESS_2_HOST_WRITE_BIT_KHR : VkAccessFlagBits2 : 0x00004000;
VK_ACCESS_2_MEMORY_READ_BIT : VkAccessFlagBits2 : 0x00008000;
VK_ACCESS_2_MEMORY_READ_BIT_KHR : VkAccessFlagBits2 : 0x00008000;
VK_ACCESS_2_MEMORY_WRITE_BIT : VkAccessFlagBits2 : 0x00010000;
VK_ACCESS_2_MEMORY_WRITE_BIT_KHR : VkAccessFlagBits2 : 0x00010000;
VK_ACCESS_2_SHADER_SAMPLED_READ_BIT : VkAccessFlagBits2 : 0x100000000;
VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR : VkAccessFlagBits2 : 0x100000000;
VK_ACCESS_2_SHADER_STORAGE_READ_BIT : VkAccessFlagBits2 : 0x200000000;
VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR : VkAccessFlagBits2 : 0x200000000;
VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT : VkAccessFlagBits2 : 0x400000000;
VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR : VkAccessFlagBits2 : 0x400000000;
VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR : VkAccessFlagBits2 : 0x800000000;
VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR : VkAccessFlagBits2 : 0x1000000000;
VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR : VkAccessFlagBits2 : 0x2000000000;
VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR : VkAccessFlagBits2 : 0x4000000000;
VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT : VkAccessFlagBits2 : 0x02000000;
VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT : VkAccessFlagBits2 : 0x04000000;
VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT : VkAccessFlagBits2 : 0x08000000;
VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT : VkAccessFlagBits2 : 0x00100000;
VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV : VkAccessFlagBits2 : 0x00020000;
VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV : VkAccessFlagBits2 : 0x00040000;
VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR : VkAccessFlagBits2 : 0x00800000;
VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV : VkAccessFlagBits2 : 0x00800000;
VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR : VkAccessFlagBits2 : 0x00200000;
VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR : VkAccessFlagBits2 : 0x00400000;
VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV : VkAccessFlagBits2 : 0x00200000;
VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV : VkAccessFlagBits2 : 0x00400000;
VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT : VkAccessFlagBits2 : 0x01000000;
VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT : VkAccessFlagBits2 : 0x00080000;
VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT : VkAccessFlagBits2 : 0x20000000000;
VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI : VkAccessFlagBits2 : 0x8000000000;
VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR : VkAccessFlagBits2 : 0x10000000000;
VK_ACCESS_2_MICROMAP_READ_BIT_EXT : VkAccessFlagBits2 : 0x100000000000;
VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT : VkAccessFlagBits2 : 0x200000000000;
VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV : VkAccessFlagBits2 : 0x40000000000;
VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV : VkAccessFlagBits2 : 0x80000000000;


VkSubmitFlagBits :: enum u32 #flags {
	VK_SUBMIT_PROTECTED_BIT = 0x1;
	VK_SUBMIT_PROTECTED_BIT_KHR = 0x1;
	VK_SUBMIT_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkSubmitFlags :: VkFlags;
VkRenderingFlagBits :: enum u32 #flags {
	VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT = 0x1;
	VK_RENDERING_SUSPENDING_BIT = 0x2;
	VK_RENDERING_RESUMING_BIT = 0x4;
	VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT = 0x8;
	VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR = 0x1;
	VK_RENDERING_SUSPENDING_BIT_KHR = 0x2;
	VK_RENDERING_RESUMING_BIT_KHR = 0x4;
	VK_RENDERING_FLAG_BITS_MAX_ENUM = 0x7fffffff;
}
VkRenderingFlags :: VkFlags;
VkFormatFeatureFlags2 :: VkFlags64;
VkFormatFeatureFlagBits2 :: VkFlags64;
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6648: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6649: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6650: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6651: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6652: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6653: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6654: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6655: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6656: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6657: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6658: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6659: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6660: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6661: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6662: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6663: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6664: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6665: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6666: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6667: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6668: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6669: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6670: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6671: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6672: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6673: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6674: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6675: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6676: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6677: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6678: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6679: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6680: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6681: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6682: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6683: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6684: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6685: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6686: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6687: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6688: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6689: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6690: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6691: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6692: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6693: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6694: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6695: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6696: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6697: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6698: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6699: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6700: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6701: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6708: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6709: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6710: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6717: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6718: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6719: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6720: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6721: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6722: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6723: Unsupported C object kind 'CursorKind.VarDecl'. */
/* C:\VulkanSDK\1.3.231.1\Include\vulkan\vulkan_core.h:6724: Unsupported C object kind 'CursorKind.VarDecl'. */
VkPhysicalDeviceVulkan13Features :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	robustImageAccess: VkBool32;
	inlineUniformBlock: VkBool32;
	descriptorBindingInlineUniformBlockUpdateAfterBind: VkBool32;
	pipelineCreationCacheControl: VkBool32;
	privateData: VkBool32;
	shaderDemoteToHelperInvocation: VkBool32;
	shaderTerminateInvocation: VkBool32;
	subgroupSizeControl: VkBool32;
	computeFullSubgroups: VkBool32;
	synchronization2: VkBool32;
	textureCompressionASTC_HDR: VkBool32;
	shaderZeroInitializeWorkgroupMemory: VkBool32;
	dynamicRendering: VkBool32;
	shaderIntegerDotProduct: VkBool32;
	maintenance4: VkBool32;
}
VkPhysicalDeviceVulkan13Properties :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	minSubgroupSize: u32;
	maxSubgroupSize: u32;
	maxComputeWorkgroupSubgroups: u32;
	requiredSubgroupSizeStages: VkShaderStageFlags;
	maxInlineUniformBlockSize: u32;
	maxPerStageDescriptorInlineUniformBlocks: u32;
	maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: u32;
	maxDescriptorSetInlineUniformBlocks: u32;
	maxDescriptorSetUpdateAfterBindInlineUniformBlocks: u32;
	maxInlineUniformTotalSize: u32;
	integerDotProduct8BitUnsignedAccelerated: VkBool32;
	integerDotProduct8BitSignedAccelerated: VkBool32;
	integerDotProduct8BitMixedSignednessAccelerated: VkBool32;
	integerDotProduct4x8BitPackedUnsignedAccelerated: VkBool32;
	integerDotProduct4x8BitPackedSignedAccelerated: VkBool32;
	integerDotProduct4x8BitPackedMixedSignednessAccelerated: VkBool32;
	integerDotProduct16BitUnsignedAccelerated: VkBool32;
	integerDotProduct16BitSignedAccelerated: VkBool32;
	integerDotProduct16BitMixedSignednessAccelerated: VkBool32;
	integerDotProduct32BitUnsignedAccelerated: VkBool32;
	integerDotProduct32BitSignedAccelerated: VkBool32;
	integerDotProduct32BitMixedSignednessAccelerated: VkBool32;
	integerDotProduct64BitUnsignedAccelerated: VkBool32;
	integerDotProduct64BitSignedAccelerated: VkBool32;
	integerDotProduct64BitMixedSignednessAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating8BitSignedAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating16BitSignedAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating32BitSignedAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating64BitSignedAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: VkBool32;
	storageTexelBufferOffsetAlignmentBytes: VkDeviceSize;
	storageTexelBufferOffsetSingleTexelAlignment: VkBool32;
	uniformTexelBufferOffsetAlignmentBytes: VkDeviceSize;
	uniformTexelBufferOffsetSingleTexelAlignment: VkBool32;
	maxBufferSize: VkDeviceSize;
}
VkPipelineCreationFeedback :: struct {
	flags: VkPipelineCreationFeedbackFlags;
	duration: u64;
}
VkPipelineCreationFeedbackCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	pPipelineCreationFeedback: *VkPipelineCreationFeedback;
	pipelineStageCreationFeedbackCount: u32;
	pPipelineStageCreationFeedbacks: *VkPipelineCreationFeedback;
}
VkPhysicalDeviceShaderTerminateInvocationFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shaderTerminateInvocation: VkBool32;
}
VkPhysicalDeviceToolProperties :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	name: [256]C.char;
	version: [256]C.char;
	purposes: VkToolPurposeFlags;
	description: [256]C.char;
	layer: [256]C.char;
}
VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shaderDemoteToHelperInvocation: VkBool32;
}
VkPhysicalDevicePrivateDataFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	privateData: VkBool32;
}
VkDevicePrivateDataCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	privateDataSlotRequestCount: u32;
}
VkPrivateDataSlotCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkPrivateDataSlotCreateFlags;
}
VkPhysicalDevicePipelineCreationCacheControlFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	pipelineCreationCacheControl: VkBool32;
}
VkMemoryBarrier2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	srcStageMask: VkPipelineStageFlags2;
	srcAccessMask: VkAccessFlags2;
	dstStageMask: VkPipelineStageFlags2;
	dstAccessMask: VkAccessFlags2;
}
VkBufferMemoryBarrier2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	srcStageMask: VkPipelineStageFlags2;
	srcAccessMask: VkAccessFlags2;
	dstStageMask: VkPipelineStageFlags2;
	dstAccessMask: VkAccessFlags2;
	srcQueueFamilyIndex: u32;
	dstQueueFamilyIndex: u32;
	buffer: VkBuffer;
	offset: VkDeviceSize;
	size: VkDeviceSize;
}
VkImageMemoryBarrier2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	srcStageMask: VkPipelineStageFlags2;
	srcAccessMask: VkAccessFlags2;
	dstStageMask: VkPipelineStageFlags2;
	dstAccessMask: VkAccessFlags2;
	oldLayout: VkImageLayout;
	newLayout: VkImageLayout;
	srcQueueFamilyIndex: u32;
	dstQueueFamilyIndex: u32;
	image: VkImage;
	subresourceRange: VkImageSubresourceRange;
}
VkDependencyInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	dependencyFlags: VkDependencyFlags;
	memoryBarrierCount: u32;
	pMemoryBarriers: *VkMemoryBarrier2;
	bufferMemoryBarrierCount: u32;
	pBufferMemoryBarriers: *VkBufferMemoryBarrier2;
	imageMemoryBarrierCount: u32;
	pImageMemoryBarriers: *VkImageMemoryBarrier2;
}
VkSemaphoreSubmitInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	semaphore: VkSemaphore;
	value: u64;
	stageMask: VkPipelineStageFlags2;
	deviceIndex: u32;
}
VkCommandBufferSubmitInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	commandBuffer: VkCommandBuffer;
	deviceMask: u32;
}
VkSubmitInfo2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkSubmitFlags;
	waitSemaphoreInfoCount: u32;
	pWaitSemaphoreInfos: *VkSemaphoreSubmitInfo;
	commandBufferInfoCount: u32;
	pCommandBufferInfos: *VkCommandBufferSubmitInfo;
	signalSemaphoreInfoCount: u32;
	pSignalSemaphoreInfos: *VkSemaphoreSubmitInfo;
}
VkPhysicalDeviceSynchronization2Features :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	synchronization2: VkBool32;
}
VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shaderZeroInitializeWorkgroupMemory: VkBool32;
}
VkPhysicalDeviceImageRobustnessFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	robustImageAccess: VkBool32;
}
VkBufferCopy2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	srcOffset: VkDeviceSize;
	dstOffset: VkDeviceSize;
	size: VkDeviceSize;
}
VkCopyBufferInfo2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	srcBuffer: VkBuffer;
	dstBuffer: VkBuffer;
	regionCount: u32;
	pRegions: *VkBufferCopy2;
}
VkImageCopy2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	srcSubresource: VkImageSubresourceLayers;
	srcOffset: VkOffset3D;
	dstSubresource: VkImageSubresourceLayers;
	dstOffset: VkOffset3D;
	extent: VkExtent3D;
}
VkCopyImageInfo2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	srcImage: VkImage;
	srcImageLayout: VkImageLayout;
	dstImage: VkImage;
	dstImageLayout: VkImageLayout;
	regionCount: u32;
	pRegions: *VkImageCopy2;
}
VkBufferImageCopy2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	bufferOffset: VkDeviceSize;
	bufferRowLength: u32;
	bufferImageHeight: u32;
	imageSubresource: VkImageSubresourceLayers;
	imageOffset: VkOffset3D;
	imageExtent: VkExtent3D;
}
VkCopyBufferToImageInfo2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	srcBuffer: VkBuffer;
	dstImage: VkImage;
	dstImageLayout: VkImageLayout;
	regionCount: u32;
	pRegions: *VkBufferImageCopy2;
}
VkCopyImageToBufferInfo2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	srcImage: VkImage;
	srcImageLayout: VkImageLayout;
	dstBuffer: VkBuffer;
	regionCount: u32;
	pRegions: *VkBufferImageCopy2;
}
VkImageBlit2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	srcSubresource: VkImageSubresourceLayers;
	srcOffsets: [2]VkOffset3D;
	dstSubresource: VkImageSubresourceLayers;
	dstOffsets: [2]VkOffset3D;
}
VkBlitImageInfo2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	srcImage: VkImage;
	srcImageLayout: VkImageLayout;
	dstImage: VkImage;
	dstImageLayout: VkImageLayout;
	regionCount: u32;
	pRegions: *VkImageBlit2;
	filter: VkFilter;
}
VkImageResolve2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	srcSubresource: VkImageSubresourceLayers;
	srcOffset: VkOffset3D;
	dstSubresource: VkImageSubresourceLayers;
	dstOffset: VkOffset3D;
	extent: VkExtent3D;
}
VkResolveImageInfo2 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	srcImage: VkImage;
	srcImageLayout: VkImageLayout;
	dstImage: VkImage;
	dstImageLayout: VkImageLayout;
	regionCount: u32;
	pRegions: *VkImageResolve2;
}
VkPhysicalDeviceSubgroupSizeControlFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	subgroupSizeControl: VkBool32;
	computeFullSubgroups: VkBool32;
}
VkPhysicalDeviceSubgroupSizeControlProperties :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	minSubgroupSize: u32;
	maxSubgroupSize: u32;
	maxComputeWorkgroupSubgroups: u32;
	requiredSubgroupSizeStages: VkShaderStageFlags;
}
VkPipelineShaderStageRequiredSubgroupSizeCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	requiredSubgroupSize: u32;
}
VkPhysicalDeviceInlineUniformBlockFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	inlineUniformBlock: VkBool32;
	descriptorBindingInlineUniformBlockUpdateAfterBind: VkBool32;
}
VkPhysicalDeviceInlineUniformBlockProperties :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	maxInlineUniformBlockSize: u32;
	maxPerStageDescriptorInlineUniformBlocks: u32;
	maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: u32;
	maxDescriptorSetInlineUniformBlocks: u32;
	maxDescriptorSetUpdateAfterBindInlineUniformBlocks: u32;
}
VkWriteDescriptorSetInlineUniformBlock :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	dataSize: u32;
	pData: C.void_ptr;
}
VkDescriptorPoolInlineUniformBlockCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	maxInlineUniformBlockBindings: u32;
}
VkPhysicalDeviceTextureCompressionASTCHDRFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	textureCompressionASTC_HDR: VkBool32;
}
VkRenderingAttachmentInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	imageView: VkImageView;
	imageLayout: VkImageLayout;
	resolveMode: VkResolveModeFlagBits;
	resolveImageView: VkImageView;
	resolveImageLayout: VkImageLayout;
	loadOp: VkAttachmentLoadOp;
	storeOp: VkAttachmentStoreOp;
	clearValue: VkClearValue;
}
VkRenderingInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkRenderingFlags;
	renderArea: VkRect2D;
	layerCount: u32;
	viewMask: u32;
	colorAttachmentCount: u32;
	pColorAttachments: *VkRenderingAttachmentInfo;
	pDepthAttachment: *VkRenderingAttachmentInfo;
	pStencilAttachment: *VkRenderingAttachmentInfo;
}
VkPipelineRenderingCreateInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	viewMask: u32;
	colorAttachmentCount: u32;
	pColorAttachmentFormats: *VkFormat;
	depthAttachmentFormat: VkFormat;
	stencilAttachmentFormat: VkFormat;
}
VkPhysicalDeviceDynamicRenderingFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	dynamicRendering: VkBool32;
}
VkCommandBufferInheritanceRenderingInfo :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkRenderingFlags;
	viewMask: u32;
	colorAttachmentCount: u32;
	pColorAttachmentFormats: *VkFormat;
	depthAttachmentFormat: VkFormat;
	stencilAttachmentFormat: VkFormat;
	rasterizationSamples: VkSampleCountFlagBits;
}
VkPhysicalDeviceShaderIntegerDotProductFeatures :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shaderIntegerDotProduct: VkBool32;
}
VkPhysicalDeviceShaderIntegerDotProductProperties :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	integerDotProduct8BitUnsignedAccelerated: VkBool32;
	integerDotProduct8BitSignedAccelerated: VkBool32;
	integerDotProduct8BitMixedSignednessAccelerated: VkBool32;
	integerDotProduct4x8BitPackedUnsignedAccelerated: VkBool32;
	integerDotProduct4x8BitPackedSignedAccelerated: VkBool32;
	integerDotProduct4x8BitPackedMixedSignednessAccelerated: VkBool32;
	integerDotProduct16BitUnsignedAccelerated: VkBool32;
	integerDotProduct16BitSignedAccelerated: VkBool32;
	integerDotProduct16BitMixedSignednessAccelerated: VkBool32;
	integerDotProduct32BitUnsignedAccelerated: VkBool32;
	integerDotProduct32BitSignedAccelerated: VkBool32;
	integerDotProduct32BitMixedSignednessAccelerated: VkBool32;
	integerDotProduct64BitUnsignedAccelerated: VkBool32;
	integerDotProduct64BitSignedAccelerated: VkBool32;
	integerDotProduct64BitMixedSignednessAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating8BitSignedAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating16BitSignedAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating32BitSignedAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating64BitSignedAccelerated: VkBool32;
	integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: VkBool32;
}
VkPhysicalDeviceTexelBufferAlignmentProperties :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	storageTexelBufferOffsetAlignmentBytes: VkDeviceSize;
	storageTexelBufferOffsetSingleTexelAlignment: VkBool32;
	uniformTexelBufferOffsetAlignmentBytes: VkDeviceSize;
	uniformTexelBufferOffsetSingleTexelAlignment: VkBool32;
}
VkFormatProperties3 :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	linearTilingFeatures: VkFormatFeatureFlags2;
	optimalTilingFeatures: VkFormatFeatureFlags2;
	bufferFeatures: VkFormatFeatureFlags2;
}
VkPhysicalDeviceMaintenance4Features :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	maintenance4: VkBool32;
}
VkPhysicalDeviceMaintenance4Properties :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	maxBufferSize: VkDeviceSize;
}
VkDeviceBufferMemoryRequirements :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	pCreateInfo: *VkBufferCreateInfo;
}
VkDeviceImageMemoryRequirements :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	pCreateInfo: *VkImageCreateInfo;
	planeAspect: VkImageAspectFlagBits;
}
PFN_vkGetPhysicalDeviceToolProperties :: *fn (VkPhysicalDevice, *u32, *VkPhysicalDeviceToolProperties) VkResult;
PFN_vkCreatePrivateDataSlot :: *fn (VkDevice, *VkPrivateDataSlotCreateInfo, *VkAllocationCallbacks, *VkPrivateDataSlot) VkResult;
PFN_vkDestroyPrivateDataSlot :: *fn (VkDevice, VkPrivateDataSlot, *VkAllocationCallbacks);
PFN_vkSetPrivateData :: *fn (VkDevice, VkObjectType, u64, VkPrivateDataSlot, u64) VkResult;
PFN_vkGetPrivateData :: *fn (VkDevice, VkObjectType, u64, VkPrivateDataSlot, *u64);
PFN_vkCmdSetEvent2 :: *fn (VkCommandBuffer, VkEvent, *VkDependencyInfo);
PFN_vkCmdResetEvent2 :: *fn (VkCommandBuffer, VkEvent, VkPipelineStageFlags2);
PFN_vkCmdWaitEvents2 :: *fn (VkCommandBuffer, u32, *VkEvent, *VkDependencyInfo);
PFN_vkCmdPipelineBarrier2 :: *fn (VkCommandBuffer, *VkDependencyInfo);
PFN_vkCmdWriteTimestamp2 :: *fn (VkCommandBuffer, VkPipelineStageFlags2, VkQueryPool, u32);
PFN_vkQueueSubmit2 :: *fn (VkQueue, u32, *VkSubmitInfo2, VkFence) VkResult;
PFN_vkCmdCopyBuffer2 :: *fn (VkCommandBuffer, *VkCopyBufferInfo2);
PFN_vkCmdCopyImage2 :: *fn (VkCommandBuffer, *VkCopyImageInfo2);
PFN_vkCmdCopyBufferToImage2 :: *fn (VkCommandBuffer, *VkCopyBufferToImageInfo2);
PFN_vkCmdCopyImageToBuffer2 :: *fn (VkCommandBuffer, *VkCopyImageToBufferInfo2);
PFN_vkCmdBlitImage2 :: *fn (VkCommandBuffer, *VkBlitImageInfo2);
PFN_vkCmdResolveImage2 :: *fn (VkCommandBuffer, *VkResolveImageInfo2);
PFN_vkCmdBeginRendering :: *fn (VkCommandBuffer, *VkRenderingInfo);
PFN_vkCmdEndRendering :: *fn (VkCommandBuffer);
PFN_vkCmdSetCullMode :: *fn (VkCommandBuffer, VkCullModeFlags);
PFN_vkCmdSetFrontFace :: *fn (VkCommandBuffer, VkFrontFace);
PFN_vkCmdSetPrimitiveTopology :: *fn (VkCommandBuffer, VkPrimitiveTopology);
PFN_vkCmdSetViewportWithCount :: *fn (VkCommandBuffer, u32, *VkViewport);
PFN_vkCmdSetScissorWithCount :: *fn (VkCommandBuffer, u32, *VkRect2D);
PFN_vkCmdBindVertexBuffers2 :: *fn (VkCommandBuffer, u32, u32, *VkBuffer, *VkDeviceSize, *VkDeviceSize, *VkDeviceSize);
PFN_vkCmdSetDepthTestEnable :: *fn (VkCommandBuffer, VkBool32);
PFN_vkCmdSetDepthWriteEnable :: *fn (VkCommandBuffer, VkBool32);
PFN_vkCmdSetDepthCompareOp :: *fn (VkCommandBuffer, VkCompareOp);
PFN_vkCmdSetDepthBoundsTestEnable :: *fn (VkCommandBuffer, VkBool32);
PFN_vkCmdSetStencilTestEnable :: *fn (VkCommandBuffer, VkBool32);
PFN_vkCmdSetStencilOp :: *fn (VkCommandBuffer, VkStencilFaceFlags, VkStencilOp, VkStencilOp, VkStencilOp, VkCompareOp);
PFN_vkCmdSetRasterizerDiscardEnable :: *fn (VkCommandBuffer, VkBool32);
PFN_vkCmdSetDepthBiasEnable :: *fn (VkCommandBuffer, VkBool32);
PFN_vkCmdSetPrimitiveRestartEnable :: *fn (VkCommandBuffer, VkBool32);
PFN_vkGetDeviceBufferMemoryRequirements :: *fn (VkDevice, *VkDeviceBufferMemoryRequirements, *VkMemoryRequirements2);
PFN_vkGetDeviceImageMemoryRequirements :: *fn (VkDevice, *VkDeviceImageMemoryRequirements, *VkMemoryRequirements2);
PFN_vkGetDeviceImageSparseMemoryRequirements :: *fn (VkDevice, *VkDeviceImageMemoryRequirements, *u32, *VkSparseImageMemoryRequirements2);
vkGetPhysicalDeviceToolProperties :: fn (physicalDevice: VkPhysicalDevice, pToolCount: *u32, pToolProperties: *VkPhysicalDeviceToolProperties) VkResult #extern;
vkCreatePrivateDataSlot :: fn (device: VkDevice, pCreateInfo: *VkPrivateDataSlotCreateInfo, pAllocator: *VkAllocationCallbacks, pPrivateDataSlot: *VkPrivateDataSlot) VkResult #extern;
vkDestroyPrivateDataSlot :: fn (device: VkDevice, privateDataSlot: VkPrivateDataSlot, pAllocator: *VkAllocationCallbacks) #extern;
vkSetPrivateData :: fn (device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, data: u64) VkResult #extern;
vkGetPrivateData :: fn (device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, pData: *u64) #extern;
vkCmdSetEvent2 :: fn (commandBuffer: VkCommandBuffer, event: VkEvent, pDependencyInfo: *VkDependencyInfo) #extern;
vkCmdResetEvent2 :: fn (commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags2) #extern;
vkCmdWaitEvents2 :: fn (commandBuffer: VkCommandBuffer, eventCount: u32, pEvents: *VkEvent, pDependencyInfos: *VkDependencyInfo) #extern;
vkCmdPipelineBarrier2 :: fn (commandBuffer: VkCommandBuffer, pDependencyInfo: *VkDependencyInfo) #extern;
vkCmdWriteTimestamp2 :: fn (commandBuffer: VkCommandBuffer, stage: VkPipelineStageFlags2, queryPool: VkQueryPool, query: u32) #extern;
vkQueueSubmit2 :: fn (queue: VkQueue, submitCount: u32, pSubmits: *VkSubmitInfo2, fence: VkFence) VkResult #extern;
vkCmdCopyBuffer2 :: fn (commandBuffer: VkCommandBuffer, pCopyBufferInfo: *VkCopyBufferInfo2) #extern;
vkCmdCopyImage2 :: fn (commandBuffer: VkCommandBuffer, pCopyImageInfo: *VkCopyImageInfo2) #extern;
vkCmdCopyBufferToImage2 :: fn (commandBuffer: VkCommandBuffer, pCopyBufferToImageInfo: *VkCopyBufferToImageInfo2) #extern;
vkCmdCopyImageToBuffer2 :: fn (commandBuffer: VkCommandBuffer, pCopyImageToBufferInfo: *VkCopyImageToBufferInfo2) #extern;
vkCmdBlitImage2 :: fn (commandBuffer: VkCommandBuffer, pBlitImageInfo: *VkBlitImageInfo2) #extern;
vkCmdResolveImage2 :: fn (commandBuffer: VkCommandBuffer, pResolveImageInfo: *VkResolveImageInfo2) #extern;
vkCmdBeginRendering :: fn (commandBuffer: VkCommandBuffer, pRenderingInfo: *VkRenderingInfo) #extern;
vkCmdEndRendering :: fn (commandBuffer: VkCommandBuffer) #extern;
vkCmdSetCullMode :: fn (commandBuffer: VkCommandBuffer, cullMode: VkCullModeFlags) #extern;
vkCmdSetFrontFace :: fn (commandBuffer: VkCommandBuffer, frontFace: VkFrontFace) #extern;
vkCmdSetPrimitiveTopology :: fn (commandBuffer: VkCommandBuffer, primitiveTopology: VkPrimitiveTopology) #extern;
vkCmdSetViewportWithCount :: fn (commandBuffer: VkCommandBuffer, viewportCount: u32, pViewports: *VkViewport) #extern;
vkCmdSetScissorWithCount :: fn (commandBuffer: VkCommandBuffer, scissorCount: u32, pScissors: *VkRect2D) #extern;
vkCmdBindVertexBuffers2 :: fn (commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *VkBuffer, pOffsets: *VkDeviceSize, pSizes: *VkDeviceSize, pStrides: *VkDeviceSize) #extern;
vkCmdSetDepthTestEnable :: fn (commandBuffer: VkCommandBuffer, depthTestEnable: VkBool32) #extern;
vkCmdSetDepthWriteEnable :: fn (commandBuffer: VkCommandBuffer, depthWriteEnable: VkBool32) #extern;
vkCmdSetDepthCompareOp :: fn (commandBuffer: VkCommandBuffer, depthCompareOp: VkCompareOp) #extern;
vkCmdSetDepthBoundsTestEnable :: fn (commandBuffer: VkCommandBuffer, depthBoundsTestEnable: VkBool32) #extern;
vkCmdSetStencilTestEnable :: fn (commandBuffer: VkCommandBuffer, stencilTestEnable: VkBool32) #extern;
vkCmdSetStencilOp :: fn (commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, failOp: VkStencilOp, passOp: VkStencilOp, depthFailOp: VkStencilOp, compareOp: VkCompareOp) #extern;
vkCmdSetRasterizerDiscardEnable :: fn (commandBuffer: VkCommandBuffer, rasterizerDiscardEnable: VkBool32) #extern;
vkCmdSetDepthBiasEnable :: fn (commandBuffer: VkCommandBuffer, depthBiasEnable: VkBool32) #extern;
vkCmdSetPrimitiveRestartEnable :: fn (commandBuffer: VkCommandBuffer, primitiveRestartEnable: VkBool32) #extern;
vkGetDeviceBufferMemoryRequirements :: fn (device: VkDevice, pInfo: *VkDeviceBufferMemoryRequirements, pMemoryRequirements: *VkMemoryRequirements2) #extern;
vkGetDeviceImageMemoryRequirements :: fn (device: VkDevice, pInfo: *VkDeviceImageMemoryRequirements, pMemoryRequirements: *VkMemoryRequirements2) #extern;
vkGetDeviceImageSparseMemoryRequirements :: fn (device: VkDevice, pInfo: *VkDeviceImageMemoryRequirements, pSparseMemoryRequirementCount: *u32, pSparseMemoryRequirements: *VkSparseImageMemoryRequirements2) #extern;
VkPresentModeKHR :: enum s32 {
	VK_PRESENT_MODE_IMMEDIATE_KHR = 0x0;
	VK_PRESENT_MODE_MAILBOX_KHR = 0x1;
	VK_PRESENT_MODE_FIFO_KHR = 0x2;
	VK_PRESENT_MODE_FIFO_RELAXED_KHR = 0x3;
	VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = 0x3b9c7b98;
	VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = 0x3b9c7b99;
	VK_PRESENT_MODE_MAX_ENUM_KHR = 0x7fffffff;
}
VkColorSpaceKHR :: enum s32 {
	VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0x0;
	VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = 0x3b9c6041;
	VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = 0x3b9c6042;
	VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT = 0x3b9c6043;
	VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT = 0x3b9c6044;
	VK_COLOR_SPACE_BT709_LINEAR_EXT = 0x3b9c6045;
	VK_COLOR_SPACE_BT709_NONLINEAR_EXT = 0x3b9c6046;
	VK_COLOR_SPACE_BT2020_LINEAR_EXT = 0x3b9c6047;
	VK_COLOR_SPACE_HDR10_ST2084_EXT = 0x3b9c6048;
	VK_COLOR_SPACE_DOLBYVISION_EXT = 0x3b9c6049;
	VK_COLOR_SPACE_HDR10_HLG_EXT = 0x3b9c604a;
	VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT = 0x3b9c604b;
	VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = 0x3b9c604c;
	VK_COLOR_SPACE_PASS_THROUGH_EXT = 0x3b9c604d;
	VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = 0x3b9c604e;
	VK_COLOR_SPACE_DISPLAY_NATIVE_AMD = 0x3b9e0a08;
	VK_COLORSPACE_SRGB_NONLINEAR_KHR = 0x0;
	VK_COLOR_SPACE_DCI_P3_LINEAR_EXT = 0x3b9c6043;
	VK_COLOR_SPACE_MAX_ENUM_KHR = 0x7fffffff;
}
VkSurfaceTransformFlagBitsKHR :: enum s32 {
	VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 0x1;
	VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 0x2;
	VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 0x4;
	VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 0x8;
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 0x10;
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 0x20;
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 0x40;
	VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 0x80;
	VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 0x100;
	VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff;
}
VkCompositeAlphaFlagBitsKHR :: enum s32 {
	VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 0x1;
	VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 0x2;
	VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 0x4;
	VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 0x8;
	VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff;
}
VkCompositeAlphaFlagsKHR :: VkFlags;
VkSurfaceTransformFlagsKHR :: VkFlags;
VkSurfaceCapabilitiesKHR :: struct {
	minImageCount: u32;
	maxImageCount: u32;
	currentExtent: VkExtent2D;
	minImageExtent: VkExtent2D;
	maxImageExtent: VkExtent2D;
	maxImageArrayLayers: u32;
	supportedTransforms: VkSurfaceTransformFlagsKHR;
	currentTransform: VkSurfaceTransformFlagBitsKHR;
	supportedCompositeAlpha: VkCompositeAlphaFlagsKHR;
	supportedUsageFlags: VkImageUsageFlags;
}
VkSurfaceFormatKHR :: struct {
	format: VkFormat;
	colorSpace: VkColorSpaceKHR;
}
PFN_vkDestroySurfaceKHR :: *fn (VkInstance, VkSurfaceKHR, *VkAllocationCallbacks);
PFN_vkGetPhysicalDeviceSurfaceSupportKHR :: *fn (VkPhysicalDevice, u32, VkSurfaceKHR, *VkBool32) VkResult;
PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR :: *fn (VkPhysicalDevice, VkSurfaceKHR, *VkSurfaceCapabilitiesKHR) VkResult;
PFN_vkGetPhysicalDeviceSurfaceFormatsKHR :: *fn (VkPhysicalDevice, VkSurfaceKHR, *u32, *VkSurfaceFormatKHR) VkResult;
PFN_vkGetPhysicalDeviceSurfacePresentModesKHR :: *fn (VkPhysicalDevice, VkSurfaceKHR, *u32, *VkPresentModeKHR) VkResult;
vkDestroySurfaceKHR :: fn (instance: VkInstance, surface: VkSurfaceKHR, pAllocator: *VkAllocationCallbacks) #extern;
vkGetPhysicalDeviceSurfaceSupportKHR :: fn (physicalDevice: VkPhysicalDevice, queueFamilyIndex: u32, surface: VkSurfaceKHR, pSupported: *VkBool32) VkResult #extern;
vkGetPhysicalDeviceSurfaceCapabilitiesKHR :: fn (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceCapabilities: *VkSurfaceCapabilitiesKHR) VkResult #extern;
vkGetPhysicalDeviceSurfaceFormatsKHR :: fn (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceFormatCount: *u32, pSurfaceFormats: *VkSurfaceFormatKHR) VkResult #extern;
vkGetPhysicalDeviceSurfacePresentModesKHR :: fn (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pPresentModeCount: *u32, pPresentModes: *VkPresentModeKHR) VkResult #extern;
VkSwapchainCreateFlagBitsKHR :: enum s32 {
	VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = 0x1;
	VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = 0x2;
	VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR = 0x4;
	VK_SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff;
}
VkSwapchainCreateFlagsKHR :: VkFlags;
VkDeviceGroupPresentModeFlagBitsKHR :: enum s32 {
	VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR = 0x1;
	VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR = 0x2;
	VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR = 0x4;
	VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR = 0x8;
	VK_DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff;
}
VkDeviceGroupPresentModeFlagsKHR :: VkFlags;
VkSwapchainCreateInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkSwapchainCreateFlagsKHR;
	surface: VkSurfaceKHR;
	minImageCount: u32;
	imageFormat: VkFormat;
	imageColorSpace: VkColorSpaceKHR;
	imageExtent: VkExtent2D;
	imageArrayLayers: u32;
	imageUsage: VkImageUsageFlags;
	imageSharingMode: VkSharingMode;
	queueFamilyIndexCount: u32;
	pQueueFamilyIndices: *u32;
	preTransform: VkSurfaceTransformFlagBitsKHR;
	compositeAlpha: VkCompositeAlphaFlagBitsKHR;
	presentMode: VkPresentModeKHR;
	clipped: VkBool32;
	oldSwapchain: VkSwapchainKHR;
}
VkPresentInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	waitSemaphoreCount: u32;
	pWaitSemaphores: *VkSemaphore;
	swapchainCount: u32;
	pSwapchains: *VkSwapchainKHR;
	pImageIndices: *u32;
	pResults: *VkResult;
}
VkImageSwapchainCreateInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	swapchain: VkSwapchainKHR;
}
VkBindImageMemorySwapchainInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	swapchain: VkSwapchainKHR;
	imageIndex: u32;
}
VkAcquireNextImageInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	swapchain: VkSwapchainKHR;
	timeout: u64;
	semaphore: VkSemaphore;
	fence: VkFence;
	deviceMask: u32;
}
VkDeviceGroupPresentCapabilitiesKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	presentMask: [32]u32;
	modes: VkDeviceGroupPresentModeFlagsKHR;
}
VkDeviceGroupPresentInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	swapchainCount: u32;
	pDeviceMasks: *u32;
	mode: VkDeviceGroupPresentModeFlagBitsKHR;
}
VkDeviceGroupSwapchainCreateInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	modes: VkDeviceGroupPresentModeFlagsKHR;
}
PFN_vkCreateSwapchainKHR :: *fn (VkDevice, *VkSwapchainCreateInfoKHR, *VkAllocationCallbacks, *VkSwapchainKHR) VkResult;
PFN_vkDestroySwapchainKHR :: *fn (VkDevice, VkSwapchainKHR, *VkAllocationCallbacks);
PFN_vkGetSwapchainImagesKHR :: *fn (VkDevice, VkSwapchainKHR, *u32, *VkImage) VkResult;
PFN_vkAcquireNextImageKHR :: *fn (VkDevice, VkSwapchainKHR, u64, VkSemaphore, VkFence, *u32) VkResult;
PFN_vkQueuePresentKHR :: *fn (VkQueue, *VkPresentInfoKHR) VkResult;
PFN_vkGetDeviceGroupPresentCapabilitiesKHR :: *fn (VkDevice, *VkDeviceGroupPresentCapabilitiesKHR) VkResult;
PFN_vkGetDeviceGroupSurfacePresentModesKHR :: *fn (VkDevice, VkSurfaceKHR, *VkDeviceGroupPresentModeFlagsKHR) VkResult;
PFN_vkGetPhysicalDevicePresentRectanglesKHR :: *fn (VkPhysicalDevice, VkSurfaceKHR, *u32, *VkRect2D) VkResult;
PFN_vkAcquireNextImage2KHR :: *fn (VkDevice, *VkAcquireNextImageInfoKHR, *u32) VkResult;
vkCreateSwapchainKHR :: fn (device: VkDevice, pCreateInfo: *VkSwapchainCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pSwapchain: *VkSwapchainKHR) VkResult #extern;
vkDestroySwapchainKHR :: fn (device: VkDevice, swapchain: VkSwapchainKHR, pAllocator: *VkAllocationCallbacks) #extern;
vkGetSwapchainImagesKHR :: fn (device: VkDevice, swapchain: VkSwapchainKHR, pSwapchainImageCount: *u32, pSwapchainImages: *VkImage) VkResult #extern;
vkAcquireNextImageKHR :: fn (device: VkDevice, swapchain: VkSwapchainKHR, timeout: u64, semaphore: VkSemaphore, fence: VkFence, pImageIndex: *u32) VkResult #extern;
vkQueuePresentKHR :: fn (queue: VkQueue, pPresentInfo: *VkPresentInfoKHR) VkResult #extern;
vkGetDeviceGroupPresentCapabilitiesKHR :: fn (device: VkDevice, pDeviceGroupPresentCapabilities: *VkDeviceGroupPresentCapabilitiesKHR) VkResult #extern;
vkGetDeviceGroupSurfacePresentModesKHR :: fn (device: VkDevice, surface: VkSurfaceKHR, pModes: *VkDeviceGroupPresentModeFlagsKHR) VkResult #extern;
vkGetPhysicalDevicePresentRectanglesKHR :: fn (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pRectCount: *u32, pRects: *VkRect2D) VkResult #extern;
vkAcquireNextImage2KHR :: fn (device: VkDevice, pAcquireInfo: *VkAcquireNextImageInfoKHR, pImageIndex: *u32) VkResult #extern;
VkDisplayModeCreateFlagsKHR :: VkFlags;
VkDisplayPlaneAlphaFlagBitsKHR :: enum s32 {
	VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 0x1;
	VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 0x2;
	VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 0x4;
	VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 0x8;
	VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff;
}
VkDisplayPlaneAlphaFlagsKHR :: VkFlags;
VkDisplaySurfaceCreateFlagsKHR :: VkFlags;
VkDisplayModeParametersKHR :: struct {
	visibleRegion: VkExtent2D;
	refreshRate: u32;
}
VkDisplayModeCreateInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkDisplayModeCreateFlagsKHR;
	parameters: VkDisplayModeParametersKHR;
}
VkDisplayModePropertiesKHR :: struct {
	displayMode: VkDisplayModeKHR;
	parameters: VkDisplayModeParametersKHR;
}
VkDisplayPlaneCapabilitiesKHR :: struct {
	supportedAlpha: VkDisplayPlaneAlphaFlagsKHR;
	minSrcPosition: VkOffset2D;
	maxSrcPosition: VkOffset2D;
	minSrcExtent: VkExtent2D;
	maxSrcExtent: VkExtent2D;
	minDstPosition: VkOffset2D;
	maxDstPosition: VkOffset2D;
	minDstExtent: VkExtent2D;
	maxDstExtent: VkExtent2D;
}
VkDisplayPlanePropertiesKHR :: struct {
	currentDisplay: VkDisplayKHR;
	currentStackIndex: u32;
}
VkDisplayPropertiesKHR :: struct {
	display: VkDisplayKHR;
	displayName: *C.char;
	physicalDimensions: VkExtent2D;
	physicalResolution: VkExtent2D;
	supportedTransforms: VkSurfaceTransformFlagsKHR;
	planeReorderPossible: VkBool32;
	persistentContent: VkBool32;
}
VkDisplaySurfaceCreateInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkDisplaySurfaceCreateFlagsKHR;
	displayMode: VkDisplayModeKHR;
	planeIndex: u32;
	planeStackIndex: u32;
	transform: VkSurfaceTransformFlagBitsKHR;
	globalAlpha: f32;
	alphaMode: VkDisplayPlaneAlphaFlagBitsKHR;
	imageExtent: VkExtent2D;
}
PFN_vkGetPhysicalDeviceDisplayPropertiesKHR :: *fn (VkPhysicalDevice, *u32, *VkDisplayPropertiesKHR) VkResult;
PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR :: *fn (VkPhysicalDevice, *u32, *VkDisplayPlanePropertiesKHR) VkResult;
PFN_vkGetDisplayPlaneSupportedDisplaysKHR :: *fn (VkPhysicalDevice, u32, *u32, *VkDisplayKHR) VkResult;
PFN_vkGetDisplayModePropertiesKHR :: *fn (VkPhysicalDevice, VkDisplayKHR, *u32, *VkDisplayModePropertiesKHR) VkResult;
PFN_vkCreateDisplayModeKHR :: *fn (VkPhysicalDevice, VkDisplayKHR, *VkDisplayModeCreateInfoKHR, *VkAllocationCallbacks, *VkDisplayModeKHR) VkResult;
PFN_vkGetDisplayPlaneCapabilitiesKHR :: *fn (VkPhysicalDevice, VkDisplayModeKHR, u32, *VkDisplayPlaneCapabilitiesKHR) VkResult;
PFN_vkCreateDisplayPlaneSurfaceKHR :: *fn (VkInstance, *VkDisplaySurfaceCreateInfoKHR, *VkAllocationCallbacks, *VkSurfaceKHR) VkResult;
vkGetPhysicalDeviceDisplayPropertiesKHR :: fn (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkDisplayPropertiesKHR) VkResult #extern;
vkGetPhysicalDeviceDisplayPlanePropertiesKHR :: fn (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkDisplayPlanePropertiesKHR) VkResult #extern;
vkGetDisplayPlaneSupportedDisplaysKHR :: fn (physicalDevice: VkPhysicalDevice, planeIndex: u32, pDisplayCount: *u32, pDisplays: *VkDisplayKHR) VkResult #extern;
vkGetDisplayModePropertiesKHR :: fn (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR, pPropertyCount: *u32, pProperties: *VkDisplayModePropertiesKHR) VkResult #extern;
vkCreateDisplayModeKHR :: fn (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR, pCreateInfo: *VkDisplayModeCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pMode: *VkDisplayModeKHR) VkResult #extern;
vkGetDisplayPlaneCapabilitiesKHR :: fn (physicalDevice: VkPhysicalDevice, mode: VkDisplayModeKHR, planeIndex: u32, pCapabilities: *VkDisplayPlaneCapabilitiesKHR) VkResult #extern;
vkCreateDisplayPlaneSurfaceKHR :: fn (instance: VkInstance, pCreateInfo: *VkDisplaySurfaceCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pSurface: *VkSurfaceKHR) VkResult #extern;
VkDisplayPresentInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	srcRect: VkRect2D;
	dstRect: VkRect2D;
	persistent: VkBool32;
}
PFN_vkCreateSharedSwapchainsKHR :: *fn (VkDevice, u32, *VkSwapchainCreateInfoKHR, *VkAllocationCallbacks, *VkSwapchainKHR) VkResult;
vkCreateSharedSwapchainsKHR :: fn (device: VkDevice, swapchainCount: u32, pCreateInfos: *VkSwapchainCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pSwapchains: *VkSwapchainKHR) VkResult #extern;
VkRenderingFlagsKHR :: VkRenderingFlags;
VkRenderingFlagBitsKHR :: VkRenderingFlagBits;
VkRenderingInfoKHR :: VkRenderingInfo;
VkRenderingAttachmentInfoKHR :: VkRenderingAttachmentInfo;
VkPipelineRenderingCreateInfoKHR :: VkPipelineRenderingCreateInfo;
VkPhysicalDeviceDynamicRenderingFeaturesKHR :: VkPhysicalDeviceDynamicRenderingFeatures;
VkCommandBufferInheritanceRenderingInfoKHR :: VkCommandBufferInheritanceRenderingInfo;
VkRenderingFragmentShadingRateAttachmentInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	imageView: VkImageView;
	imageLayout: VkImageLayout;
	shadingRateAttachmentTexelSize: VkExtent2D;
}
VkRenderingFragmentDensityMapAttachmentInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	imageView: VkImageView;
	imageLayout: VkImageLayout;
}
VkAttachmentSampleCountInfoAMD :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	colorAttachmentCount: u32;
	pColorAttachmentSamples: *VkSampleCountFlagBits;
	depthStencilAttachmentSamples: VkSampleCountFlagBits;
}
VkAttachmentSampleCountInfoNV :: VkAttachmentSampleCountInfoAMD;
VkMultiviewPerViewAttributesInfoNVX :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	perViewAttributes: VkBool32;
	perViewAttributesPositionXOnly: VkBool32;
}
PFN_vkCmdBeginRenderingKHR :: *fn (VkCommandBuffer, *VkRenderingInfo);
PFN_vkCmdEndRenderingKHR :: *fn (VkCommandBuffer);
vkCmdBeginRenderingKHR :: fn (commandBuffer: VkCommandBuffer, pRenderingInfo: *VkRenderingInfo) #extern;
vkCmdEndRenderingKHR :: fn (commandBuffer: VkCommandBuffer) #extern;
VkRenderPassMultiviewCreateInfoKHR :: VkRenderPassMultiviewCreateInfo;
VkPhysicalDeviceMultiviewFeaturesKHR :: VkPhysicalDeviceMultiviewFeatures;
VkPhysicalDeviceMultiviewPropertiesKHR :: VkPhysicalDeviceMultiviewProperties;
VkPhysicalDeviceFeatures2KHR :: VkPhysicalDeviceFeatures2;
VkPhysicalDeviceProperties2KHR :: VkPhysicalDeviceProperties2;
VkFormatProperties2KHR :: VkFormatProperties2;
VkImageFormatProperties2KHR :: VkImageFormatProperties2;
VkPhysicalDeviceImageFormatInfo2KHR :: VkPhysicalDeviceImageFormatInfo2;
VkQueueFamilyProperties2KHR :: VkQueueFamilyProperties2;
VkPhysicalDeviceMemoryProperties2KHR :: VkPhysicalDeviceMemoryProperties2;
VkSparseImageFormatProperties2KHR :: VkSparseImageFormatProperties2;
VkPhysicalDeviceSparseImageFormatInfo2KHR :: VkPhysicalDeviceSparseImageFormatInfo2;
PFN_vkGetPhysicalDeviceFeatures2KHR :: *fn (VkPhysicalDevice, *VkPhysicalDeviceFeatures2);
PFN_vkGetPhysicalDeviceProperties2KHR :: *fn (VkPhysicalDevice, *VkPhysicalDeviceProperties2);
PFN_vkGetPhysicalDeviceFormatProperties2KHR :: *fn (VkPhysicalDevice, VkFormat, *VkFormatProperties2);
PFN_vkGetPhysicalDeviceImageFormatProperties2KHR :: *fn (VkPhysicalDevice, *VkPhysicalDeviceImageFormatInfo2, *VkImageFormatProperties2) VkResult;
PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR :: *fn (VkPhysicalDevice, *u32, *VkQueueFamilyProperties2);
PFN_vkGetPhysicalDeviceMemoryProperties2KHR :: *fn (VkPhysicalDevice, *VkPhysicalDeviceMemoryProperties2);
PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR :: *fn (VkPhysicalDevice, *VkPhysicalDeviceSparseImageFormatInfo2, *u32, *VkSparseImageFormatProperties2);
vkGetPhysicalDeviceFeatures2KHR :: fn (physicalDevice: VkPhysicalDevice, pFeatures: *VkPhysicalDeviceFeatures2) #extern;
vkGetPhysicalDeviceProperties2KHR :: fn (physicalDevice: VkPhysicalDevice, pProperties: *VkPhysicalDeviceProperties2) #extern;
vkGetPhysicalDeviceFormatProperties2KHR :: fn (physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *VkFormatProperties2) #extern;
vkGetPhysicalDeviceImageFormatProperties2KHR :: fn (physicalDevice: VkPhysicalDevice, pImageFormatInfo: *VkPhysicalDeviceImageFormatInfo2, pImageFormatProperties: *VkImageFormatProperties2) VkResult #extern;
vkGetPhysicalDeviceQueueFamilyProperties2KHR :: fn (physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *u32, pQueueFamilyProperties: *VkQueueFamilyProperties2) #extern;
vkGetPhysicalDeviceMemoryProperties2KHR :: fn (physicalDevice: VkPhysicalDevice, pMemoryProperties: *VkPhysicalDeviceMemoryProperties2) #extern;
vkGetPhysicalDeviceSparseImageFormatProperties2KHR :: fn (physicalDevice: VkPhysicalDevice, pFormatInfo: *VkPhysicalDeviceSparseImageFormatInfo2, pPropertyCount: *u32, pProperties: *VkSparseImageFormatProperties2) #extern;
VkPeerMemoryFeatureFlagsKHR :: VkPeerMemoryFeatureFlags;
VkPeerMemoryFeatureFlagBitsKHR :: VkPeerMemoryFeatureFlagBits;
VkMemoryAllocateFlagsKHR :: VkMemoryAllocateFlags;
VkMemoryAllocateFlagBitsKHR :: VkMemoryAllocateFlagBits;
VkMemoryAllocateFlagsInfoKHR :: VkMemoryAllocateFlagsInfo;
VkDeviceGroupRenderPassBeginInfoKHR :: VkDeviceGroupRenderPassBeginInfo;
VkDeviceGroupCommandBufferBeginInfoKHR :: VkDeviceGroupCommandBufferBeginInfo;
VkDeviceGroupSubmitInfoKHR :: VkDeviceGroupSubmitInfo;
VkDeviceGroupBindSparseInfoKHR :: VkDeviceGroupBindSparseInfo;
VkBindBufferMemoryDeviceGroupInfoKHR :: VkBindBufferMemoryDeviceGroupInfo;
VkBindImageMemoryDeviceGroupInfoKHR :: VkBindImageMemoryDeviceGroupInfo;
PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR :: *fn (VkDevice, u32, u32, u32, *VkPeerMemoryFeatureFlags);
PFN_vkCmdSetDeviceMaskKHR :: *fn (VkCommandBuffer, u32);
PFN_vkCmdDispatchBaseKHR :: *fn (VkCommandBuffer, u32, u32, u32, u32, u32, u32);
vkGetDeviceGroupPeerMemoryFeaturesKHR :: fn (device: VkDevice, heapIndex: u32, localDeviceIndex: u32, remoteDeviceIndex: u32, pPeerMemoryFeatures: *VkPeerMemoryFeatureFlags) #extern;
vkCmdSetDeviceMaskKHR :: fn (commandBuffer: VkCommandBuffer, deviceMask: u32) #extern;
vkCmdDispatchBaseKHR :: fn (commandBuffer: VkCommandBuffer, baseGroupX: u32, baseGroupY: u32, baseGroupZ: u32, groupCountX: u32, groupCountY: u32, groupCountZ: u32) #extern;
VkCommandPoolTrimFlagsKHR :: VkCommandPoolTrimFlags;
PFN_vkTrimCommandPoolKHR :: *fn (VkDevice, VkCommandPool, VkCommandPoolTrimFlags);
vkTrimCommandPoolKHR :: fn (device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolTrimFlags) #extern;
VkPhysicalDeviceGroupPropertiesKHR :: VkPhysicalDeviceGroupProperties;
VkDeviceGroupDeviceCreateInfoKHR :: VkDeviceGroupDeviceCreateInfo;
PFN_vkEnumeratePhysicalDeviceGroupsKHR :: *fn (VkInstance, *u32, *VkPhysicalDeviceGroupProperties) VkResult;
vkEnumeratePhysicalDeviceGroupsKHR :: fn (instance: VkInstance, pPhysicalDeviceGroupCount: *u32, pPhysicalDeviceGroupProperties: *VkPhysicalDeviceGroupProperties) VkResult #extern;
VkExternalMemoryHandleTypeFlagsKHR :: VkExternalMemoryHandleTypeFlags;
VkExternalMemoryHandleTypeFlagBitsKHR :: VkExternalMemoryHandleTypeFlagBits;
VkExternalMemoryFeatureFlagsKHR :: VkExternalMemoryFeatureFlags;
VkExternalMemoryFeatureFlagBitsKHR :: VkExternalMemoryFeatureFlagBits;
VkExternalMemoryPropertiesKHR :: VkExternalMemoryProperties;
VkPhysicalDeviceExternalImageFormatInfoKHR :: VkPhysicalDeviceExternalImageFormatInfo;
VkExternalImageFormatPropertiesKHR :: VkExternalImageFormatProperties;
VkPhysicalDeviceExternalBufferInfoKHR :: VkPhysicalDeviceExternalBufferInfo;
VkExternalBufferPropertiesKHR :: VkExternalBufferProperties;
VkPhysicalDeviceIDPropertiesKHR :: VkPhysicalDeviceIDProperties;
PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR :: *fn (VkPhysicalDevice, *VkPhysicalDeviceExternalBufferInfo, *VkExternalBufferProperties);
vkGetPhysicalDeviceExternalBufferPropertiesKHR :: fn (physicalDevice: VkPhysicalDevice, pExternalBufferInfo: *VkPhysicalDeviceExternalBufferInfo, pExternalBufferProperties: *VkExternalBufferProperties) #extern;
VkExternalMemoryImageCreateInfoKHR :: VkExternalMemoryImageCreateInfo;
VkExternalMemoryBufferCreateInfoKHR :: VkExternalMemoryBufferCreateInfo;
VkExportMemoryAllocateInfoKHR :: VkExportMemoryAllocateInfo;
VkImportMemoryFdInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	handleType: VkExternalMemoryHandleTypeFlagBits;
	fd: C.int;
}
VkMemoryFdPropertiesKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	memoryTypeBits: u32;
}
VkMemoryGetFdInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	memory: VkDeviceMemory;
	handleType: VkExternalMemoryHandleTypeFlagBits;
}
PFN_vkGetMemoryFdKHR :: *fn (VkDevice, *VkMemoryGetFdInfoKHR, *C.int) VkResult;
PFN_vkGetMemoryFdPropertiesKHR :: *fn (VkDevice, VkExternalMemoryHandleTypeFlagBits, C.int, *VkMemoryFdPropertiesKHR) VkResult;
vkGetMemoryFdKHR :: fn (device: VkDevice, pGetFdInfo: *VkMemoryGetFdInfoKHR, pFd: *C.int) VkResult #extern;
vkGetMemoryFdPropertiesKHR :: fn (device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, fd: C.int, pMemoryFdProperties: *VkMemoryFdPropertiesKHR) VkResult #extern;
VkExternalSemaphoreHandleTypeFlagsKHR :: VkExternalSemaphoreHandleTypeFlags;
VkExternalSemaphoreHandleTypeFlagBitsKHR :: VkExternalSemaphoreHandleTypeFlagBits;
VkExternalSemaphoreFeatureFlagsKHR :: VkExternalSemaphoreFeatureFlags;
VkExternalSemaphoreFeatureFlagBitsKHR :: VkExternalSemaphoreFeatureFlagBits;
VkPhysicalDeviceExternalSemaphoreInfoKHR :: VkPhysicalDeviceExternalSemaphoreInfo;
VkExternalSemaphorePropertiesKHR :: VkExternalSemaphoreProperties;
PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR :: *fn (VkPhysicalDevice, *VkPhysicalDeviceExternalSemaphoreInfo, *VkExternalSemaphoreProperties);
vkGetPhysicalDeviceExternalSemaphorePropertiesKHR :: fn (physicalDevice: VkPhysicalDevice, pExternalSemaphoreInfo: *VkPhysicalDeviceExternalSemaphoreInfo, pExternalSemaphoreProperties: *VkExternalSemaphoreProperties) #extern;
VkSemaphoreImportFlagsKHR :: VkSemaphoreImportFlags;
VkSemaphoreImportFlagBitsKHR :: VkSemaphoreImportFlagBits;
VkExportSemaphoreCreateInfoKHR :: VkExportSemaphoreCreateInfo;
VkImportSemaphoreFdInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	semaphore: VkSemaphore;
	flags: VkSemaphoreImportFlags;
	handleType: VkExternalSemaphoreHandleTypeFlagBits;
	fd: C.int;
}
VkSemaphoreGetFdInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	semaphore: VkSemaphore;
	handleType: VkExternalSemaphoreHandleTypeFlagBits;
}
PFN_vkImportSemaphoreFdKHR :: *fn (VkDevice, *VkImportSemaphoreFdInfoKHR) VkResult;
PFN_vkGetSemaphoreFdKHR :: *fn (VkDevice, *VkSemaphoreGetFdInfoKHR, *C.int) VkResult;
vkImportSemaphoreFdKHR :: fn (device: VkDevice, pImportSemaphoreFdInfo: *VkImportSemaphoreFdInfoKHR) VkResult #extern;
vkGetSemaphoreFdKHR :: fn (device: VkDevice, pGetFdInfo: *VkSemaphoreGetFdInfoKHR, pFd: *C.int) VkResult #extern;
VkPhysicalDevicePushDescriptorPropertiesKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	maxPushDescriptors: u32;
}
PFN_vkCmdPushDescriptorSetKHR :: *fn (VkCommandBuffer, VkPipelineBindPoint, VkPipelineLayout, u32, u32, *VkWriteDescriptorSet);
PFN_vkCmdPushDescriptorSetWithTemplateKHR :: *fn (VkCommandBuffer, VkDescriptorUpdateTemplate, VkPipelineLayout, u32, C.void_ptr);
vkCmdPushDescriptorSetKHR :: fn (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, layout: VkPipelineLayout, set: u32, descriptorWriteCount: u32, pDescriptorWrites: *VkWriteDescriptorSet) #extern;
vkCmdPushDescriptorSetWithTemplateKHR :: fn (commandBuffer: VkCommandBuffer, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, layout: VkPipelineLayout, set: u32, pData: C.void_ptr) #extern;
VkPhysicalDeviceShaderFloat16Int8FeaturesKHR :: VkPhysicalDeviceShaderFloat16Int8Features;
VkPhysicalDeviceFloat16Int8FeaturesKHR :: VkPhysicalDeviceShaderFloat16Int8Features;
VkPhysicalDevice16BitStorageFeaturesKHR :: VkPhysicalDevice16BitStorageFeatures;
VkRectLayerKHR :: struct {
	offset: VkOffset2D;
	extent: VkExtent2D;
	layer: u32;
}
VkPresentRegionKHR :: struct {
	rectangleCount: u32;
	pRectangles: *VkRectLayerKHR;
}
VkPresentRegionsKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	swapchainCount: u32;
	pRegions: *VkPresentRegionKHR;
}
VkDescriptorUpdateTemplateKHR :: VkDescriptorUpdateTemplate;
VkDescriptorUpdateTemplateTypeKHR :: VkDescriptorUpdateTemplateType;
VkDescriptorUpdateTemplateCreateFlagsKHR :: VkDescriptorUpdateTemplateCreateFlags;
VkDescriptorUpdateTemplateEntryKHR :: VkDescriptorUpdateTemplateEntry;
VkDescriptorUpdateTemplateCreateInfoKHR :: VkDescriptorUpdateTemplateCreateInfo;
PFN_vkCreateDescriptorUpdateTemplateKHR :: *fn (VkDevice, *VkDescriptorUpdateTemplateCreateInfo, *VkAllocationCallbacks, *VkDescriptorUpdateTemplate) VkResult;
PFN_vkDestroyDescriptorUpdateTemplateKHR :: *fn (VkDevice, VkDescriptorUpdateTemplate, *VkAllocationCallbacks);
PFN_vkUpdateDescriptorSetWithTemplateKHR :: *fn (VkDevice, VkDescriptorSet, VkDescriptorUpdateTemplate, C.void_ptr);
vkCreateDescriptorUpdateTemplateKHR :: fn (device: VkDevice, pCreateInfo: *VkDescriptorUpdateTemplateCreateInfo, pAllocator: *VkAllocationCallbacks, pDescriptorUpdateTemplate: *VkDescriptorUpdateTemplate) VkResult #extern;
vkDestroyDescriptorUpdateTemplateKHR :: fn (device: VkDevice, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pAllocator: *VkAllocationCallbacks) #extern;
vkUpdateDescriptorSetWithTemplateKHR :: fn (device: VkDevice, descriptorSet: VkDescriptorSet, descriptorUpdateTemplate: VkDescriptorUpdateTemplate, pData: C.void_ptr) #extern;
VkPhysicalDeviceImagelessFramebufferFeaturesKHR :: VkPhysicalDeviceImagelessFramebufferFeatures;
VkFramebufferAttachmentsCreateInfoKHR :: VkFramebufferAttachmentsCreateInfo;
VkFramebufferAttachmentImageInfoKHR :: VkFramebufferAttachmentImageInfo;
VkRenderPassAttachmentBeginInfoKHR :: VkRenderPassAttachmentBeginInfo;
VkRenderPassCreateInfo2KHR :: VkRenderPassCreateInfo2;
VkAttachmentDescription2KHR :: VkAttachmentDescription2;
VkAttachmentReference2KHR :: VkAttachmentReference2;
VkSubpassDescription2KHR :: VkSubpassDescription2;
VkSubpassDependency2KHR :: VkSubpassDependency2;
VkSubpassBeginInfoKHR :: VkSubpassBeginInfo;
VkSubpassEndInfoKHR :: VkSubpassEndInfo;
PFN_vkCreateRenderPass2KHR :: *fn (VkDevice, *VkRenderPassCreateInfo2, *VkAllocationCallbacks, *VkRenderPass) VkResult;
PFN_vkCmdBeginRenderPass2KHR :: *fn (VkCommandBuffer, *VkRenderPassBeginInfo, *VkSubpassBeginInfo);
PFN_vkCmdNextSubpass2KHR :: *fn (VkCommandBuffer, *VkSubpassBeginInfo, *VkSubpassEndInfo);
PFN_vkCmdEndRenderPass2KHR :: *fn (VkCommandBuffer, *VkSubpassEndInfo);
vkCreateRenderPass2KHR :: fn (device: VkDevice, pCreateInfo: *VkRenderPassCreateInfo2, pAllocator: *VkAllocationCallbacks, pRenderPass: *VkRenderPass) VkResult #extern;
vkCmdBeginRenderPass2KHR :: fn (commandBuffer: VkCommandBuffer, pRenderPassBegin: *VkRenderPassBeginInfo, pSubpassBeginInfo: *VkSubpassBeginInfo) #extern;
vkCmdNextSubpass2KHR :: fn (commandBuffer: VkCommandBuffer, pSubpassBeginInfo: *VkSubpassBeginInfo, pSubpassEndInfo: *VkSubpassEndInfo) #extern;
vkCmdEndRenderPass2KHR :: fn (commandBuffer: VkCommandBuffer, pSubpassEndInfo: *VkSubpassEndInfo) #extern;
VkSharedPresentSurfaceCapabilitiesKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	sharedPresentSupportedUsageFlags: VkImageUsageFlags;
}
PFN_vkGetSwapchainStatusKHR :: *fn (VkDevice, VkSwapchainKHR) VkResult;
vkGetSwapchainStatusKHR :: fn (device: VkDevice, swapchain: VkSwapchainKHR) VkResult #extern;
VkExternalFenceHandleTypeFlagsKHR :: VkExternalFenceHandleTypeFlags;
VkExternalFenceHandleTypeFlagBitsKHR :: VkExternalFenceHandleTypeFlagBits;
VkExternalFenceFeatureFlagsKHR :: VkExternalFenceFeatureFlags;
VkExternalFenceFeatureFlagBitsKHR :: VkExternalFenceFeatureFlagBits;
VkPhysicalDeviceExternalFenceInfoKHR :: VkPhysicalDeviceExternalFenceInfo;
VkExternalFencePropertiesKHR :: VkExternalFenceProperties;
PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR :: *fn (VkPhysicalDevice, *VkPhysicalDeviceExternalFenceInfo, *VkExternalFenceProperties);
vkGetPhysicalDeviceExternalFencePropertiesKHR :: fn (physicalDevice: VkPhysicalDevice, pExternalFenceInfo: *VkPhysicalDeviceExternalFenceInfo, pExternalFenceProperties: *VkExternalFenceProperties) #extern;
VkFenceImportFlagsKHR :: VkFenceImportFlags;
VkFenceImportFlagBitsKHR :: VkFenceImportFlagBits;
VkExportFenceCreateInfoKHR :: VkExportFenceCreateInfo;
VkImportFenceFdInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	fence: VkFence;
	flags: VkFenceImportFlags;
	handleType: VkExternalFenceHandleTypeFlagBits;
	fd: C.int;
}
VkFenceGetFdInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	fence: VkFence;
	handleType: VkExternalFenceHandleTypeFlagBits;
}
PFN_vkImportFenceFdKHR :: *fn (VkDevice, *VkImportFenceFdInfoKHR) VkResult;
PFN_vkGetFenceFdKHR :: *fn (VkDevice, *VkFenceGetFdInfoKHR, *C.int) VkResult;
vkImportFenceFdKHR :: fn (device: VkDevice, pImportFenceFdInfo: *VkImportFenceFdInfoKHR) VkResult #extern;
vkGetFenceFdKHR :: fn (device: VkDevice, pGetFdInfo: *VkFenceGetFdInfoKHR, pFd: *C.int) VkResult #extern;
VkPerformanceCounterUnitKHR :: enum s32 {
	VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR = 0x0;
	VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR = 0x1;
	VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR = 0x2;
	VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR = 0x3;
	VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR = 0x4;
	VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR = 0x5;
	VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR = 0x6;
	VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR = 0x7;
	VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR = 0x8;
	VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR = 0x9;
	VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR = 0xa;
	VK_PERFORMANCE_COUNTER_UNIT_MAX_ENUM_KHR = 0x7fffffff;
}
VkPerformanceCounterScopeKHR :: enum s32 {
	VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR = 0x0;
	VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR = 0x1;
	VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR = 0x2;
	VK_QUERY_SCOPE_COMMAND_BUFFER_KHR = 0x0;
	VK_QUERY_SCOPE_RENDER_PASS_KHR = 0x1;
	VK_QUERY_SCOPE_COMMAND_KHR = 0x2;
	VK_PERFORMANCE_COUNTER_SCOPE_MAX_ENUM_KHR = 0x7fffffff;
}
VkPerformanceCounterStorageKHR :: enum s32 {
	VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR = 0x0;
	VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR = 0x1;
	VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR = 0x2;
	VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR = 0x3;
	VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR = 0x4;
	VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR = 0x5;
	VK_PERFORMANCE_COUNTER_STORAGE_MAX_ENUM_KHR = 0x7fffffff;
}
VkPerformanceCounterDescriptionFlagBitsKHR :: enum s32 {
	VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR = 0x1;
	VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR = 0x2;
	VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR = 0x1;
	VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR = 0x2;
	VK_PERFORMANCE_COUNTER_DESCRIPTION_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff;
}
VkPerformanceCounterDescriptionFlagsKHR :: VkFlags;
VkAcquireProfilingLockFlagBitsKHR :: enum s32 {
	VK_ACQUIRE_PROFILING_LOCK_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff;
}
VkAcquireProfilingLockFlagsKHR :: VkFlags;
VkPhysicalDevicePerformanceQueryFeaturesKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	performanceCounterQueryPools: VkBool32;
	performanceCounterMultipleQueryPools: VkBool32;
}
VkPhysicalDevicePerformanceQueryPropertiesKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	allowCommandBufferQueryCopies: VkBool32;
}
VkPerformanceCounterKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	unit: VkPerformanceCounterUnitKHR;
	scope: VkPerformanceCounterScopeKHR;
	storage: VkPerformanceCounterStorageKHR;
	uuid: [16]u8;
}
VkPerformanceCounterDescriptionKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkPerformanceCounterDescriptionFlagsKHR;
	name: [256]C.char;
	category: [256]C.char;
	description: [256]C.char;
}
VkQueryPoolPerformanceCreateInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	queueFamilyIndex: u32;
	counterIndexCount: u32;
	pCounterIndices: *u32;
}
VkPerformanceCounterResultKHR :: union {
	int32: s32;
	int64: s64;
	uint32: u32;
	uint64: u64;
	float32: f32;
	float64: f64;
}
VkAcquireProfilingLockInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkAcquireProfilingLockFlagsKHR;
	timeout: u64;
}
VkPerformanceQuerySubmitInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	counterPassIndex: u32;
}
PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR :: *fn (VkPhysicalDevice, u32, *u32, *VkPerformanceCounterKHR, *VkPerformanceCounterDescriptionKHR) VkResult;
PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR :: *fn (VkPhysicalDevice, *VkQueryPoolPerformanceCreateInfoKHR, *u32);
PFN_vkAcquireProfilingLockKHR :: *fn (VkDevice, *VkAcquireProfilingLockInfoKHR) VkResult;
PFN_vkReleaseProfilingLockKHR :: *fn (VkDevice);
vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR :: fn (physicalDevice: VkPhysicalDevice, queueFamilyIndex: u32, pCounterCount: *u32, pCounters: *VkPerformanceCounterKHR, pCounterDescriptions: *VkPerformanceCounterDescriptionKHR) VkResult #extern;
vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR :: fn (physicalDevice: VkPhysicalDevice, pPerformanceQueryCreateInfo: *VkQueryPoolPerformanceCreateInfoKHR, pNumPasses: *u32) #extern;
vkAcquireProfilingLockKHR :: fn (device: VkDevice, pInfo: *VkAcquireProfilingLockInfoKHR) VkResult #extern;
vkReleaseProfilingLockKHR :: fn (device: VkDevice) #extern;
VkPointClippingBehaviorKHR :: VkPointClippingBehavior;
VkTessellationDomainOriginKHR :: VkTessellationDomainOrigin;
VkPhysicalDevicePointClippingPropertiesKHR :: VkPhysicalDevicePointClippingProperties;
VkRenderPassInputAttachmentAspectCreateInfoKHR :: VkRenderPassInputAttachmentAspectCreateInfo;
VkInputAttachmentAspectReferenceKHR :: VkInputAttachmentAspectReference;
VkImageViewUsageCreateInfoKHR :: VkImageViewUsageCreateInfo;
VkPipelineTessellationDomainOriginStateCreateInfoKHR :: VkPipelineTessellationDomainOriginStateCreateInfo;
VkPhysicalDeviceSurfaceInfo2KHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	surface: VkSurfaceKHR;
}
VkSurfaceCapabilities2KHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	surfaceCapabilities: VkSurfaceCapabilitiesKHR;
}
VkSurfaceFormat2KHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	surfaceFormat: VkSurfaceFormatKHR;
}
PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR :: *fn (VkPhysicalDevice, *VkPhysicalDeviceSurfaceInfo2KHR, *VkSurfaceCapabilities2KHR) VkResult;
PFN_vkGetPhysicalDeviceSurfaceFormats2KHR :: *fn (VkPhysicalDevice, *VkPhysicalDeviceSurfaceInfo2KHR, *u32, *VkSurfaceFormat2KHR) VkResult;
vkGetPhysicalDeviceSurfaceCapabilities2KHR :: fn (physicalDevice: VkPhysicalDevice, pSurfaceInfo: *VkPhysicalDeviceSurfaceInfo2KHR, pSurfaceCapabilities: *VkSurfaceCapabilities2KHR) VkResult #extern;
vkGetPhysicalDeviceSurfaceFormats2KHR :: fn (physicalDevice: VkPhysicalDevice, pSurfaceInfo: *VkPhysicalDeviceSurfaceInfo2KHR, pSurfaceFormatCount: *u32, pSurfaceFormats: *VkSurfaceFormat2KHR) VkResult #extern;
VkPhysicalDeviceVariablePointerFeaturesKHR :: VkPhysicalDeviceVariablePointersFeatures;
VkPhysicalDeviceVariablePointersFeaturesKHR :: VkPhysicalDeviceVariablePointersFeatures;
VkDisplayProperties2KHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	displayProperties: VkDisplayPropertiesKHR;
}
VkDisplayPlaneProperties2KHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	displayPlaneProperties: VkDisplayPlanePropertiesKHR;
}
VkDisplayModeProperties2KHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	displayModeProperties: VkDisplayModePropertiesKHR;
}
VkDisplayPlaneInfo2KHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	mode: VkDisplayModeKHR;
	planeIndex: u32;
}
VkDisplayPlaneCapabilities2KHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	capabilities: VkDisplayPlaneCapabilitiesKHR;
}
PFN_vkGetPhysicalDeviceDisplayProperties2KHR :: *fn (VkPhysicalDevice, *u32, *VkDisplayProperties2KHR) VkResult;
PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR :: *fn (VkPhysicalDevice, *u32, *VkDisplayPlaneProperties2KHR) VkResult;
PFN_vkGetDisplayModeProperties2KHR :: *fn (VkPhysicalDevice, VkDisplayKHR, *u32, *VkDisplayModeProperties2KHR) VkResult;
PFN_vkGetDisplayPlaneCapabilities2KHR :: *fn (VkPhysicalDevice, *VkDisplayPlaneInfo2KHR, *VkDisplayPlaneCapabilities2KHR) VkResult;
vkGetPhysicalDeviceDisplayProperties2KHR :: fn (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkDisplayProperties2KHR) VkResult #extern;
vkGetPhysicalDeviceDisplayPlaneProperties2KHR :: fn (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkDisplayPlaneProperties2KHR) VkResult #extern;
vkGetDisplayModeProperties2KHR :: fn (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR, pPropertyCount: *u32, pProperties: *VkDisplayModeProperties2KHR) VkResult #extern;
vkGetDisplayPlaneCapabilities2KHR :: fn (physicalDevice: VkPhysicalDevice, pDisplayPlaneInfo: *VkDisplayPlaneInfo2KHR, pCapabilities: *VkDisplayPlaneCapabilities2KHR) VkResult #extern;
VkMemoryDedicatedRequirementsKHR :: VkMemoryDedicatedRequirements;
VkMemoryDedicatedAllocateInfoKHR :: VkMemoryDedicatedAllocateInfo;
VkBufferMemoryRequirementsInfo2KHR :: VkBufferMemoryRequirementsInfo2;
VkImageMemoryRequirementsInfo2KHR :: VkImageMemoryRequirementsInfo2;
VkImageSparseMemoryRequirementsInfo2KHR :: VkImageSparseMemoryRequirementsInfo2;
VkMemoryRequirements2KHR :: VkMemoryRequirements2;
VkSparseImageMemoryRequirements2KHR :: VkSparseImageMemoryRequirements2;
PFN_vkGetImageMemoryRequirements2KHR :: *fn (VkDevice, *VkImageMemoryRequirementsInfo2, *VkMemoryRequirements2);
PFN_vkGetBufferMemoryRequirements2KHR :: *fn (VkDevice, *VkBufferMemoryRequirementsInfo2, *VkMemoryRequirements2);
PFN_vkGetImageSparseMemoryRequirements2KHR :: *fn (VkDevice, *VkImageSparseMemoryRequirementsInfo2, *u32, *VkSparseImageMemoryRequirements2);
vkGetImageMemoryRequirements2KHR :: fn (device: VkDevice, pInfo: *VkImageMemoryRequirementsInfo2, pMemoryRequirements: *VkMemoryRequirements2) #extern;
vkGetBufferMemoryRequirements2KHR :: fn (device: VkDevice, pInfo: *VkBufferMemoryRequirementsInfo2, pMemoryRequirements: *VkMemoryRequirements2) #extern;
vkGetImageSparseMemoryRequirements2KHR :: fn (device: VkDevice, pInfo: *VkImageSparseMemoryRequirementsInfo2, pSparseMemoryRequirementCount: *u32, pSparseMemoryRequirements: *VkSparseImageMemoryRequirements2) #extern;
VkImageFormatListCreateInfoKHR :: VkImageFormatListCreateInfo;
VkSamplerYcbcrConversionKHR :: VkSamplerYcbcrConversion;
VkSamplerYcbcrModelConversionKHR :: VkSamplerYcbcrModelConversion;
VkSamplerYcbcrRangeKHR :: VkSamplerYcbcrRange;
VkChromaLocationKHR :: VkChromaLocation;
VkSamplerYcbcrConversionCreateInfoKHR :: VkSamplerYcbcrConversionCreateInfo;
VkSamplerYcbcrConversionInfoKHR :: VkSamplerYcbcrConversionInfo;
VkBindImagePlaneMemoryInfoKHR :: VkBindImagePlaneMemoryInfo;
VkImagePlaneMemoryRequirementsInfoKHR :: VkImagePlaneMemoryRequirementsInfo;
VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR :: VkPhysicalDeviceSamplerYcbcrConversionFeatures;
VkSamplerYcbcrConversionImageFormatPropertiesKHR :: VkSamplerYcbcrConversionImageFormatProperties;
PFN_vkCreateSamplerYcbcrConversionKHR :: *fn (VkDevice, *VkSamplerYcbcrConversionCreateInfo, *VkAllocationCallbacks, *VkSamplerYcbcrConversion) VkResult;
PFN_vkDestroySamplerYcbcrConversionKHR :: *fn (VkDevice, VkSamplerYcbcrConversion, *VkAllocationCallbacks);
vkCreateSamplerYcbcrConversionKHR :: fn (device: VkDevice, pCreateInfo: *VkSamplerYcbcrConversionCreateInfo, pAllocator: *VkAllocationCallbacks, pYcbcrConversion: *VkSamplerYcbcrConversion) VkResult #extern;
vkDestroySamplerYcbcrConversionKHR :: fn (device: VkDevice, ycbcrConversion: VkSamplerYcbcrConversion, pAllocator: *VkAllocationCallbacks) #extern;
VkBindBufferMemoryInfoKHR :: VkBindBufferMemoryInfo;
VkBindImageMemoryInfoKHR :: VkBindImageMemoryInfo;
PFN_vkBindBufferMemory2KHR :: *fn (VkDevice, u32, *VkBindBufferMemoryInfo) VkResult;
PFN_vkBindImageMemory2KHR :: *fn (VkDevice, u32, *VkBindImageMemoryInfo) VkResult;
vkBindBufferMemory2KHR :: fn (device: VkDevice, bindInfoCount: u32, pBindInfos: *VkBindBufferMemoryInfo) VkResult #extern;
vkBindImageMemory2KHR :: fn (device: VkDevice, bindInfoCount: u32, pBindInfos: *VkBindImageMemoryInfo) VkResult #extern;
VkPhysicalDeviceMaintenance3PropertiesKHR :: VkPhysicalDeviceMaintenance3Properties;
VkDescriptorSetLayoutSupportKHR :: VkDescriptorSetLayoutSupport;
PFN_vkGetDescriptorSetLayoutSupportKHR :: *fn (VkDevice, *VkDescriptorSetLayoutCreateInfo, *VkDescriptorSetLayoutSupport);
vkGetDescriptorSetLayoutSupportKHR :: fn (device: VkDevice, pCreateInfo: *VkDescriptorSetLayoutCreateInfo, pSupport: *VkDescriptorSetLayoutSupport) #extern;
PFN_vkCmdDrawIndirectCountKHR :: *fn (VkCommandBuffer, VkBuffer, VkDeviceSize, VkBuffer, VkDeviceSize, u32, u32);
PFN_vkCmdDrawIndexedIndirectCountKHR :: *fn (VkCommandBuffer, VkBuffer, VkDeviceSize, VkBuffer, VkDeviceSize, u32, u32);
vkCmdDrawIndirectCountKHR :: fn (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) #extern;
vkCmdDrawIndexedIndirectCountKHR :: fn (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) #extern;
VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR :: VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures;
VkPhysicalDevice8BitStorageFeaturesKHR :: VkPhysicalDevice8BitStorageFeatures;
VkPhysicalDeviceShaderAtomicInt64FeaturesKHR :: VkPhysicalDeviceShaderAtomicInt64Features;
VkPhysicalDeviceShaderClockFeaturesKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shaderSubgroupClock: VkBool32;
	shaderDeviceClock: VkBool32;
}
VkQueueGlobalPriorityKHR :: enum s32 {
	VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR = 0x80;
	VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR = 0x100;
	VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR = 0x200;
	VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR = 0x400;
	VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT = 0x80;
	VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT = 0x100;
	VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT = 0x200;
	VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT = 0x400;
	VK_QUEUE_GLOBAL_PRIORITY_MAX_ENUM_KHR = 0x7fffffff;
}
VkDeviceQueueGlobalPriorityCreateInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	globalPriority: VkQueueGlobalPriorityKHR;
}
VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	globalPriorityQuery: VkBool32;
}
VkQueueFamilyGlobalPriorityPropertiesKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	priorityCount: u32;
	priorities: [16]VkQueueGlobalPriorityKHR;
}
VkDriverIdKHR :: VkDriverId;
VkConformanceVersionKHR :: VkConformanceVersion;
VkPhysicalDeviceDriverPropertiesKHR :: VkPhysicalDeviceDriverProperties;
VkShaderFloatControlsIndependenceKHR :: VkShaderFloatControlsIndependence;
VkPhysicalDeviceFloatControlsPropertiesKHR :: VkPhysicalDeviceFloatControlsProperties;
VkResolveModeFlagBitsKHR :: VkResolveModeFlagBits;
VkResolveModeFlagsKHR :: VkResolveModeFlags;
VkSubpassDescriptionDepthStencilResolveKHR :: VkSubpassDescriptionDepthStencilResolve;
VkPhysicalDeviceDepthStencilResolvePropertiesKHR :: VkPhysicalDeviceDepthStencilResolveProperties;
VkSemaphoreTypeKHR :: VkSemaphoreType;
VkSemaphoreWaitFlagBitsKHR :: VkSemaphoreWaitFlagBits;
VkSemaphoreWaitFlagsKHR :: VkSemaphoreWaitFlags;
VkPhysicalDeviceTimelineSemaphoreFeaturesKHR :: VkPhysicalDeviceTimelineSemaphoreFeatures;
VkPhysicalDeviceTimelineSemaphorePropertiesKHR :: VkPhysicalDeviceTimelineSemaphoreProperties;
VkSemaphoreTypeCreateInfoKHR :: VkSemaphoreTypeCreateInfo;
VkTimelineSemaphoreSubmitInfoKHR :: VkTimelineSemaphoreSubmitInfo;
VkSemaphoreWaitInfoKHR :: VkSemaphoreWaitInfo;
VkSemaphoreSignalInfoKHR :: VkSemaphoreSignalInfo;
PFN_vkGetSemaphoreCounterValueKHR :: *fn (VkDevice, VkSemaphore, *u64) VkResult;
PFN_vkWaitSemaphoresKHR :: *fn (VkDevice, *VkSemaphoreWaitInfo, u64) VkResult;
PFN_vkSignalSemaphoreKHR :: *fn (VkDevice, *VkSemaphoreSignalInfo) VkResult;
vkGetSemaphoreCounterValueKHR :: fn (device: VkDevice, semaphore: VkSemaphore, pValue: *u64) VkResult #extern;
vkWaitSemaphoresKHR :: fn (device: VkDevice, pWaitInfo: *VkSemaphoreWaitInfo, timeout: u64) VkResult #extern;
vkSignalSemaphoreKHR :: fn (device: VkDevice, pSignalInfo: *VkSemaphoreSignalInfo) VkResult #extern;
VkPhysicalDeviceVulkanMemoryModelFeaturesKHR :: VkPhysicalDeviceVulkanMemoryModelFeatures;
VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR :: VkPhysicalDeviceShaderTerminateInvocationFeatures;
VkFragmentShadingRateCombinerOpKHR :: enum s32 {
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR = 0x0;
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR = 0x1;
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR = 0x2;
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR = 0x3;
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR = 0x4;
	VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_ENUM_KHR = 0x7fffffff;
}
VkFragmentShadingRateAttachmentInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	pFragmentShadingRateAttachment: *VkAttachmentReference2;
	shadingRateAttachmentTexelSize: VkExtent2D;
}
VkPipelineFragmentShadingRateStateCreateInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	fragmentSize: VkExtent2D;
	combinerOps: [2]VkFragmentShadingRateCombinerOpKHR;
}
VkPhysicalDeviceFragmentShadingRateFeaturesKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	pipelineFragmentShadingRate: VkBool32;
	primitiveFragmentShadingRate: VkBool32;
	attachmentFragmentShadingRate: VkBool32;
}
VkPhysicalDeviceFragmentShadingRatePropertiesKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	minFragmentShadingRateAttachmentTexelSize: VkExtent2D;
	maxFragmentShadingRateAttachmentTexelSize: VkExtent2D;
	maxFragmentShadingRateAttachmentTexelSizeAspectRatio: u32;
	primitiveFragmentShadingRateWithMultipleViewports: VkBool32;
	layeredShadingRateAttachments: VkBool32;
	fragmentShadingRateNonTrivialCombinerOps: VkBool32;
	maxFragmentSize: VkExtent2D;
	maxFragmentSizeAspectRatio: u32;
	maxFragmentShadingRateCoverageSamples: u32;
	maxFragmentShadingRateRasterizationSamples: VkSampleCountFlagBits;
	fragmentShadingRateWithShaderDepthStencilWrites: VkBool32;
	fragmentShadingRateWithSampleMask: VkBool32;
	fragmentShadingRateWithShaderSampleMask: VkBool32;
	fragmentShadingRateWithConservativeRasterization: VkBool32;
	fragmentShadingRateWithFragmentShaderInterlock: VkBool32;
	fragmentShadingRateWithCustomSampleLocations: VkBool32;
	fragmentShadingRateStrictMultiplyCombiner: VkBool32;
}
VkPhysicalDeviceFragmentShadingRateKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	sampleCounts: VkSampleCountFlags;
	fragmentSize: VkExtent2D;
}
PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR :: *fn (VkPhysicalDevice, *u32, *VkPhysicalDeviceFragmentShadingRateKHR) VkResult;
PFN_vkCmdSetFragmentShadingRateKHR :: *fn (VkCommandBuffer, *VkExtent2D, [2]VkFragmentShadingRateCombinerOpKHR);
vkGetPhysicalDeviceFragmentShadingRatesKHR :: fn (physicalDevice: VkPhysicalDevice, pFragmentShadingRateCount: *u32, pFragmentShadingRates: *VkPhysicalDeviceFragmentShadingRateKHR) VkResult #extern;
vkCmdSetFragmentShadingRateKHR :: fn (commandBuffer: VkCommandBuffer, pFragmentSize: *VkExtent2D, combinerOps: [2]VkFragmentShadingRateCombinerOpKHR) #extern;
VkSurfaceProtectedCapabilitiesKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	supportsProtected: VkBool32;
}
VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR :: VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures;
VkAttachmentReferenceStencilLayoutKHR :: VkAttachmentReferenceStencilLayout;
VkAttachmentDescriptionStencilLayoutKHR :: VkAttachmentDescriptionStencilLayout;
VkPhysicalDevicePresentWaitFeaturesKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	presentWait: VkBool32;
}
PFN_vkWaitForPresentKHR :: *fn (VkDevice, VkSwapchainKHR, u64, u64) VkResult;
vkWaitForPresentKHR :: fn (device: VkDevice, swapchain: VkSwapchainKHR, presentId: u64, timeout: u64) VkResult #extern;
VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR :: VkPhysicalDeviceUniformBufferStandardLayoutFeatures;
VkPhysicalDeviceBufferDeviceAddressFeaturesKHR :: VkPhysicalDeviceBufferDeviceAddressFeatures;
VkBufferDeviceAddressInfoKHR :: VkBufferDeviceAddressInfo;
VkBufferOpaqueCaptureAddressCreateInfoKHR :: VkBufferOpaqueCaptureAddressCreateInfo;
VkMemoryOpaqueCaptureAddressAllocateInfoKHR :: VkMemoryOpaqueCaptureAddressAllocateInfo;
VkDeviceMemoryOpaqueCaptureAddressInfoKHR :: VkDeviceMemoryOpaqueCaptureAddressInfo;
PFN_vkGetBufferDeviceAddressKHR :: *fn (VkDevice, *VkBufferDeviceAddressInfo) VkDeviceAddress;
PFN_vkGetBufferOpaqueCaptureAddressKHR :: *fn (VkDevice, *VkBufferDeviceAddressInfo) u64;
PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR :: *fn (VkDevice, *VkDeviceMemoryOpaqueCaptureAddressInfo) u64;
vkGetBufferDeviceAddressKHR :: fn (device: VkDevice, pInfo: *VkBufferDeviceAddressInfo) VkDeviceAddress #extern;
vkGetBufferOpaqueCaptureAddressKHR :: fn (device: VkDevice, pInfo: *VkBufferDeviceAddressInfo) u64 #extern;
vkGetDeviceMemoryOpaqueCaptureAddressKHR :: fn (device: VkDevice, pInfo: *VkDeviceMemoryOpaqueCaptureAddressInfo) u64 #extern;
PFN_vkCreateDeferredOperationKHR :: *fn (VkDevice, *VkAllocationCallbacks, *VkDeferredOperationKHR) VkResult;
PFN_vkDestroyDeferredOperationKHR :: *fn (VkDevice, VkDeferredOperationKHR, *VkAllocationCallbacks);
PFN_vkGetDeferredOperationMaxConcurrencyKHR :: *fn (VkDevice, VkDeferredOperationKHR) u32;
PFN_vkGetDeferredOperationResultKHR :: *fn (VkDevice, VkDeferredOperationKHR) VkResult;
PFN_vkDeferredOperationJoinKHR :: *fn (VkDevice, VkDeferredOperationKHR) VkResult;
vkCreateDeferredOperationKHR :: fn (device: VkDevice, pAllocator: *VkAllocationCallbacks, pDeferredOperation: *VkDeferredOperationKHR) VkResult #extern;
vkDestroyDeferredOperationKHR :: fn (device: VkDevice, operation: VkDeferredOperationKHR, pAllocator: *VkAllocationCallbacks) #extern;
vkGetDeferredOperationMaxConcurrencyKHR :: fn (device: VkDevice, operation: VkDeferredOperationKHR) u32 #extern;
vkGetDeferredOperationResultKHR :: fn (device: VkDevice, operation: VkDeferredOperationKHR) VkResult #extern;
vkDeferredOperationJoinKHR :: fn (device: VkDevice, operation: VkDeferredOperationKHR) VkResult #extern;
VkPipelineExecutableStatisticFormatKHR :: enum s32 {
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR = 0x0;
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR = 0x1;
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR = 0x2;
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR = 0x3;
	VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_MAX_ENUM_KHR = 0x7fffffff;
}
VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	pipelineExecutableInfo: VkBool32;
}
VkPipelineInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	pipeline: VkPipeline;
}
VkPipelineExecutablePropertiesKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	stages: VkShaderStageFlags;
	name: [256]C.char;
	description: [256]C.char;
	subgroupSize: u32;
}
VkPipelineExecutableInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	pipeline: VkPipeline;
	executableIndex: u32;
}
VkPipelineExecutableStatisticValueKHR :: union {
	bool_32: VkBool32;
	int_64: s64;
	uint_64: u64;
	float_64: f64;
}
VkPipelineExecutableStatisticKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	name: [256]C.char;
	description: [256]C.char;
	format: VkPipelineExecutableStatisticFormatKHR;
	value: VkPipelineExecutableStatisticValueKHR;
}
VkPipelineExecutableInternalRepresentationKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	name: [256]C.char;
	description: [256]C.char;
	isText: VkBool32;
	dataSize: usize;
	pData: C.void_ptr;
}
PFN_vkGetPipelineExecutablePropertiesKHR :: *fn (VkDevice, *VkPipelineInfoKHR, *u32, *VkPipelineExecutablePropertiesKHR) VkResult;
PFN_vkGetPipelineExecutableStatisticsKHR :: *fn (VkDevice, *VkPipelineExecutableInfoKHR, *u32, *VkPipelineExecutableStatisticKHR) VkResult;
PFN_vkGetPipelineExecutableInternalRepresentationsKHR :: *fn (VkDevice, *VkPipelineExecutableInfoKHR, *u32, *VkPipelineExecutableInternalRepresentationKHR) VkResult;
vkGetPipelineExecutablePropertiesKHR :: fn (device: VkDevice, pPipelineInfo: *VkPipelineInfoKHR, pExecutableCount: *u32, pProperties: *VkPipelineExecutablePropertiesKHR) VkResult #extern;
vkGetPipelineExecutableStatisticsKHR :: fn (device: VkDevice, pExecutableInfo: *VkPipelineExecutableInfoKHR, pStatisticCount: *u32, pStatistics: *VkPipelineExecutableStatisticKHR) VkResult #extern;
vkGetPipelineExecutableInternalRepresentationsKHR :: fn (device: VkDevice, pExecutableInfo: *VkPipelineExecutableInfoKHR, pInternalRepresentationCount: *u32, pInternalRepresentations: *VkPipelineExecutableInternalRepresentationKHR) VkResult #extern;
VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR :: VkPhysicalDeviceShaderIntegerDotProductFeatures;
VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR :: VkPhysicalDeviceShaderIntegerDotProductProperties;
VkPipelineLibraryCreateInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	libraryCount: u32;
	pLibraries: *VkPipeline;
}
VkPresentIdKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	swapchainCount: u32;
	pPresentIds: *u64;
}
VkPhysicalDevicePresentIdFeaturesKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	presentId: VkBool32;
}
VkPipelineStageFlags2KHR :: VkPipelineStageFlags2;
VkPipelineStageFlagBits2KHR :: VkPipelineStageFlagBits2;
VkAccessFlags2KHR :: VkAccessFlags2;
VkAccessFlagBits2KHR :: VkAccessFlagBits2;
VkSubmitFlagBitsKHR :: VkSubmitFlagBits;
VkSubmitFlagsKHR :: VkSubmitFlags;
VkMemoryBarrier2KHR :: VkMemoryBarrier2;
VkBufferMemoryBarrier2KHR :: VkBufferMemoryBarrier2;
VkImageMemoryBarrier2KHR :: VkImageMemoryBarrier2;
VkDependencyInfoKHR :: VkDependencyInfo;
VkSubmitInfo2KHR :: VkSubmitInfo2;
VkSemaphoreSubmitInfoKHR :: VkSemaphoreSubmitInfo;
VkCommandBufferSubmitInfoKHR :: VkCommandBufferSubmitInfo;
VkPhysicalDeviceSynchronization2FeaturesKHR :: VkPhysicalDeviceSynchronization2Features;
VkQueueFamilyCheckpointProperties2NV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	checkpointExecutionStageMask: VkPipelineStageFlags2;
}
VkCheckpointData2NV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	stage: VkPipelineStageFlags2;
	pCheckpointMarker: C.void_ptr;
}
PFN_vkCmdSetEvent2KHR :: *fn (VkCommandBuffer, VkEvent, *VkDependencyInfo);
PFN_vkCmdResetEvent2KHR :: *fn (VkCommandBuffer, VkEvent, VkPipelineStageFlags2);
PFN_vkCmdWaitEvents2KHR :: *fn (VkCommandBuffer, u32, *VkEvent, *VkDependencyInfo);
PFN_vkCmdPipelineBarrier2KHR :: *fn (VkCommandBuffer, *VkDependencyInfo);
PFN_vkCmdWriteTimestamp2KHR :: *fn (VkCommandBuffer, VkPipelineStageFlags2, VkQueryPool, u32);
PFN_vkQueueSubmit2KHR :: *fn (VkQueue, u32, *VkSubmitInfo2, VkFence) VkResult;
PFN_vkCmdWriteBufferMarker2AMD :: *fn (VkCommandBuffer, VkPipelineStageFlags2, VkBuffer, VkDeviceSize, u32);
PFN_vkGetQueueCheckpointData2NV :: *fn (VkQueue, *u32, *VkCheckpointData2NV);
vkCmdSetEvent2KHR :: fn (commandBuffer: VkCommandBuffer, event: VkEvent, pDependencyInfo: *VkDependencyInfo) #extern;
vkCmdResetEvent2KHR :: fn (commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags2) #extern;
vkCmdWaitEvents2KHR :: fn (commandBuffer: VkCommandBuffer, eventCount: u32, pEvents: *VkEvent, pDependencyInfos: *VkDependencyInfo) #extern;
vkCmdPipelineBarrier2KHR :: fn (commandBuffer: VkCommandBuffer, pDependencyInfo: *VkDependencyInfo) #extern;
vkCmdWriteTimestamp2KHR :: fn (commandBuffer: VkCommandBuffer, stage: VkPipelineStageFlags2, queryPool: VkQueryPool, query: u32) #extern;
vkQueueSubmit2KHR :: fn (queue: VkQueue, submitCount: u32, pSubmits: *VkSubmitInfo2, fence: VkFence) VkResult #extern;
vkCmdWriteBufferMarker2AMD :: fn (commandBuffer: VkCommandBuffer, stage: VkPipelineStageFlags2, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, marker: u32) #extern;
vkGetQueueCheckpointData2NV :: fn (queue: VkQueue, pCheckpointDataCount: *u32, pCheckpointData: *VkCheckpointData2NV) #extern;
VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	fragmentShaderBarycentric: VkBool32;
}
VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	triStripVertexOrderIndependentOfProvokingVertex: VkBool32;
}
VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shaderSubgroupUniformControlFlow: VkBool32;
}
VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR :: VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures;
VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	workgroupMemoryExplicitLayout: VkBool32;
	workgroupMemoryExplicitLayoutScalarBlockLayout: VkBool32;
	workgroupMemoryExplicitLayout8BitAccess: VkBool32;
	workgroupMemoryExplicitLayout16BitAccess: VkBool32;
}
VkCopyBufferInfo2KHR :: VkCopyBufferInfo2;
VkCopyImageInfo2KHR :: VkCopyImageInfo2;
VkCopyBufferToImageInfo2KHR :: VkCopyBufferToImageInfo2;
VkCopyImageToBufferInfo2KHR :: VkCopyImageToBufferInfo2;
VkBlitImageInfo2KHR :: VkBlitImageInfo2;
VkResolveImageInfo2KHR :: VkResolveImageInfo2;
VkBufferCopy2KHR :: VkBufferCopy2;
VkImageCopy2KHR :: VkImageCopy2;
VkImageBlit2KHR :: VkImageBlit2;
VkBufferImageCopy2KHR :: VkBufferImageCopy2;
VkImageResolve2KHR :: VkImageResolve2;
PFN_vkCmdCopyBuffer2KHR :: *fn (VkCommandBuffer, *VkCopyBufferInfo2);
PFN_vkCmdCopyImage2KHR :: *fn (VkCommandBuffer, *VkCopyImageInfo2);
PFN_vkCmdCopyBufferToImage2KHR :: *fn (VkCommandBuffer, *VkCopyBufferToImageInfo2);
PFN_vkCmdCopyImageToBuffer2KHR :: *fn (VkCommandBuffer, *VkCopyImageToBufferInfo2);
PFN_vkCmdBlitImage2KHR :: *fn (VkCommandBuffer, *VkBlitImageInfo2);
PFN_vkCmdResolveImage2KHR :: *fn (VkCommandBuffer, *VkResolveImageInfo2);
vkCmdCopyBuffer2KHR :: fn (commandBuffer: VkCommandBuffer, pCopyBufferInfo: *VkCopyBufferInfo2) #extern;
vkCmdCopyImage2KHR :: fn (commandBuffer: VkCommandBuffer, pCopyImageInfo: *VkCopyImageInfo2) #extern;
vkCmdCopyBufferToImage2KHR :: fn (commandBuffer: VkCommandBuffer, pCopyBufferToImageInfo: *VkCopyBufferToImageInfo2) #extern;
vkCmdCopyImageToBuffer2KHR :: fn (commandBuffer: VkCommandBuffer, pCopyImageToBufferInfo: *VkCopyImageToBufferInfo2) #extern;
vkCmdBlitImage2KHR :: fn (commandBuffer: VkCommandBuffer, pBlitImageInfo: *VkBlitImageInfo2) #extern;
vkCmdResolveImage2KHR :: fn (commandBuffer: VkCommandBuffer, pResolveImageInfo: *VkResolveImageInfo2) #extern;
VkFormatFeatureFlags2KHR :: VkFormatFeatureFlags2;
VkFormatFeatureFlagBits2KHR :: VkFormatFeatureFlagBits2;
VkFormatProperties3KHR :: VkFormatProperties3;
VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	rayTracingMaintenance1: VkBool32;
	rayTracingPipelineTraceRaysIndirect2: VkBool32;
}
VkTraceRaysIndirectCommand2KHR :: struct {
	raygenShaderRecordAddress: VkDeviceAddress;
	raygenShaderRecordSize: VkDeviceSize;
	missShaderBindingTableAddress: VkDeviceAddress;
	missShaderBindingTableSize: VkDeviceSize;
	missShaderBindingTableStride: VkDeviceSize;
	hitShaderBindingTableAddress: VkDeviceAddress;
	hitShaderBindingTableSize: VkDeviceSize;
	hitShaderBindingTableStride: VkDeviceSize;
	callableShaderBindingTableAddress: VkDeviceAddress;
	callableShaderBindingTableSize: VkDeviceSize;
	callableShaderBindingTableStride: VkDeviceSize;
	width: u32;
	height: u32;
	depth: u32;
}
PFN_vkCmdTraceRaysIndirect2KHR :: *fn (VkCommandBuffer, VkDeviceAddress);
vkCmdTraceRaysIndirect2KHR :: fn (commandBuffer: VkCommandBuffer, indirectDeviceAddress: VkDeviceAddress) #extern;
VkPhysicalDeviceMaintenance4FeaturesKHR :: VkPhysicalDeviceMaintenance4Features;
VkPhysicalDeviceMaintenance4PropertiesKHR :: VkPhysicalDeviceMaintenance4Properties;
VkDeviceBufferMemoryRequirementsKHR :: VkDeviceBufferMemoryRequirements;
VkDeviceImageMemoryRequirementsKHR :: VkDeviceImageMemoryRequirements;
PFN_vkGetDeviceBufferMemoryRequirementsKHR :: *fn (VkDevice, *VkDeviceBufferMemoryRequirements, *VkMemoryRequirements2);
PFN_vkGetDeviceImageMemoryRequirementsKHR :: *fn (VkDevice, *VkDeviceImageMemoryRequirements, *VkMemoryRequirements2);
PFN_vkGetDeviceImageSparseMemoryRequirementsKHR :: *fn (VkDevice, *VkDeviceImageMemoryRequirements, *u32, *VkSparseImageMemoryRequirements2);
vkGetDeviceBufferMemoryRequirementsKHR :: fn (device: VkDevice, pInfo: *VkDeviceBufferMemoryRequirements, pMemoryRequirements: *VkMemoryRequirements2) #extern;
vkGetDeviceImageMemoryRequirementsKHR :: fn (device: VkDevice, pInfo: *VkDeviceImageMemoryRequirements, pMemoryRequirements: *VkMemoryRequirements2) #extern;
vkGetDeviceImageSparseMemoryRequirementsKHR :: fn (device: VkDevice, pInfo: *VkDeviceImageMemoryRequirements, pSparseMemoryRequirementCount: *u32, pSparseMemoryRequirements: *VkSparseImageMemoryRequirements2) #extern;
VkDebugReportObjectTypeEXT :: enum s32 {
	VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0x0;
	VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 0x1;
	VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 0x2;
	VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 0x3;
	VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 0x4;
	VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 0x5;
	VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 0x6;
	VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 0x7;
	VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 0x8;
	VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 0x9;
	VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 0xa;
	VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 0xb;
	VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 0xc;
	VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 0xd;
	VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 0xe;
	VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 0xf;
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 0x10;
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 0x11;
	VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 0x12;
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 0x13;
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 0x14;
	VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 0x15;
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 0x16;
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 0x17;
	VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 0x18;
	VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 0x19;
	VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 0x1a;
	VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 0x1b;
	VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = 0x1c;
	VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = 0x1d;
	VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = 0x1e;
	VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT = 0x21;
	VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT = 0x3b9d2b60;
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT = 0x3b9c1608;
	VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT = 0x3b9b3b48;
	VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT = 0x3b9b3b49;
	VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT = 0x3b9d13f0;
	VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT = 0x3b9d4e88;
	VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT = 0x3ba05fb0;
	VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = 0x1c;
	VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT = 0x21;
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT = 0x3b9c1608;
	VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT = 0x3b9d2b60;
	VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT = 0x7fffffff;
}
VkDebugReportFlagBitsEXT :: enum u32 #flags {
	VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 0x1;
	VK_DEBUG_REPORT_WARNING_BIT_EXT = 0x2;
	VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 0x4;
	VK_DEBUG_REPORT_ERROR_BIT_EXT = 0x8;
	VK_DEBUG_REPORT_DEBUG_BIT_EXT = 0x10;
	VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff;
}
VkDebugReportFlagsEXT :: VkFlags;
PFN_vkDebugReportCallbackEXT :: *fn (VkDebugReportFlagsEXT, VkDebugReportObjectTypeEXT, u64, usize, s32, *C.char, *C.char, C.void_ptr) VkBool32;
VkDebugReportCallbackCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkDebugReportFlagsEXT;
	pfnCallback: PFN_vkDebugReportCallbackEXT;
	pUserData: C.void_ptr;
}
PFN_vkCreateDebugReportCallbackEXT :: *fn (VkInstance, *VkDebugReportCallbackCreateInfoEXT, *VkAllocationCallbacks, *VkDebugReportCallbackEXT) VkResult;
PFN_vkDestroyDebugReportCallbackEXT :: *fn (VkInstance, VkDebugReportCallbackEXT, *VkAllocationCallbacks);
PFN_vkDebugReportMessageEXT :: *fn (VkInstance, VkDebugReportFlagsEXT, VkDebugReportObjectTypeEXT, u64, usize, s32, *C.char, *C.char);
vkCreateDebugReportCallbackEXT :: fn (instance: VkInstance, pCreateInfo: *VkDebugReportCallbackCreateInfoEXT, pAllocator: *VkAllocationCallbacks, pCallback: *VkDebugReportCallbackEXT) VkResult #extern;
vkDestroyDebugReportCallbackEXT :: fn (instance: VkInstance, callback: VkDebugReportCallbackEXT, pAllocator: *VkAllocationCallbacks) #extern;
vkDebugReportMessageEXT :: fn (instance: VkInstance, flags: VkDebugReportFlagsEXT, objectType: VkDebugReportObjectTypeEXT, object: u64, location: usize, messageCode: s32, pLayerPrefix: *C.char, pMessage: *C.char) #extern;
VkRasterizationOrderAMD :: enum s32 {
	VK_RASTERIZATION_ORDER_STRICT_AMD = 0x0;
	VK_RASTERIZATION_ORDER_RELAXED_AMD = 0x1;
	VK_RASTERIZATION_ORDER_MAX_ENUM_AMD = 0x7fffffff;
}
VkPipelineRasterizationStateRasterizationOrderAMD :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	rasterizationOrder: VkRasterizationOrderAMD;
}
VkDebugMarkerObjectNameInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	objectType: VkDebugReportObjectTypeEXT;
	object: u64;
	pObjectName: *C.char;
}
VkDebugMarkerObjectTagInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	objectType: VkDebugReportObjectTypeEXT;
	object: u64;
	tagName: u64;
	tagSize: usize;
	pTag: C.void_ptr;
}
VkDebugMarkerMarkerInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	pMarkerName: *C.char;
	color: [4]f32;
}
PFN_vkDebugMarkerSetObjectTagEXT :: *fn (VkDevice, *VkDebugMarkerObjectTagInfoEXT) VkResult;
PFN_vkDebugMarkerSetObjectNameEXT :: *fn (VkDevice, *VkDebugMarkerObjectNameInfoEXT) VkResult;
PFN_vkCmdDebugMarkerBeginEXT :: *fn (VkCommandBuffer, *VkDebugMarkerMarkerInfoEXT);
PFN_vkCmdDebugMarkerEndEXT :: *fn (VkCommandBuffer);
PFN_vkCmdDebugMarkerInsertEXT :: *fn (VkCommandBuffer, *VkDebugMarkerMarkerInfoEXT);
vkDebugMarkerSetObjectTagEXT :: fn (device: VkDevice, pTagInfo: *VkDebugMarkerObjectTagInfoEXT) VkResult #extern;
vkDebugMarkerSetObjectNameEXT :: fn (device: VkDevice, pNameInfo: *VkDebugMarkerObjectNameInfoEXT) VkResult #extern;
vkCmdDebugMarkerBeginEXT :: fn (commandBuffer: VkCommandBuffer, pMarkerInfo: *VkDebugMarkerMarkerInfoEXT) #extern;
vkCmdDebugMarkerEndEXT :: fn (commandBuffer: VkCommandBuffer) #extern;
vkCmdDebugMarkerInsertEXT :: fn (commandBuffer: VkCommandBuffer, pMarkerInfo: *VkDebugMarkerMarkerInfoEXT) #extern;
VkDedicatedAllocationImageCreateInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	dedicatedAllocation: VkBool32;
}
VkDedicatedAllocationBufferCreateInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	dedicatedAllocation: VkBool32;
}
VkDedicatedAllocationMemoryAllocateInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	image: VkImage;
	buffer: VkBuffer;
}
VkPipelineRasterizationStateStreamCreateFlagsEXT :: VkFlags;
VkPhysicalDeviceTransformFeedbackFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	transformFeedback: VkBool32;
	geometryStreams: VkBool32;
}
VkPhysicalDeviceTransformFeedbackPropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	maxTransformFeedbackStreams: u32;
	maxTransformFeedbackBuffers: u32;
	maxTransformFeedbackBufferSize: VkDeviceSize;
	maxTransformFeedbackStreamDataSize: u32;
	maxTransformFeedbackBufferDataSize: u32;
	maxTransformFeedbackBufferDataStride: u32;
	transformFeedbackQueries: VkBool32;
	transformFeedbackStreamsLinesTriangles: VkBool32;
	transformFeedbackRasterizationStreamSelect: VkBool32;
	transformFeedbackDraw: VkBool32;
}
VkPipelineRasterizationStateStreamCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkPipelineRasterizationStateStreamCreateFlagsEXT;
	rasterizationStream: u32;
}
PFN_vkCmdBindTransformFeedbackBuffersEXT :: *fn (VkCommandBuffer, u32, u32, *VkBuffer, *VkDeviceSize, *VkDeviceSize);
PFN_vkCmdBeginTransformFeedbackEXT :: *fn (VkCommandBuffer, u32, u32, *VkBuffer, *VkDeviceSize);
PFN_vkCmdEndTransformFeedbackEXT :: *fn (VkCommandBuffer, u32, u32, *VkBuffer, *VkDeviceSize);
PFN_vkCmdBeginQueryIndexedEXT :: *fn (VkCommandBuffer, VkQueryPool, u32, VkQueryControlFlags, u32);
PFN_vkCmdEndQueryIndexedEXT :: *fn (VkCommandBuffer, VkQueryPool, u32, u32);
PFN_vkCmdDrawIndirectByteCountEXT :: *fn (VkCommandBuffer, u32, u32, VkBuffer, VkDeviceSize, u32, u32);
vkCmdBindTransformFeedbackBuffersEXT :: fn (commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *VkBuffer, pOffsets: *VkDeviceSize, pSizes: *VkDeviceSize) #extern;
vkCmdBeginTransformFeedbackEXT :: fn (commandBuffer: VkCommandBuffer, firstCounterBuffer: u32, counterBufferCount: u32, pCounterBuffers: *VkBuffer, pCounterBufferOffsets: *VkDeviceSize) #extern;
vkCmdEndTransformFeedbackEXT :: fn (commandBuffer: VkCommandBuffer, firstCounterBuffer: u32, counterBufferCount: u32, pCounterBuffers: *VkBuffer, pCounterBufferOffsets: *VkDeviceSize) #extern;
vkCmdBeginQueryIndexedEXT :: fn (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32, flags: VkQueryControlFlags, index: u32) #extern;
vkCmdEndQueryIndexedEXT :: fn (commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32, index: u32) #extern;
vkCmdDrawIndirectByteCountEXT :: fn (commandBuffer: VkCommandBuffer, instanceCount: u32, firstInstance: u32, counterBuffer: VkBuffer, counterBufferOffset: VkDeviceSize, counterOffset: u32, vertexStride: u32) #extern;
VkCuModuleCreateInfoNVX :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	dataSize: usize;
	pData: C.void_ptr;
}
VkCuFunctionCreateInfoNVX :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	module: VkCuModuleNVX;
	pName: *C.char;
}
VkCuLaunchInfoNVX :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	function: VkCuFunctionNVX;
	gridDimX: u32;
	gridDimY: u32;
	gridDimZ: u32;
	blockDimX: u32;
	blockDimY: u32;
	blockDimZ: u32;
	sharedMemBytes: u32;
	paramCount: usize;
	pParams: *C.void_ptr;
	extraCount: usize;
	pExtras: *C.void_ptr;
}
PFN_vkCreateCuModuleNVX :: *fn (VkDevice, *VkCuModuleCreateInfoNVX, *VkAllocationCallbacks, *VkCuModuleNVX) VkResult;
PFN_vkCreateCuFunctionNVX :: *fn (VkDevice, *VkCuFunctionCreateInfoNVX, *VkAllocationCallbacks, *VkCuFunctionNVX) VkResult;
PFN_vkDestroyCuModuleNVX :: *fn (VkDevice, VkCuModuleNVX, *VkAllocationCallbacks);
PFN_vkDestroyCuFunctionNVX :: *fn (VkDevice, VkCuFunctionNVX, *VkAllocationCallbacks);
PFN_vkCmdCuLaunchKernelNVX :: *fn (VkCommandBuffer, *VkCuLaunchInfoNVX);
vkCreateCuModuleNVX :: fn (device: VkDevice, pCreateInfo: *VkCuModuleCreateInfoNVX, pAllocator: *VkAllocationCallbacks, pModule: *VkCuModuleNVX) VkResult #extern;
vkCreateCuFunctionNVX :: fn (device: VkDevice, pCreateInfo: *VkCuFunctionCreateInfoNVX, pAllocator: *VkAllocationCallbacks, pFunction: *VkCuFunctionNVX) VkResult #extern;
vkDestroyCuModuleNVX :: fn (device: VkDevice, module: VkCuModuleNVX, pAllocator: *VkAllocationCallbacks) #extern;
vkDestroyCuFunctionNVX :: fn (device: VkDevice, function: VkCuFunctionNVX, pAllocator: *VkAllocationCallbacks) #extern;
vkCmdCuLaunchKernelNVX :: fn (commandBuffer: VkCommandBuffer, pLaunchInfo: *VkCuLaunchInfoNVX) #extern;
VkImageViewHandleInfoNVX :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	imageView: VkImageView;
	descriptorType: VkDescriptorType;
	sampler: VkSampler;
}
VkImageViewAddressPropertiesNVX :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	deviceAddress: VkDeviceAddress;
	size: VkDeviceSize;
}
PFN_vkGetImageViewHandleNVX :: *fn (VkDevice, *VkImageViewHandleInfoNVX) u32;
PFN_vkGetImageViewAddressNVX :: *fn (VkDevice, VkImageView, *VkImageViewAddressPropertiesNVX) VkResult;
vkGetImageViewHandleNVX :: fn (device: VkDevice, pInfo: *VkImageViewHandleInfoNVX) u32 #extern;
vkGetImageViewAddressNVX :: fn (device: VkDevice, imageView: VkImageView, pProperties: *VkImageViewAddressPropertiesNVX) VkResult #extern;
PFN_vkCmdDrawIndirectCountAMD :: *fn (VkCommandBuffer, VkBuffer, VkDeviceSize, VkBuffer, VkDeviceSize, u32, u32);
PFN_vkCmdDrawIndexedIndirectCountAMD :: *fn (VkCommandBuffer, VkBuffer, VkDeviceSize, VkBuffer, VkDeviceSize, u32, u32);
vkCmdDrawIndirectCountAMD :: fn (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) #extern;
vkCmdDrawIndexedIndirectCountAMD :: fn (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) #extern;
VkTextureLODGatherFormatPropertiesAMD :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	supportsTextureGatherLODBiasAMD: VkBool32;
}
VkShaderInfoTypeAMD :: enum s32 {
	VK_SHADER_INFO_TYPE_STATISTICS_AMD = 0x0;
	VK_SHADER_INFO_TYPE_BINARY_AMD = 0x1;
	VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD = 0x2;
	VK_SHADER_INFO_TYPE_MAX_ENUM_AMD = 0x7fffffff;
}
VkShaderResourceUsageAMD :: struct {
	numUsedVgprs: u32;
	numUsedSgprs: u32;
	ldsSizePerLocalWorkGroup: u32;
	ldsUsageSizeInBytes: usize;
	scratchMemUsageInBytes: usize;
}
VkShaderStatisticsInfoAMD :: struct {
	shaderStageMask: VkShaderStageFlags;
	resourceUsage: VkShaderResourceUsageAMD;
	numPhysicalVgprs: u32;
	numPhysicalSgprs: u32;
	numAvailableVgprs: u32;
	numAvailableSgprs: u32;
	computeWorkGroupSize: [3]u32;
}
PFN_vkGetShaderInfoAMD :: *fn (VkDevice, VkPipeline, VkShaderStageFlagBits, VkShaderInfoTypeAMD, *usize, C.void_ptr) VkResult;
vkGetShaderInfoAMD :: fn (device: VkDevice, pipeline: VkPipeline, shaderStage: VkShaderStageFlagBits, infoType: VkShaderInfoTypeAMD, pInfoSize: *usize, pInfo: C.void_ptr) VkResult #extern;
VkPhysicalDeviceCornerSampledImageFeaturesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	cornerSampledImage: VkBool32;
}
VkExternalMemoryHandleTypeFlagBitsNV :: enum s32 {
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = 0x1;
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 0x2;
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = 0x4;
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = 0x8;
	VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff;
}
VkExternalMemoryHandleTypeFlagsNV :: VkFlags;
VkExternalMemoryFeatureFlagBitsNV :: enum s32 {
	VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = 0x1;
	VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = 0x2;
	VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = 0x4;
	VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff;
}
VkExternalMemoryFeatureFlagsNV :: VkFlags;
VkExternalImageFormatPropertiesNV :: struct {
	imageFormatProperties: VkImageFormatProperties;
	externalMemoryFeatures: VkExternalMemoryFeatureFlagsNV;
	exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlagsNV;
	compatibleHandleTypes: VkExternalMemoryHandleTypeFlagsNV;
}
PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV :: *fn (VkPhysicalDevice, VkFormat, VkImageType, VkImageTiling, VkImageUsageFlags, VkImageCreateFlags, VkExternalMemoryHandleTypeFlagsNV, *VkExternalImageFormatPropertiesNV) VkResult;
vkGetPhysicalDeviceExternalImageFormatPropertiesNV :: fn (physicalDevice: VkPhysicalDevice, format: VkFormat, t: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, externalHandleType: VkExternalMemoryHandleTypeFlagsNV, pExternalImageFormatProperties: *VkExternalImageFormatPropertiesNV) VkResult #extern;
VkExternalMemoryImageCreateInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	handleTypes: VkExternalMemoryHandleTypeFlagsNV;
}
VkExportMemoryAllocateInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	handleTypes: VkExternalMemoryHandleTypeFlagsNV;
}
VkValidationCheckEXT :: enum s32 {
	VK_VALIDATION_CHECK_ALL_EXT = 0x0;
	VK_VALIDATION_CHECK_SHADERS_EXT = 0x1;
	VK_VALIDATION_CHECK_MAX_ENUM_EXT = 0x7fffffff;
}
VkValidationFlagsEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	disabledValidationCheckCount: u32;
	pDisabledValidationChecks: *VkValidationCheckEXT;
}
VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT :: VkPhysicalDeviceTextureCompressionASTCHDRFeatures;
VkImageViewASTCDecodeModeEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	decodeMode: VkFormat;
}
VkPhysicalDeviceASTCDecodeFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	decodeModeSharedExponent: VkBool32;
}
VkPipelineRobustnessBufferBehaviorEXT :: enum s32 {
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT = 0x0;
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT = 0x1;
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT = 0x2;
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT = 0x3;
	VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_MAX_ENUM_EXT = 0x7fffffff;
}
VkPipelineRobustnessImageBehaviorEXT :: enum s32 {
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT = 0x0;
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT = 0x1;
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT = 0x2;
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT = 0x3;
	VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_MAX_ENUM_EXT = 0x7fffffff;
}
VkPhysicalDevicePipelineRobustnessFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	pipelineRobustness: VkBool32;
}
VkPhysicalDevicePipelineRobustnessPropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	defaultRobustnessStorageBuffers: VkPipelineRobustnessBufferBehaviorEXT;
	defaultRobustnessUniformBuffers: VkPipelineRobustnessBufferBehaviorEXT;
	defaultRobustnessVertexInputs: VkPipelineRobustnessBufferBehaviorEXT;
	defaultRobustnessImages: VkPipelineRobustnessImageBehaviorEXT;
}
VkPipelineRobustnessCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	storageBuffers: VkPipelineRobustnessBufferBehaviorEXT;
	uniformBuffers: VkPipelineRobustnessBufferBehaviorEXT;
	vertexInputs: VkPipelineRobustnessBufferBehaviorEXT;
	images: VkPipelineRobustnessImageBehaviorEXT;
}
VkConditionalRenderingFlagBitsEXT :: enum u32 #flags {
	VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT = 0x1;
	VK_CONDITIONAL_RENDERING_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff;
}
VkConditionalRenderingFlagsEXT :: VkFlags;
VkConditionalRenderingBeginInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	buffer: VkBuffer;
	offset: VkDeviceSize;
	flags: VkConditionalRenderingFlagsEXT;
}
VkPhysicalDeviceConditionalRenderingFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	conditionalRendering: VkBool32;
	inheritedConditionalRendering: VkBool32;
}
VkCommandBufferInheritanceConditionalRenderingInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	conditionalRenderingEnable: VkBool32;
}
PFN_vkCmdBeginConditionalRenderingEXT :: *fn (VkCommandBuffer, *VkConditionalRenderingBeginInfoEXT);
PFN_vkCmdEndConditionalRenderingEXT :: *fn (VkCommandBuffer);
vkCmdBeginConditionalRenderingEXT :: fn (commandBuffer: VkCommandBuffer, pConditionalRenderingBegin: *VkConditionalRenderingBeginInfoEXT) #extern;
vkCmdEndConditionalRenderingEXT :: fn (commandBuffer: VkCommandBuffer) #extern;
VkViewportWScalingNV :: struct {
	xcoeff: f32;
	ycoeff: f32;
}
VkPipelineViewportWScalingStateCreateInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	viewportWScalingEnable: VkBool32;
	viewportCount: u32;
	pViewportWScalings: *VkViewportWScalingNV;
}
PFN_vkCmdSetViewportWScalingNV :: *fn (VkCommandBuffer, u32, u32, *VkViewportWScalingNV);
vkCmdSetViewportWScalingNV :: fn (commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewportWScalings: *VkViewportWScalingNV) #extern;
PFN_vkReleaseDisplayEXT :: *fn (VkPhysicalDevice, VkDisplayKHR) VkResult;
vkReleaseDisplayEXT :: fn (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR) VkResult #extern;
VkSurfaceCounterFlagBitsEXT :: enum u32 #flags {
	VK_SURFACE_COUNTER_VBLANK_BIT_EXT = 0x1;
	VK_SURFACE_COUNTER_VBLANK_EXT = 0x1;
	VK_SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff;
}
VkSurfaceCounterFlagsEXT :: VkFlags;
VkSurfaceCapabilities2EXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	minImageCount: u32;
	maxImageCount: u32;
	currentExtent: VkExtent2D;
	minImageExtent: VkExtent2D;
	maxImageExtent: VkExtent2D;
	maxImageArrayLayers: u32;
	supportedTransforms: VkSurfaceTransformFlagsKHR;
	currentTransform: VkSurfaceTransformFlagBitsKHR;
	supportedCompositeAlpha: VkCompositeAlphaFlagsKHR;
	supportedUsageFlags: VkImageUsageFlags;
	supportedSurfaceCounters: VkSurfaceCounterFlagsEXT;
}
PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT :: *fn (VkPhysicalDevice, VkSurfaceKHR, *VkSurfaceCapabilities2EXT) VkResult;
vkGetPhysicalDeviceSurfaceCapabilities2EXT :: fn (physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR, pSurfaceCapabilities: *VkSurfaceCapabilities2EXT) VkResult #extern;
VkDisplayPowerStateEXT :: enum s32 {
	VK_DISPLAY_POWER_STATE_OFF_EXT = 0x0;
	VK_DISPLAY_POWER_STATE_SUSPEND_EXT = 0x1;
	VK_DISPLAY_POWER_STATE_ON_EXT = 0x2;
	VK_DISPLAY_POWER_STATE_MAX_ENUM_EXT = 0x7fffffff;
}
VkDeviceEventTypeEXT :: enum s32 {
	VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = 0x0;
	VK_DEVICE_EVENT_TYPE_MAX_ENUM_EXT = 0x7fffffff;
}
VkDisplayEventTypeEXT :: enum s32 {
	VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = 0x0;
	VK_DISPLAY_EVENT_TYPE_MAX_ENUM_EXT = 0x7fffffff;
}
VkDisplayPowerInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	powerState: VkDisplayPowerStateEXT;
}
VkDeviceEventInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	deviceEvent: VkDeviceEventTypeEXT;
}
VkDisplayEventInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	displayEvent: VkDisplayEventTypeEXT;
}
VkSwapchainCounterCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	surfaceCounters: VkSurfaceCounterFlagsEXT;
}
PFN_vkDisplayPowerControlEXT :: *fn (VkDevice, VkDisplayKHR, *VkDisplayPowerInfoEXT) VkResult;
PFN_vkRegisterDeviceEventEXT :: *fn (VkDevice, *VkDeviceEventInfoEXT, *VkAllocationCallbacks, *VkFence) VkResult;
PFN_vkRegisterDisplayEventEXT :: *fn (VkDevice, VkDisplayKHR, *VkDisplayEventInfoEXT, *VkAllocationCallbacks, *VkFence) VkResult;
PFN_vkGetSwapchainCounterEXT :: *fn (VkDevice, VkSwapchainKHR, VkSurfaceCounterFlagBitsEXT, *u64) VkResult;
vkDisplayPowerControlEXT :: fn (device: VkDevice, display: VkDisplayKHR, pDisplayPowerInfo: *VkDisplayPowerInfoEXT) VkResult #extern;
vkRegisterDeviceEventEXT :: fn (device: VkDevice, pDeviceEventInfo: *VkDeviceEventInfoEXT, pAllocator: *VkAllocationCallbacks, pFence: *VkFence) VkResult #extern;
vkRegisterDisplayEventEXT :: fn (device: VkDevice, display: VkDisplayKHR, pDisplayEventInfo: *VkDisplayEventInfoEXT, pAllocator: *VkAllocationCallbacks, pFence: *VkFence) VkResult #extern;
vkGetSwapchainCounterEXT :: fn (device: VkDevice, swapchain: VkSwapchainKHR, counter: VkSurfaceCounterFlagBitsEXT, pCounterValue: *u64) VkResult #extern;
VkRefreshCycleDurationGOOGLE :: struct {
	refreshDuration: u64;
}
VkPastPresentationTimingGOOGLE :: struct {
	presentID: u32;
	desiredPresentTime: u64;
	actualPresentTime: u64;
	earliestPresentTime: u64;
	presentMargin: u64;
}
VkPresentTimeGOOGLE :: struct {
	presentID: u32;
	desiredPresentTime: u64;
}
VkPresentTimesInfoGOOGLE :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	swapchainCount: u32;
	pTimes: *VkPresentTimeGOOGLE;
}
PFN_vkGetRefreshCycleDurationGOOGLE :: *fn (VkDevice, VkSwapchainKHR, *VkRefreshCycleDurationGOOGLE) VkResult;
PFN_vkGetPastPresentationTimingGOOGLE :: *fn (VkDevice, VkSwapchainKHR, *u32, *VkPastPresentationTimingGOOGLE) VkResult;
vkGetRefreshCycleDurationGOOGLE :: fn (device: VkDevice, swapchain: VkSwapchainKHR, pDisplayTimingProperties: *VkRefreshCycleDurationGOOGLE) VkResult #extern;
vkGetPastPresentationTimingGOOGLE :: fn (device: VkDevice, swapchain: VkSwapchainKHR, pPresentationTimingCount: *u32, pPresentationTimings: *VkPastPresentationTimingGOOGLE) VkResult #extern;
VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	perViewPositionAllComponents: VkBool32;
}
VkViewportCoordinateSwizzleNV :: enum s32 {
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV = 0x0;
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV = 0x1;
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV = 0x2;
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV = 0x3;
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV = 0x4;
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV = 0x5;
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV = 0x6;
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV = 0x7;
	VK_VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV = 0x7fffffff;
}
VkPipelineViewportSwizzleStateCreateFlagsNV :: VkFlags;
VkViewportSwizzleNV :: struct {
	x: VkViewportCoordinateSwizzleNV;
	y: VkViewportCoordinateSwizzleNV;
	z: VkViewportCoordinateSwizzleNV;
	w: VkViewportCoordinateSwizzleNV;
}
VkPipelineViewportSwizzleStateCreateInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkPipelineViewportSwizzleStateCreateFlagsNV;
	viewportCount: u32;
	pViewportSwizzles: *VkViewportSwizzleNV;
}
VkDiscardRectangleModeEXT :: enum s32 {
	VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = 0x0;
	VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT = 0x1;
	VK_DISCARD_RECTANGLE_MODE_MAX_ENUM_EXT = 0x7fffffff;
}
VkPipelineDiscardRectangleStateCreateFlagsEXT :: VkFlags;
VkPhysicalDeviceDiscardRectanglePropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	maxDiscardRectangles: u32;
}
VkPipelineDiscardRectangleStateCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkPipelineDiscardRectangleStateCreateFlagsEXT;
	discardRectangleMode: VkDiscardRectangleModeEXT;
	discardRectangleCount: u32;
	pDiscardRectangles: *VkRect2D;
}
PFN_vkCmdSetDiscardRectangleEXT :: *fn (VkCommandBuffer, u32, u32, *VkRect2D);
vkCmdSetDiscardRectangleEXT :: fn (commandBuffer: VkCommandBuffer, firstDiscardRectangle: u32, discardRectangleCount: u32, pDiscardRectangles: *VkRect2D) #extern;
VkConservativeRasterizationModeEXT :: enum s32 {
	VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT = 0x0;
	VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT = 0x1;
	VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT = 0x2;
	VK_CONSERVATIVE_RASTERIZATION_MODE_MAX_ENUM_EXT = 0x7fffffff;
}
VkPipelineRasterizationConservativeStateCreateFlagsEXT :: VkFlags;
VkPhysicalDeviceConservativeRasterizationPropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	primitiveOverestimationSize: f32;
	maxExtraPrimitiveOverestimationSize: f32;
	extraPrimitiveOverestimationSizeGranularity: f32;
	primitiveUnderestimation: VkBool32;
	conservativePointAndLineRasterization: VkBool32;
	degenerateTrianglesRasterized: VkBool32;
	degenerateLinesRasterized: VkBool32;
	fullyCoveredFragmentShaderInputVariable: VkBool32;
	conservativeRasterizationPostDepthCoverage: VkBool32;
}
VkPipelineRasterizationConservativeStateCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkPipelineRasterizationConservativeStateCreateFlagsEXT;
	conservativeRasterizationMode: VkConservativeRasterizationModeEXT;
	extraPrimitiveOverestimationSize: f32;
}
VkPipelineRasterizationDepthClipStateCreateFlagsEXT :: VkFlags;
VkPhysicalDeviceDepthClipEnableFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	depthClipEnable: VkBool32;
}
VkPipelineRasterizationDepthClipStateCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkPipelineRasterizationDepthClipStateCreateFlagsEXT;
	depthClipEnable: VkBool32;
}
VkXYColorEXT :: struct {
	x: f32;
	y: f32;
}
VkHdrMetadataEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	displayPrimaryRed: VkXYColorEXT;
	displayPrimaryGreen: VkXYColorEXT;
	displayPrimaryBlue: VkXYColorEXT;
	whitePoint: VkXYColorEXT;
	maxLuminance: f32;
	minLuminance: f32;
	maxContentLightLevel: f32;
	maxFrameAverageLightLevel: f32;
}
PFN_vkSetHdrMetadataEXT :: *fn (VkDevice, u32, *VkSwapchainKHR, *VkHdrMetadataEXT);
vkSetHdrMetadataEXT :: fn (device: VkDevice, swapchainCount: u32, pSwapchains: *VkSwapchainKHR, pMetadata: *VkHdrMetadataEXT) #extern;
VkDebugUtilsMessengerCallbackDataFlagsEXT :: VkFlags;
VkDebugUtilsMessageSeverityFlagBitsEXT :: enum u32 #flags {
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT = 0x1;
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT = 0x10;
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT = 0x100;
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT = 0x1000;
	VK_DEBUG_UTILS_MESSAGE_SEVERITY_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff;
}
VkDebugUtilsMessageTypeFlagBitsEXT :: enum u32 #flags {
	VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT = 0x1;
	VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT = 0x2;
	VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT = 0x4;
	VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT = 0x8;
	VK_DEBUG_UTILS_MESSAGE_TYPE_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff;
}
VkDebugUtilsMessageTypeFlagsEXT :: VkFlags;
VkDebugUtilsMessageSeverityFlagsEXT :: VkFlags;
VkDebugUtilsMessengerCreateFlagsEXT :: VkFlags;
VkDebugUtilsLabelEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	pLabelName: *C.char;
	color: [4]f32;
}
VkDebugUtilsObjectNameInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	objectType: VkObjectType;
	objectHandle: u64;
	pObjectName: *C.char;
}
VkDebugUtilsMessengerCallbackDataEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkDebugUtilsMessengerCallbackDataFlagsEXT;
	pMessageIdName: *C.char;
	messageIdNumber: s32;
	pMessage: *C.char;
	queueLabelCount: u32;
	pQueueLabels: *VkDebugUtilsLabelEXT;
	cmdBufLabelCount: u32;
	pCmdBufLabels: *VkDebugUtilsLabelEXT;
	objectCount: u32;
	pObjects: *VkDebugUtilsObjectNameInfoEXT;
}
PFN_vkDebugUtilsMessengerCallbackEXT :: *fn (VkDebugUtilsMessageSeverityFlagBitsEXT, VkDebugUtilsMessageTypeFlagsEXT, *VkDebugUtilsMessengerCallbackDataEXT, C.void_ptr) VkBool32;
VkDebugUtilsMessengerCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkDebugUtilsMessengerCreateFlagsEXT;
	messageSeverity: VkDebugUtilsMessageSeverityFlagsEXT;
	messageType: VkDebugUtilsMessageTypeFlagsEXT;
	pfnUserCallback: PFN_vkDebugUtilsMessengerCallbackEXT;
	pUserData: C.void_ptr;
}
VkDebugUtilsObjectTagInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	objectType: VkObjectType;
	objectHandle: u64;
	tagName: u64;
	tagSize: usize;
	pTag: C.void_ptr;
}
PFN_vkSetDebugUtilsObjectNameEXT :: *fn (VkDevice, *VkDebugUtilsObjectNameInfoEXT) VkResult;
PFN_vkSetDebugUtilsObjectTagEXT :: *fn (VkDevice, *VkDebugUtilsObjectTagInfoEXT) VkResult;
PFN_vkQueueBeginDebugUtilsLabelEXT :: *fn (VkQueue, *VkDebugUtilsLabelEXT);
PFN_vkQueueEndDebugUtilsLabelEXT :: *fn (VkQueue);
PFN_vkQueueInsertDebugUtilsLabelEXT :: *fn (VkQueue, *VkDebugUtilsLabelEXT);
PFN_vkCmdBeginDebugUtilsLabelEXT :: *fn (VkCommandBuffer, *VkDebugUtilsLabelEXT);
PFN_vkCmdEndDebugUtilsLabelEXT :: *fn (VkCommandBuffer);
PFN_vkCmdInsertDebugUtilsLabelEXT :: *fn (VkCommandBuffer, *VkDebugUtilsLabelEXT);
PFN_vkCreateDebugUtilsMessengerEXT :: *fn (VkInstance, *VkDebugUtilsMessengerCreateInfoEXT, *VkAllocationCallbacks, *VkDebugUtilsMessengerEXT) VkResult;
PFN_vkDestroyDebugUtilsMessengerEXT :: *fn (VkInstance, VkDebugUtilsMessengerEXT, *VkAllocationCallbacks);
PFN_vkSubmitDebugUtilsMessageEXT :: *fn (VkInstance, VkDebugUtilsMessageSeverityFlagBitsEXT, VkDebugUtilsMessageTypeFlagsEXT, *VkDebugUtilsMessengerCallbackDataEXT);
vkSetDebugUtilsObjectNameEXT :: fn (device: VkDevice, pNameInfo: *VkDebugUtilsObjectNameInfoEXT) VkResult #extern;
vkSetDebugUtilsObjectTagEXT :: fn (device: VkDevice, pTagInfo: *VkDebugUtilsObjectTagInfoEXT) VkResult #extern;
vkQueueBeginDebugUtilsLabelEXT :: fn (queue: VkQueue, pLabelInfo: *VkDebugUtilsLabelEXT) #extern;
vkQueueEndDebugUtilsLabelEXT :: fn (queue: VkQueue) #extern;
vkQueueInsertDebugUtilsLabelEXT :: fn (queue: VkQueue, pLabelInfo: *VkDebugUtilsLabelEXT) #extern;
vkCmdBeginDebugUtilsLabelEXT :: fn (commandBuffer: VkCommandBuffer, pLabelInfo: *VkDebugUtilsLabelEXT) #extern;
vkCmdEndDebugUtilsLabelEXT :: fn (commandBuffer: VkCommandBuffer) #extern;
vkCmdInsertDebugUtilsLabelEXT :: fn (commandBuffer: VkCommandBuffer, pLabelInfo: *VkDebugUtilsLabelEXT) #extern;
vkCreateDebugUtilsMessengerEXT :: fn (instance: VkInstance, pCreateInfo: *VkDebugUtilsMessengerCreateInfoEXT, pAllocator: *VkAllocationCallbacks, pMessenger: *VkDebugUtilsMessengerEXT) VkResult #extern;
vkDestroyDebugUtilsMessengerEXT :: fn (instance: VkInstance, messenger: VkDebugUtilsMessengerEXT, pAllocator: *VkAllocationCallbacks) #extern;
vkSubmitDebugUtilsMessageEXT :: fn (instance: VkInstance, messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT, messageTypes: VkDebugUtilsMessageTypeFlagsEXT, pCallbackData: *VkDebugUtilsMessengerCallbackDataEXT) #extern;
VkSamplerReductionModeEXT :: VkSamplerReductionMode;
VkSamplerReductionModeCreateInfoEXT :: VkSamplerReductionModeCreateInfo;
VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT :: VkPhysicalDeviceSamplerFilterMinmaxProperties;
VkPhysicalDeviceInlineUniformBlockFeaturesEXT :: VkPhysicalDeviceInlineUniformBlockFeatures;
VkPhysicalDeviceInlineUniformBlockPropertiesEXT :: VkPhysicalDeviceInlineUniformBlockProperties;
VkWriteDescriptorSetInlineUniformBlockEXT :: VkWriteDescriptorSetInlineUniformBlock;
VkDescriptorPoolInlineUniformBlockCreateInfoEXT :: VkDescriptorPoolInlineUniformBlockCreateInfo;
VkSampleLocationEXT :: struct {
	x: f32;
	y: f32;
}
VkSampleLocationsInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	sampleLocationsPerPixel: VkSampleCountFlagBits;
	sampleLocationGridSize: VkExtent2D;
	sampleLocationsCount: u32;
	pSampleLocations: *VkSampleLocationEXT;
}
VkAttachmentSampleLocationsEXT :: struct {
	attachmentIndex: u32;
	sampleLocationsInfo: VkSampleLocationsInfoEXT;
}
VkSubpassSampleLocationsEXT :: struct {
	subpassIndex: u32;
	sampleLocationsInfo: VkSampleLocationsInfoEXT;
}
VkRenderPassSampleLocationsBeginInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	attachmentInitialSampleLocationsCount: u32;
	pAttachmentInitialSampleLocations: *VkAttachmentSampleLocationsEXT;
	postSubpassSampleLocationsCount: u32;
	pPostSubpassSampleLocations: *VkSubpassSampleLocationsEXT;
}
VkPipelineSampleLocationsStateCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	sampleLocationsEnable: VkBool32;
	sampleLocationsInfo: VkSampleLocationsInfoEXT;
}
VkPhysicalDeviceSampleLocationsPropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	sampleLocationSampleCounts: VkSampleCountFlags;
	maxSampleLocationGridSize: VkExtent2D;
	sampleLocationCoordinateRange: [2]f32;
	sampleLocationSubPixelBits: u32;
	variableSampleLocations: VkBool32;
}
VkMultisamplePropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	maxSampleLocationGridSize: VkExtent2D;
}
PFN_vkCmdSetSampleLocationsEXT :: *fn (VkCommandBuffer, *VkSampleLocationsInfoEXT);
PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT :: *fn (VkPhysicalDevice, VkSampleCountFlagBits, *VkMultisamplePropertiesEXT);
vkCmdSetSampleLocationsEXT :: fn (commandBuffer: VkCommandBuffer, pSampleLocationsInfo: *VkSampleLocationsInfoEXT) #extern;
vkGetPhysicalDeviceMultisamplePropertiesEXT :: fn (physicalDevice: VkPhysicalDevice, samples: VkSampleCountFlagBits, pMultisampleProperties: *VkMultisamplePropertiesEXT) #extern;
VkBlendOverlapEXT :: enum s32 {
	VK_BLEND_OVERLAP_UNCORRELATED_EXT = 0x0;
	VK_BLEND_OVERLAP_DISJOINT_EXT = 0x1;
	VK_BLEND_OVERLAP_CONJOINT_EXT = 0x2;
	VK_BLEND_OVERLAP_MAX_ENUM_EXT = 0x7fffffff;
}
VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	advancedBlendCoherentOperations: VkBool32;
}
VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	advancedBlendMaxColorAttachments: u32;
	advancedBlendIndependentBlend: VkBool32;
	advancedBlendNonPremultipliedSrcColor: VkBool32;
	advancedBlendNonPremultipliedDstColor: VkBool32;
	advancedBlendCorrelatedOverlap: VkBool32;
	advancedBlendAllOperations: VkBool32;
}
VkPipelineColorBlendAdvancedStateCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	srcPremultiplied: VkBool32;
	dstPremultiplied: VkBool32;
	blendOverlap: VkBlendOverlapEXT;
}
VkPipelineCoverageToColorStateCreateFlagsNV :: VkFlags;
VkPipelineCoverageToColorStateCreateInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkPipelineCoverageToColorStateCreateFlagsNV;
	coverageToColorEnable: VkBool32;
	coverageToColorLocation: u32;
}
VkCoverageModulationModeNV :: enum s32 {
	VK_COVERAGE_MODULATION_MODE_NONE_NV = 0x0;
	VK_COVERAGE_MODULATION_MODE_RGB_NV = 0x1;
	VK_COVERAGE_MODULATION_MODE_ALPHA_NV = 0x2;
	VK_COVERAGE_MODULATION_MODE_RGBA_NV = 0x3;
	VK_COVERAGE_MODULATION_MODE_MAX_ENUM_NV = 0x7fffffff;
}
VkPipelineCoverageModulationStateCreateFlagsNV :: VkFlags;
VkPipelineCoverageModulationStateCreateInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkPipelineCoverageModulationStateCreateFlagsNV;
	coverageModulationMode: VkCoverageModulationModeNV;
	coverageModulationTableEnable: VkBool32;
	coverageModulationTableCount: u32;
	pCoverageModulationTable: *f32;
}
VkPhysicalDeviceShaderSMBuiltinsPropertiesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shaderSMCount: u32;
	shaderWarpsPerSM: u32;
}
VkPhysicalDeviceShaderSMBuiltinsFeaturesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shaderSMBuiltins: VkBool32;
}
VkDrmFormatModifierPropertiesEXT :: struct {
	drmFormatModifier: u64;
	drmFormatModifierPlaneCount: u32;
	drmFormatModifierTilingFeatures: VkFormatFeatureFlags;
}
VkDrmFormatModifierPropertiesListEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	drmFormatModifierCount: u32;
	pDrmFormatModifierProperties: *VkDrmFormatModifierPropertiesEXT;
}
VkPhysicalDeviceImageDrmFormatModifierInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	drmFormatModifier: u64;
	sharingMode: VkSharingMode;
	queueFamilyIndexCount: u32;
	pQueueFamilyIndices: *u32;
}
VkImageDrmFormatModifierListCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	drmFormatModifierCount: u32;
	pDrmFormatModifiers: *u64;
}
VkImageDrmFormatModifierExplicitCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	drmFormatModifier: u64;
	drmFormatModifierPlaneCount: u32;
	pPlaneLayouts: *VkSubresourceLayout;
}
VkImageDrmFormatModifierPropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	drmFormatModifier: u64;
}
VkDrmFormatModifierProperties2EXT :: struct {
	drmFormatModifier: u64;
	drmFormatModifierPlaneCount: u32;
	drmFormatModifierTilingFeatures: VkFormatFeatureFlags2;
}
VkDrmFormatModifierPropertiesList2EXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	drmFormatModifierCount: u32;
	pDrmFormatModifierProperties: *VkDrmFormatModifierProperties2EXT;
}
PFN_vkGetImageDrmFormatModifierPropertiesEXT :: *fn (VkDevice, VkImage, *VkImageDrmFormatModifierPropertiesEXT) VkResult;
vkGetImageDrmFormatModifierPropertiesEXT :: fn (device: VkDevice, image: VkImage, pProperties: *VkImageDrmFormatModifierPropertiesEXT) VkResult #extern;
VkValidationCacheHeaderVersionEXT :: enum s32 {
	VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT = 0x1;
	VK_VALIDATION_CACHE_HEADER_VERSION_MAX_ENUM_EXT = 0x7fffffff;
}
VkValidationCacheCreateFlagsEXT :: VkFlags;
VkValidationCacheCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkValidationCacheCreateFlagsEXT;
	initialDataSize: usize;
	pInitialData: C.void_ptr;
}
VkShaderModuleValidationCacheCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	validationCache: VkValidationCacheEXT;
}
PFN_vkCreateValidationCacheEXT :: *fn (VkDevice, *VkValidationCacheCreateInfoEXT, *VkAllocationCallbacks, *VkValidationCacheEXT) VkResult;
PFN_vkDestroyValidationCacheEXT :: *fn (VkDevice, VkValidationCacheEXT, *VkAllocationCallbacks);
PFN_vkMergeValidationCachesEXT :: *fn (VkDevice, VkValidationCacheEXT, u32, *VkValidationCacheEXT) VkResult;
PFN_vkGetValidationCacheDataEXT :: *fn (VkDevice, VkValidationCacheEXT, *usize, C.void_ptr) VkResult;
vkCreateValidationCacheEXT :: fn (device: VkDevice, pCreateInfo: *VkValidationCacheCreateInfoEXT, pAllocator: *VkAllocationCallbacks, pValidationCache: *VkValidationCacheEXT) VkResult #extern;
vkDestroyValidationCacheEXT :: fn (device: VkDevice, validationCache: VkValidationCacheEXT, pAllocator: *VkAllocationCallbacks) #extern;
vkMergeValidationCachesEXT :: fn (device: VkDevice, dstCache: VkValidationCacheEXT, srcCacheCount: u32, pSrcCaches: *VkValidationCacheEXT) VkResult #extern;
vkGetValidationCacheDataEXT :: fn (device: VkDevice, validationCache: VkValidationCacheEXT, pDataSize: *usize, pData: C.void_ptr) VkResult #extern;
VkDescriptorBindingFlagBitsEXT :: VkDescriptorBindingFlagBits;
VkDescriptorBindingFlagsEXT :: VkDescriptorBindingFlags;
VkDescriptorSetLayoutBindingFlagsCreateInfoEXT :: VkDescriptorSetLayoutBindingFlagsCreateInfo;
VkPhysicalDeviceDescriptorIndexingFeaturesEXT :: VkPhysicalDeviceDescriptorIndexingFeatures;
VkPhysicalDeviceDescriptorIndexingPropertiesEXT :: VkPhysicalDeviceDescriptorIndexingProperties;
VkDescriptorSetVariableDescriptorCountAllocateInfoEXT :: VkDescriptorSetVariableDescriptorCountAllocateInfo;
VkDescriptorSetVariableDescriptorCountLayoutSupportEXT :: VkDescriptorSetVariableDescriptorCountLayoutSupport;
VkShadingRatePaletteEntryNV :: enum s32 {
	VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV = 0x0;
	VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV = 0x1;
	VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV = 0x2;
	VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV = 0x3;
	VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV = 0x4;
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV = 0x5;
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV = 0x6;
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV = 0x7;
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV = 0x8;
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV = 0x9;
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV = 0xa;
	VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV = 0xb;
	VK_SHADING_RATE_PALETTE_ENTRY_MAX_ENUM_NV = 0x7fffffff;
}
VkCoarseSampleOrderTypeNV :: enum s32 {
	VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV = 0x0;
	VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV = 0x1;
	VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV = 0x2;
	VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV = 0x3;
	VK_COARSE_SAMPLE_ORDER_TYPE_MAX_ENUM_NV = 0x7fffffff;
}
VkShadingRatePaletteNV :: struct {
	shadingRatePaletteEntryCount: u32;
	pShadingRatePaletteEntries: *VkShadingRatePaletteEntryNV;
}
VkPipelineViewportShadingRateImageStateCreateInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shadingRateImageEnable: VkBool32;
	viewportCount: u32;
	pShadingRatePalettes: *VkShadingRatePaletteNV;
}
VkPhysicalDeviceShadingRateImageFeaturesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shadingRateImage: VkBool32;
	shadingRateCoarseSampleOrder: VkBool32;
}
VkPhysicalDeviceShadingRateImagePropertiesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shadingRateTexelSize: VkExtent2D;
	shadingRatePaletteSize: u32;
	shadingRateMaxCoarseSamples: u32;
}
VkCoarseSampleLocationNV :: struct {
	pixelX: u32;
	pixelY: u32;
	sample: u32;
}
VkCoarseSampleOrderCustomNV :: struct {
	shadingRate: VkShadingRatePaletteEntryNV;
	sampleCount: u32;
	sampleLocationCount: u32;
	pSampleLocations: *VkCoarseSampleLocationNV;
}
VkPipelineViewportCoarseSampleOrderStateCreateInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	sampleOrderType: VkCoarseSampleOrderTypeNV;
	customSampleOrderCount: u32;
	pCustomSampleOrders: *VkCoarseSampleOrderCustomNV;
}
PFN_vkCmdBindShadingRateImageNV :: *fn (VkCommandBuffer, VkImageView, VkImageLayout);
PFN_vkCmdSetViewportShadingRatePaletteNV :: *fn (VkCommandBuffer, u32, u32, *VkShadingRatePaletteNV);
PFN_vkCmdSetCoarseSampleOrderNV :: *fn (VkCommandBuffer, VkCoarseSampleOrderTypeNV, u32, *VkCoarseSampleOrderCustomNV);
vkCmdBindShadingRateImageNV :: fn (commandBuffer: VkCommandBuffer, imageView: VkImageView, imageLayout: VkImageLayout) #extern;
vkCmdSetViewportShadingRatePaletteNV :: fn (commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pShadingRatePalettes: *VkShadingRatePaletteNV) #extern;
vkCmdSetCoarseSampleOrderNV :: fn (commandBuffer: VkCommandBuffer, sampleOrderType: VkCoarseSampleOrderTypeNV, customSampleOrderCount: u32, pCustomSampleOrders: *VkCoarseSampleOrderCustomNV) #extern;
VkRayTracingShaderGroupTypeKHR :: enum s32 {
	VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR = 0x0;
	VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR = 0x1;
	VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR = 0x2;
	VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV = 0x0;
	VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV = 0x1;
	VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV = 0x2;
	VK_RAY_TRACING_SHADER_GROUP_TYPE_MAX_ENUM_KHR = 0x7fffffff;
}
VkRayTracingShaderGroupTypeNV :: VkRayTracingShaderGroupTypeKHR;
VkGeometryTypeKHR :: enum s32 {
	VK_GEOMETRY_TYPE_TRIANGLES_KHR = 0x0;
	VK_GEOMETRY_TYPE_AABBS_KHR = 0x1;
	VK_GEOMETRY_TYPE_INSTANCES_KHR = 0x2;
	VK_GEOMETRY_TYPE_TRIANGLES_NV = 0x0;
	VK_GEOMETRY_TYPE_AABBS_NV = 0x1;
	VK_GEOMETRY_TYPE_MAX_ENUM_KHR = 0x7fffffff;
}
VkGeometryTypeNV :: VkGeometryTypeKHR;
VkAccelerationStructureTypeKHR :: enum s32 {
	VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR = 0x0;
	VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR = 0x1;
	VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR = 0x2;
	VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV = 0x0;
	VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV = 0x1;
	VK_ACCELERATION_STRUCTURE_TYPE_MAX_ENUM_KHR = 0x7fffffff;
}
VkAccelerationStructureTypeNV :: VkAccelerationStructureTypeKHR;
VkCopyAccelerationStructureModeKHR :: enum s32 {
	VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR = 0x0;
	VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR = 0x1;
	VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR = 0x2;
	VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR = 0x3;
	VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV = 0x0;
	VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV = 0x1;
	VK_COPY_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_KHR = 0x7fffffff;
}
VkCopyAccelerationStructureModeNV :: VkCopyAccelerationStructureModeKHR;
VkAccelerationStructureMemoryRequirementsTypeNV :: enum s32 {
	VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV = 0x0;
	VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV = 0x1;
	VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV = 0x2;
	VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_MAX_ENUM_NV = 0x7fffffff;
}
VkGeometryFlagBitsKHR :: enum s32 {
	VK_GEOMETRY_OPAQUE_BIT_KHR = 0x1;
	VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR = 0x2;
	VK_GEOMETRY_OPAQUE_BIT_NV = 0x1;
	VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV = 0x2;
	VK_GEOMETRY_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff;
}
VkGeometryFlagsKHR :: VkFlags;
VkGeometryFlagsNV :: VkGeometryFlagsKHR;
VkGeometryFlagBitsNV :: VkGeometryFlagBitsKHR;
VkGeometryInstanceFlagBitsKHR :: enum s32 {
	VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR = 0x1;
	VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR = 0x2;
	VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR = 0x4;
	VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR = 0x8;
	VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_EXT = 0x10;
	VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_EXT = 0x20;
	VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR = 0x2;
	VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV = 0x1;
	VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV = 0x2;
	VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV = 0x4;
	VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV = 0x8;
	VK_GEOMETRY_INSTANCE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff;
}
VkGeometryInstanceFlagsKHR :: VkFlags;
VkGeometryInstanceFlagsNV :: VkGeometryInstanceFlagsKHR;
VkGeometryInstanceFlagBitsNV :: VkGeometryInstanceFlagBitsKHR;
VkBuildAccelerationStructureFlagBitsKHR :: enum s32 {
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR = 0x1;
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR = 0x2;
	VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR = 0x4;
	VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR = 0x8;
	VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR = 0x10;
	VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV = 0x20;
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT = 0x40;
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT = 0x80;
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT = 0x100;
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV = 0x1;
	VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV = 0x2;
	VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV = 0x4;
	VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV = 0x8;
	VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV = 0x10;
	VK_BUILD_ACCELERATION_STRUCTURE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff;
}
VkBuildAccelerationStructureFlagsKHR :: VkFlags;
VkBuildAccelerationStructureFlagsNV :: VkBuildAccelerationStructureFlagsKHR;
VkBuildAccelerationStructureFlagBitsNV :: VkBuildAccelerationStructureFlagBitsKHR;
VkRayTracingShaderGroupCreateInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	t: VkRayTracingShaderGroupTypeKHR;
	generalShader: u32;
	closestHitShader: u32;
	anyHitShader: u32;
	intersectionShader: u32;
}
VkRayTracingPipelineCreateInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkPipelineCreateFlags;
	stageCount: u32;
	pStages: *VkPipelineShaderStageCreateInfo;
	groupCount: u32;
	pGroups: *VkRayTracingShaderGroupCreateInfoNV;
	maxRecursionDepth: u32;
	layout: VkPipelineLayout;
	basePipelineHandle: VkPipeline;
	basePipelineIndex: s32;
}
VkGeometryTrianglesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	vertexData: VkBuffer;
	vertexOffset: VkDeviceSize;
	vertexCount: u32;
	vertexStride: VkDeviceSize;
	vertexFormat: VkFormat;
	indexData: VkBuffer;
	indexOffset: VkDeviceSize;
	indexCount: u32;
	indexType: VkIndexType;
	transformData: VkBuffer;
	transformOffset: VkDeviceSize;
}
VkGeometryAABBNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	aabbData: VkBuffer;
	numAABBs: u32;
	stride: u32;
	offset: VkDeviceSize;
}
VkGeometryDataNV :: struct {
	triangles: VkGeometryTrianglesNV;
	aabbs: VkGeometryAABBNV;
}
VkGeometryNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	geometryType: VkGeometryTypeKHR;
	geometry: VkGeometryDataNV;
	flags: VkGeometryFlagsKHR;
}
VkAccelerationStructureInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	t: VkAccelerationStructureTypeNV;
	flags: VkBuildAccelerationStructureFlagsNV;
	instanceCount: u32;
	geometryCount: u32;
	pGeometries: *VkGeometryNV;
}
VkAccelerationStructureCreateInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	compactedSize: VkDeviceSize;
	info: VkAccelerationStructureInfoNV;
}
VkBindAccelerationStructureMemoryInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	accelerationStructure: VkAccelerationStructureNV;
	memory: VkDeviceMemory;
	memoryOffset: VkDeviceSize;
	deviceIndexCount: u32;
	pDeviceIndices: *u32;
}
VkWriteDescriptorSetAccelerationStructureNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	accelerationStructureCount: u32;
	pAccelerationStructures: *VkAccelerationStructureNV;
}
VkAccelerationStructureMemoryRequirementsInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	t: VkAccelerationStructureMemoryRequirementsTypeNV;
	accelerationStructure: VkAccelerationStructureNV;
}
VkPhysicalDeviceRayTracingPropertiesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shaderGroupHandleSize: u32;
	maxRecursionDepth: u32;
	maxShaderGroupStride: u32;
	shaderGroupBaseAlignment: u32;
	maxGeometryCount: u64;
	maxInstanceCount: u64;
	maxTriangleCount: u64;
	maxDescriptorSetAccelerationStructures: u32;
}
VkTransformMatrixKHR :: struct {
	matrix: [3][4]f32;
}
VkTransformMatrixNV :: VkTransformMatrixKHR;
VkAabbPositionsKHR :: struct {
	minX: f32;
	minY: f32;
	minZ: f32;
	maxX: f32;
	maxY: f32;
	maxZ: f32;
}
VkAabbPositionsNV :: VkAabbPositionsKHR;
VkAccelerationStructureInstanceKHR :: struct {
	transform: VkTransformMatrixKHR;
	instanceCustomIndexAndMask: u32; // MSB for mask
	instanceShaderBindingTableRecordOffsetAndFlags: u32; // MSB for flags
	accelerationStructureReference: u64;
}
VkAccelerationStructureInstanceNV :: VkAccelerationStructureInstanceKHR;
PFN_vkCreateAccelerationStructureNV :: *fn (VkDevice, *VkAccelerationStructureCreateInfoNV, *VkAllocationCallbacks, *VkAccelerationStructureNV) VkResult;
PFN_vkDestroyAccelerationStructureNV :: *fn (VkDevice, VkAccelerationStructureNV, *VkAllocationCallbacks);
PFN_vkGetAccelerationStructureMemoryRequirementsNV :: *fn (VkDevice, *VkAccelerationStructureMemoryRequirementsInfoNV, *VkMemoryRequirements2KHR);
PFN_vkBindAccelerationStructureMemoryNV :: *fn (VkDevice, u32, *VkBindAccelerationStructureMemoryInfoNV) VkResult;
PFN_vkCmdBuildAccelerationStructureNV :: *fn (VkCommandBuffer, *VkAccelerationStructureInfoNV, VkBuffer, VkDeviceSize, VkBool32, VkAccelerationStructureNV, VkAccelerationStructureNV, VkBuffer, VkDeviceSize);
PFN_vkCmdCopyAccelerationStructureNV :: *fn (VkCommandBuffer, VkAccelerationStructureNV, VkAccelerationStructureNV, VkCopyAccelerationStructureModeKHR);
PFN_vkCmdTraceRaysNV :: *fn (VkCommandBuffer, VkBuffer, VkDeviceSize, VkBuffer, VkDeviceSize, VkDeviceSize, VkBuffer, VkDeviceSize, VkDeviceSize, VkBuffer, VkDeviceSize, VkDeviceSize, u32, u32, u32);
PFN_vkCreateRayTracingPipelinesNV :: *fn (VkDevice, VkPipelineCache, u32, *VkRayTracingPipelineCreateInfoNV, *VkAllocationCallbacks, *VkPipeline) VkResult;
PFN_vkGetRayTracingShaderGroupHandlesKHR :: *fn (VkDevice, VkPipeline, u32, u32, usize, C.void_ptr) VkResult;
PFN_vkGetRayTracingShaderGroupHandlesNV :: *fn (VkDevice, VkPipeline, u32, u32, usize, C.void_ptr) VkResult;
PFN_vkGetAccelerationStructureHandleNV :: *fn (VkDevice, VkAccelerationStructureNV, usize, C.void_ptr) VkResult;
PFN_vkCmdWriteAccelerationStructuresPropertiesNV :: *fn (VkCommandBuffer, u32, *VkAccelerationStructureNV, VkQueryType, VkQueryPool, u32);
PFN_vkCompileDeferredNV :: *fn (VkDevice, VkPipeline, u32) VkResult;
vkCreateAccelerationStructureNV :: fn (device: VkDevice, pCreateInfo: *VkAccelerationStructureCreateInfoNV, pAllocator: *VkAllocationCallbacks, pAccelerationStructure: *VkAccelerationStructureNV) VkResult #extern;
vkDestroyAccelerationStructureNV :: fn (device: VkDevice, accelerationStructure: VkAccelerationStructureNV, pAllocator: *VkAllocationCallbacks) #extern;
vkGetAccelerationStructureMemoryRequirementsNV :: fn (device: VkDevice, pInfo: *VkAccelerationStructureMemoryRequirementsInfoNV, pMemoryRequirements: *VkMemoryRequirements2KHR) #extern;
vkBindAccelerationStructureMemoryNV :: fn (device: VkDevice, bindInfoCount: u32, pBindInfos: *VkBindAccelerationStructureMemoryInfoNV) VkResult #extern;
vkCmdBuildAccelerationStructureNV :: fn (commandBuffer: VkCommandBuffer, pInfo: *VkAccelerationStructureInfoNV, instanceData: VkBuffer, instanceOffset: VkDeviceSize, update: VkBool32, dst: VkAccelerationStructureNV, src: VkAccelerationStructureNV, scratch: VkBuffer, scratchOffset: VkDeviceSize) #extern;
vkCmdCopyAccelerationStructureNV :: fn (commandBuffer: VkCommandBuffer, dst: VkAccelerationStructureNV, src: VkAccelerationStructureNV, mode: VkCopyAccelerationStructureModeKHR) #extern;
vkCmdTraceRaysNV :: fn (commandBuffer: VkCommandBuffer, raygenShaderBindingTableBuffer: VkBuffer, raygenShaderBindingOffset: VkDeviceSize, missShaderBindingTableBuffer: VkBuffer, missShaderBindingOffset: VkDeviceSize, missShaderBindingStride: VkDeviceSize, hitShaderBindingTableBuffer: VkBuffer, hitShaderBindingOffset: VkDeviceSize, hitShaderBindingStride: VkDeviceSize, callableShaderBindingTableBuffer: VkBuffer, callableShaderBindingOffset: VkDeviceSize, callableShaderBindingStride: VkDeviceSize, width: u32, height: u32, depth: u32) #extern;
vkCreateRayTracingPipelinesNV :: fn (device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *VkRayTracingPipelineCreateInfoNV, pAllocator: *VkAllocationCallbacks, pPipelines: *VkPipeline) VkResult #extern;
vkGetRayTracingShaderGroupHandlesKHR :: fn (device: VkDevice, pipeline: VkPipeline, firstGroup: u32, groupCount: u32, dataSize: usize, pData: C.void_ptr) VkResult #extern;
vkGetRayTracingShaderGroupHandlesNV :: fn (device: VkDevice, pipeline: VkPipeline, firstGroup: u32, groupCount: u32, dataSize: usize, pData: C.void_ptr) VkResult #extern;
vkGetAccelerationStructureHandleNV :: fn (device: VkDevice, accelerationStructure: VkAccelerationStructureNV, dataSize: usize, pData: C.void_ptr) VkResult #extern;
vkCmdWriteAccelerationStructuresPropertiesNV :: fn (commandBuffer: VkCommandBuffer, accelerationStructureCount: u32, pAccelerationStructures: *VkAccelerationStructureNV, queryType: VkQueryType, queryPool: VkQueryPool, firstQuery: u32) #extern;
vkCompileDeferredNV :: fn (device: VkDevice, pipeline: VkPipeline, shader: u32) VkResult #extern;
VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	representativeFragmentTest: VkBool32;
}
VkPipelineRepresentativeFragmentTestStateCreateInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	representativeFragmentTestEnable: VkBool32;
}
VkPhysicalDeviceImageViewImageFormatInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	imageViewType: VkImageViewType;
}
VkFilterCubicImageViewImageFormatPropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	filterCubic: VkBool32;
	filterCubicMinmax: VkBool32;
}
VkQueueGlobalPriorityEXT :: VkQueueGlobalPriorityKHR;
VkDeviceQueueGlobalPriorityCreateInfoEXT :: VkDeviceQueueGlobalPriorityCreateInfoKHR;
VkImportMemoryHostPointerInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	handleType: VkExternalMemoryHandleTypeFlagBits;
	pHostPointer: C.void_ptr;
}
VkMemoryHostPointerPropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	memoryTypeBits: u32;
}
VkPhysicalDeviceExternalMemoryHostPropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	minImportedHostPointerAlignment: VkDeviceSize;
}
PFN_vkGetMemoryHostPointerPropertiesEXT :: *fn (VkDevice, VkExternalMemoryHandleTypeFlagBits, C.void_ptr, *VkMemoryHostPointerPropertiesEXT) VkResult;
vkGetMemoryHostPointerPropertiesEXT :: fn (device: VkDevice, handleType: VkExternalMemoryHandleTypeFlagBits, pHostPointer: C.void_ptr, pMemoryHostPointerProperties: *VkMemoryHostPointerPropertiesEXT) VkResult #extern;
PFN_vkCmdWriteBufferMarkerAMD :: *fn (VkCommandBuffer, VkPipelineStageFlagBits, VkBuffer, VkDeviceSize, u32);
vkCmdWriteBufferMarkerAMD :: fn (commandBuffer: VkCommandBuffer, pipelineStage: VkPipelineStageFlagBits, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, marker: u32) #extern;
VkPipelineCompilerControlFlagBitsAMD :: enum s32 {
	VK_PIPELINE_COMPILER_CONTROL_FLAG_BITS_MAX_ENUM_AMD = 0x7fffffff;
}
VkPipelineCompilerControlFlagsAMD :: VkFlags;
VkPipelineCompilerControlCreateInfoAMD :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	compilerControlFlags: VkPipelineCompilerControlFlagsAMD;
}
VkTimeDomainEXT :: enum s32 {
	VK_TIME_DOMAIN_DEVICE_EXT = 0x0;
	VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT = 0x1;
	VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT = 0x2;
	VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT = 0x3;
	VK_TIME_DOMAIN_MAX_ENUM_EXT = 0x7fffffff;
}
VkCalibratedTimestampInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	timeDomain: VkTimeDomainEXT;
}
PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT :: *fn (VkPhysicalDevice, *u32, *VkTimeDomainEXT) VkResult;
PFN_vkGetCalibratedTimestampsEXT :: *fn (VkDevice, u32, *VkCalibratedTimestampInfoEXT, *u64, *u64) VkResult;
vkGetPhysicalDeviceCalibrateableTimeDomainsEXT :: fn (physicalDevice: VkPhysicalDevice, pTimeDomainCount: *u32, pTimeDomains: *VkTimeDomainEXT) VkResult #extern;
vkGetCalibratedTimestampsEXT :: fn (device: VkDevice, timestampCount: u32, pTimestampInfos: *VkCalibratedTimestampInfoEXT, pTimestamps: *u64, pMaxDeviation: *u64) VkResult #extern;
VkPhysicalDeviceShaderCorePropertiesAMD :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shaderEngineCount: u32;
	shaderArraysPerEngineCount: u32;
	computeUnitsPerShaderArray: u32;
	simdPerComputeUnit: u32;
	wavefrontsPerSimd: u32;
	wavefrontSize: u32;
	sgprsPerSimd: u32;
	minSgprAllocation: u32;
	maxSgprAllocation: u32;
	sgprAllocationGranularity: u32;
	vgprsPerSimd: u32;
	minVgprAllocation: u32;
	maxVgprAllocation: u32;
	vgprAllocationGranularity: u32;
}
VkMemoryOverallocationBehaviorAMD :: enum s32 {
	VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD = 0x0;
	VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD = 0x1;
	VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD = 0x2;
	VK_MEMORY_OVERALLOCATION_BEHAVIOR_MAX_ENUM_AMD = 0x7fffffff;
}
VkDeviceMemoryOverallocationCreateInfoAMD :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	overallocationBehavior: VkMemoryOverallocationBehaviorAMD;
}
VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	maxVertexAttribDivisor: u32;
}
VkVertexInputBindingDivisorDescriptionEXT :: struct {
	binding: u32;
	divisor: u32;
}
VkPipelineVertexInputDivisorStateCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	vertexBindingDivisorCount: u32;
	pVertexBindingDivisors: *VkVertexInputBindingDivisorDescriptionEXT;
}
VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	vertexAttributeInstanceRateDivisor: VkBool32;
	vertexAttributeInstanceRateZeroDivisor: VkBool32;
}
VkPipelineCreationFeedbackFlagBitsEXT :: VkPipelineCreationFeedbackFlagBits;
VkPipelineCreationFeedbackFlagsEXT :: VkPipelineCreationFeedbackFlags;
VkPipelineCreationFeedbackCreateInfoEXT :: VkPipelineCreationFeedbackCreateInfo;
VkPipelineCreationFeedbackEXT :: VkPipelineCreationFeedback;
VkPhysicalDeviceComputeShaderDerivativesFeaturesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	computeDerivativeGroupQuads: VkBool32;
	computeDerivativeGroupLinear: VkBool32;
}
VkPhysicalDeviceMeshShaderFeaturesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	taskShader: VkBool32;
	meshShader: VkBool32;
}
VkPhysicalDeviceMeshShaderPropertiesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	maxDrawMeshTasksCount: u32;
	maxTaskWorkGroupInvocations: u32;
	maxTaskWorkGroupSize: [3]u32;
	maxTaskTotalMemorySize: u32;
	maxTaskOutputCount: u32;
	maxMeshWorkGroupInvocations: u32;
	maxMeshWorkGroupSize: [3]u32;
	maxMeshTotalMemorySize: u32;
	maxMeshOutputVertices: u32;
	maxMeshOutputPrimitives: u32;
	maxMeshMultiviewViewCount: u32;
	meshOutputPerVertexGranularity: u32;
	meshOutputPerPrimitiveGranularity: u32;
}
VkDrawMeshTasksIndirectCommandNV :: struct {
	taskCount: u32;
	firstTask: u32;
}
PFN_vkCmdDrawMeshTasksNV :: *fn (VkCommandBuffer, u32, u32);
PFN_vkCmdDrawMeshTasksIndirectNV :: *fn (VkCommandBuffer, VkBuffer, VkDeviceSize, u32, u32);
PFN_vkCmdDrawMeshTasksIndirectCountNV :: *fn (VkCommandBuffer, VkBuffer, VkDeviceSize, VkBuffer, VkDeviceSize, u32, u32);
vkCmdDrawMeshTasksNV :: fn (commandBuffer: VkCommandBuffer, taskCount: u32, firstTask: u32) #extern;
vkCmdDrawMeshTasksIndirectNV :: fn (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32) #extern;
vkCmdDrawMeshTasksIndirectCountNV :: fn (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) #extern;
VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV :: VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR;
VkPhysicalDeviceShaderImageFootprintFeaturesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	imageFootprint: VkBool32;
}
VkPipelineViewportExclusiveScissorStateCreateInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	exclusiveScissorCount: u32;
	pExclusiveScissors: *VkRect2D;
}
VkPhysicalDeviceExclusiveScissorFeaturesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	exclusiveScissor: VkBool32;
}
PFN_vkCmdSetExclusiveScissorNV :: *fn (VkCommandBuffer, u32, u32, *VkRect2D);
vkCmdSetExclusiveScissorNV :: fn (commandBuffer: VkCommandBuffer, firstExclusiveScissor: u32, exclusiveScissorCount: u32, pExclusiveScissors: *VkRect2D) #extern;
VkQueueFamilyCheckpointPropertiesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	checkpointExecutionStageMask: VkPipelineStageFlags;
}
VkCheckpointDataNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	stage: VkPipelineStageFlagBits;
	pCheckpointMarker: C.void_ptr;
}
PFN_vkCmdSetCheckpointNV :: *fn (VkCommandBuffer, C.void_ptr);
PFN_vkGetQueueCheckpointDataNV :: *fn (VkQueue, *u32, *VkCheckpointDataNV);
vkCmdSetCheckpointNV :: fn (commandBuffer: VkCommandBuffer, pCheckpointMarker: C.void_ptr) #extern;
vkGetQueueCheckpointDataNV :: fn (queue: VkQueue, pCheckpointDataCount: *u32, pCheckpointData: *VkCheckpointDataNV) #extern;
VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shaderIntegerFunctions2: VkBool32;
}
VkPerformanceConfigurationTypeINTEL :: enum s32 {
	VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL = 0x0;
	VK_PERFORMANCE_CONFIGURATION_TYPE_MAX_ENUM_INTEL = 0x7fffffff;
}
VkQueryPoolSamplingModeINTEL :: enum s32 {
	VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL = 0x0;
	VK_QUERY_POOL_SAMPLING_MODE_MAX_ENUM_INTEL = 0x7fffffff;
}
VkPerformanceOverrideTypeINTEL :: enum s32 {
	VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL = 0x0;
	VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL = 0x1;
	VK_PERFORMANCE_OVERRIDE_TYPE_MAX_ENUM_INTEL = 0x7fffffff;
}
VkPerformanceParameterTypeINTEL :: enum s32 {
	VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL = 0x0;
	VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL = 0x1;
	VK_PERFORMANCE_PARAMETER_TYPE_MAX_ENUM_INTEL = 0x7fffffff;
}
VkPerformanceValueTypeINTEL :: enum s32 {
	VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL = 0x0;
	VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL = 0x1;
	VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL = 0x2;
	VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL = 0x3;
	VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL = 0x4;
	VK_PERFORMANCE_VALUE_TYPE_MAX_ENUM_INTEL = 0x7fffffff;
}
VkPerformanceValueDataINTEL :: union {
	value32: u32;
	value64: u64;
	valueFloat: f32;
	valueBool: VkBool32;
	valueString: *C.char;
}
VkPerformanceValueINTEL :: struct {
	t: VkPerformanceValueTypeINTEL;
	data: VkPerformanceValueDataINTEL;
}
VkInitializePerformanceApiInfoINTEL :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	pUserData: C.void_ptr;
}
VkQueryPoolPerformanceQueryCreateInfoINTEL :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	performanceCountersSampling: VkQueryPoolSamplingModeINTEL;
}
VkQueryPoolCreateInfoINTEL :: VkQueryPoolPerformanceQueryCreateInfoINTEL;
VkPerformanceMarkerInfoINTEL :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	marker: u64;
}
VkPerformanceStreamMarkerInfoINTEL :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	marker: u32;
}
VkPerformanceOverrideInfoINTEL :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	t: VkPerformanceOverrideTypeINTEL;
	enable: VkBool32;
	parameter: u64;
}
VkPerformanceConfigurationAcquireInfoINTEL :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	t: VkPerformanceConfigurationTypeINTEL;
}
PFN_vkInitializePerformanceApiINTEL :: *fn (VkDevice, *VkInitializePerformanceApiInfoINTEL) VkResult;
PFN_vkUninitializePerformanceApiINTEL :: *fn (VkDevice);
PFN_vkCmdSetPerformanceMarkerINTEL :: *fn (VkCommandBuffer, *VkPerformanceMarkerInfoINTEL) VkResult;
PFN_vkCmdSetPerformanceStreamMarkerINTEL :: *fn (VkCommandBuffer, *VkPerformanceStreamMarkerInfoINTEL) VkResult;
PFN_vkCmdSetPerformanceOverrideINTEL :: *fn (VkCommandBuffer, *VkPerformanceOverrideInfoINTEL) VkResult;
PFN_vkAcquirePerformanceConfigurationINTEL :: *fn (VkDevice, *VkPerformanceConfigurationAcquireInfoINTEL, *VkPerformanceConfigurationINTEL) VkResult;
PFN_vkReleasePerformanceConfigurationINTEL :: *fn (VkDevice, VkPerformanceConfigurationINTEL) VkResult;
PFN_vkQueueSetPerformanceConfigurationINTEL :: *fn (VkQueue, VkPerformanceConfigurationINTEL) VkResult;
PFN_vkGetPerformanceParameterINTEL :: *fn (VkDevice, VkPerformanceParameterTypeINTEL, *VkPerformanceValueINTEL) VkResult;
vkInitializePerformanceApiINTEL :: fn (device: VkDevice, pInitializeInfo: *VkInitializePerformanceApiInfoINTEL) VkResult #extern;
vkUninitializePerformanceApiINTEL :: fn (device: VkDevice) #extern;
vkCmdSetPerformanceMarkerINTEL :: fn (commandBuffer: VkCommandBuffer, pMarkerInfo: *VkPerformanceMarkerInfoINTEL) VkResult #extern;
vkCmdSetPerformanceStreamMarkerINTEL :: fn (commandBuffer: VkCommandBuffer, pMarkerInfo: *VkPerformanceStreamMarkerInfoINTEL) VkResult #extern;
vkCmdSetPerformanceOverrideINTEL :: fn (commandBuffer: VkCommandBuffer, pOverrideInfo: *VkPerformanceOverrideInfoINTEL) VkResult #extern;
vkAcquirePerformanceConfigurationINTEL :: fn (device: VkDevice, pAcquireInfo: *VkPerformanceConfigurationAcquireInfoINTEL, pConfiguration: *VkPerformanceConfigurationINTEL) VkResult #extern;
vkReleasePerformanceConfigurationINTEL :: fn (device: VkDevice, configuration: VkPerformanceConfigurationINTEL) VkResult #extern;
vkQueueSetPerformanceConfigurationINTEL :: fn (queue: VkQueue, configuration: VkPerformanceConfigurationINTEL) VkResult #extern;
vkGetPerformanceParameterINTEL :: fn (device: VkDevice, parameter: VkPerformanceParameterTypeINTEL, pValue: *VkPerformanceValueINTEL) VkResult #extern;
VkPhysicalDevicePCIBusInfoPropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	pciDomain: u32;
	pciBus: u32;
	pciDevice: u32;
	pciFunction: u32;
}
VkDisplayNativeHdrSurfaceCapabilitiesAMD :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	localDimmingSupport: VkBool32;
}
VkSwapchainDisplayNativeHdrCreateInfoAMD :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	localDimmingEnable: VkBool32;
}
PFN_vkSetLocalDimmingAMD :: *fn (VkDevice, VkSwapchainKHR, VkBool32);
vkSetLocalDimmingAMD :: fn (device: VkDevice, swapChain: VkSwapchainKHR, localDimmingEnable: VkBool32) #extern;
VkPhysicalDeviceFragmentDensityMapFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	fragmentDensityMap: VkBool32;
	fragmentDensityMapDynamic: VkBool32;
	fragmentDensityMapNonSubsampledImages: VkBool32;
}
VkPhysicalDeviceFragmentDensityMapPropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	minFragmentDensityTexelSize: VkExtent2D;
	maxFragmentDensityTexelSize: VkExtent2D;
	fragmentDensityInvocations: VkBool32;
}
VkRenderPassFragmentDensityMapCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	fragmentDensityMapAttachment: VkAttachmentReference;
}
VkPhysicalDeviceScalarBlockLayoutFeaturesEXT :: VkPhysicalDeviceScalarBlockLayoutFeatures;
VkPhysicalDeviceSubgroupSizeControlFeaturesEXT :: VkPhysicalDeviceSubgroupSizeControlFeatures;
VkPhysicalDeviceSubgroupSizeControlPropertiesEXT :: VkPhysicalDeviceSubgroupSizeControlProperties;
VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT :: VkPipelineShaderStageRequiredSubgroupSizeCreateInfo;
VkShaderCorePropertiesFlagBitsAMD :: enum s32 {
	VK_SHADER_CORE_PROPERTIES_FLAG_BITS_MAX_ENUM_AMD = 0x7fffffff;
}
VkShaderCorePropertiesFlagsAMD :: VkFlags;
VkPhysicalDeviceShaderCoreProperties2AMD :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shaderCoreFeatures: VkShaderCorePropertiesFlagsAMD;
	activeComputeUnitCount: u32;
}
VkPhysicalDeviceCoherentMemoryFeaturesAMD :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	deviceCoherentMemory: VkBool32;
}
VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shaderImageInt64Atomics: VkBool32;
	sparseImageInt64Atomics: VkBool32;
}
VkPhysicalDeviceMemoryBudgetPropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	heapBudget: [16]VkDeviceSize;
	heapUsage: [16]VkDeviceSize;
}
VkPhysicalDeviceMemoryPriorityFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	memoryPriority: VkBool32;
}
VkMemoryPriorityAllocateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	priority: f32;
}
VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	dedicatedAllocationImageAliasing: VkBool32;
}
VkPhysicalDeviceBufferDeviceAddressFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	bufferDeviceAddress: VkBool32;
	bufferDeviceAddressCaptureReplay: VkBool32;
	bufferDeviceAddressMultiDevice: VkBool32;
}
VkPhysicalDeviceBufferAddressFeaturesEXT :: VkPhysicalDeviceBufferDeviceAddressFeaturesEXT;
VkBufferDeviceAddressInfoEXT :: VkBufferDeviceAddressInfo;
VkBufferDeviceAddressCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	deviceAddress: VkDeviceAddress;
}
PFN_vkGetBufferDeviceAddressEXT :: *fn (VkDevice, *VkBufferDeviceAddressInfo) VkDeviceAddress;
vkGetBufferDeviceAddressEXT :: fn (device: VkDevice, pInfo: *VkBufferDeviceAddressInfo) VkDeviceAddress #extern;
VkToolPurposeFlagBitsEXT :: VkToolPurposeFlagBits;
VkToolPurposeFlagsEXT :: VkToolPurposeFlags;
VkPhysicalDeviceToolPropertiesEXT :: VkPhysicalDeviceToolProperties;
PFN_vkGetPhysicalDeviceToolPropertiesEXT :: *fn (VkPhysicalDevice, *u32, *VkPhysicalDeviceToolProperties) VkResult;
vkGetPhysicalDeviceToolPropertiesEXT :: fn (physicalDevice: VkPhysicalDevice, pToolCount: *u32, pToolProperties: *VkPhysicalDeviceToolProperties) VkResult #extern;
VkImageStencilUsageCreateInfoEXT :: VkImageStencilUsageCreateInfo;
VkValidationFeatureEnableEXT :: enum s32 {
	VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT = 0x0;
	VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT = 0x1;
	VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT = 0x2;
	VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT = 0x3;
	VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT = 0x4;
	VK_VALIDATION_FEATURE_ENABLE_MAX_ENUM_EXT = 0x7fffffff;
}
VkValidationFeatureDisableEXT :: enum s32 {
	VK_VALIDATION_FEATURE_DISABLE_ALL_EXT = 0x0;
	VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT = 0x1;
	VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT = 0x2;
	VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT = 0x3;
	VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT = 0x4;
	VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT = 0x5;
	VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT = 0x6;
	VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT = 0x7;
	VK_VALIDATION_FEATURE_DISABLE_MAX_ENUM_EXT = 0x7fffffff;
}
VkValidationFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	enabledValidationFeatureCount: u32;
	pEnabledValidationFeatures: *VkValidationFeatureEnableEXT;
	disabledValidationFeatureCount: u32;
	pDisabledValidationFeatures: *VkValidationFeatureDisableEXT;
}
VkComponentTypeNV :: enum s32 {
	VK_COMPONENT_TYPE_FLOAT16_NV = 0x0;
	VK_COMPONENT_TYPE_FLOAT32_NV = 0x1;
	VK_COMPONENT_TYPE_FLOAT64_NV = 0x2;
	VK_COMPONENT_TYPE_SINT8_NV = 0x3;
	VK_COMPONENT_TYPE_SINT16_NV = 0x4;
	VK_COMPONENT_TYPE_SINT32_NV = 0x5;
	VK_COMPONENT_TYPE_SINT64_NV = 0x6;
	VK_COMPONENT_TYPE_UINT8_NV = 0x7;
	VK_COMPONENT_TYPE_UINT16_NV = 0x8;
	VK_COMPONENT_TYPE_UINT32_NV = 0x9;
	VK_COMPONENT_TYPE_UINT64_NV = 0xa;
	VK_COMPONENT_TYPE_MAX_ENUM_NV = 0x7fffffff;
}
VkScopeNV :: enum s32 {
	VK_SCOPE_DEVICE_NV = 0x1;
	VK_SCOPE_WORKGROUP_NV = 0x2;
	VK_SCOPE_SUBGROUP_NV = 0x3;
	VK_SCOPE_QUEUE_FAMILY_NV = 0x5;
	VK_SCOPE_MAX_ENUM_NV = 0x7fffffff;
}
VkCooperativeMatrixPropertiesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	MSize: u32;
	NSize: u32;
	KSize: u32;
	AType: VkComponentTypeNV;
	BType: VkComponentTypeNV;
	CType: VkComponentTypeNV;
	DType: VkComponentTypeNV;
	scope: VkScopeNV;
}
VkPhysicalDeviceCooperativeMatrixFeaturesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	cooperativeMatrix: VkBool32;
	cooperativeMatrixRobustBufferAccess: VkBool32;
}
VkPhysicalDeviceCooperativeMatrixPropertiesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	cooperativeMatrixSupportedStages: VkShaderStageFlags;
}
PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV :: *fn (VkPhysicalDevice, *u32, *VkCooperativeMatrixPropertiesNV) VkResult;
vkGetPhysicalDeviceCooperativeMatrixPropertiesNV :: fn (physicalDevice: VkPhysicalDevice, pPropertyCount: *u32, pProperties: *VkCooperativeMatrixPropertiesNV) VkResult #extern;
VkCoverageReductionModeNV :: enum s32 {
	VK_COVERAGE_REDUCTION_MODE_MERGE_NV = 0x0;
	VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV = 0x1;
	VK_COVERAGE_REDUCTION_MODE_MAX_ENUM_NV = 0x7fffffff;
}
VkPipelineCoverageReductionStateCreateFlagsNV :: VkFlags;
VkPhysicalDeviceCoverageReductionModeFeaturesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	coverageReductionMode: VkBool32;
}
VkPipelineCoverageReductionStateCreateInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkPipelineCoverageReductionStateCreateFlagsNV;
	coverageReductionMode: VkCoverageReductionModeNV;
}
VkFramebufferMixedSamplesCombinationNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	coverageReductionMode: VkCoverageReductionModeNV;
	rasterizationSamples: VkSampleCountFlagBits;
	depthStencilSamples: VkSampleCountFlags;
	colorSamples: VkSampleCountFlags;
}
PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV :: *fn (VkPhysicalDevice, *u32, *VkFramebufferMixedSamplesCombinationNV) VkResult;
vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV :: fn (physicalDevice: VkPhysicalDevice, pCombinationCount: *u32, pCombinations: *VkFramebufferMixedSamplesCombinationNV) VkResult #extern;
VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	fragmentShaderSampleInterlock: VkBool32;
	fragmentShaderPixelInterlock: VkBool32;
	fragmentShaderShadingRateInterlock: VkBool32;
}
VkPhysicalDeviceYcbcrImageArraysFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	ycbcrImageArrays: VkBool32;
}
VkProvokingVertexModeEXT :: enum s32 {
	VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT = 0x0;
	VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT = 0x1;
	VK_PROVOKING_VERTEX_MODE_MAX_ENUM_EXT = 0x7fffffff;
}
VkPhysicalDeviceProvokingVertexFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	provokingVertexLast: VkBool32;
	transformFeedbackPreservesProvokingVertex: VkBool32;
}
VkPhysicalDeviceProvokingVertexPropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	provokingVertexModePerPipeline: VkBool32;
	transformFeedbackPreservesTriangleFanProvokingVertex: VkBool32;
}
VkPipelineRasterizationProvokingVertexStateCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	provokingVertexMode: VkProvokingVertexModeEXT;
}
VkHeadlessSurfaceCreateFlagsEXT :: VkFlags;
VkHeadlessSurfaceCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkHeadlessSurfaceCreateFlagsEXT;
}
PFN_vkCreateHeadlessSurfaceEXT :: *fn (VkInstance, *VkHeadlessSurfaceCreateInfoEXT, *VkAllocationCallbacks, *VkSurfaceKHR) VkResult;
vkCreateHeadlessSurfaceEXT :: fn (instance: VkInstance, pCreateInfo: *VkHeadlessSurfaceCreateInfoEXT, pAllocator: *VkAllocationCallbacks, pSurface: *VkSurfaceKHR) VkResult #extern;
VkLineRasterizationModeEXT :: enum s32 {
	VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT = 0x0;
	VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT = 0x1;
	VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT = 0x2;
	VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT = 0x3;
	VK_LINE_RASTERIZATION_MODE_MAX_ENUM_EXT = 0x7fffffff;
}
VkPhysicalDeviceLineRasterizationFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	rectangularLines: VkBool32;
	bresenhamLines: VkBool32;
	smoothLines: VkBool32;
	stippledRectangularLines: VkBool32;
	stippledBresenhamLines: VkBool32;
	stippledSmoothLines: VkBool32;
}
VkPhysicalDeviceLineRasterizationPropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	lineSubPixelPrecisionBits: u32;
}
VkPipelineRasterizationLineStateCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	lineRasterizationMode: VkLineRasterizationModeEXT;
	stippledLineEnable: VkBool32;
	lineStippleFactor: u32;
	lineStipplePattern: u16;
}
PFN_vkCmdSetLineStippleEXT :: *fn (VkCommandBuffer, u32, u16);
vkCmdSetLineStippleEXT :: fn (commandBuffer: VkCommandBuffer, lineStippleFactor: u32, lineStipplePattern: u16) #extern;
VkPhysicalDeviceShaderAtomicFloatFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shaderBufferFloat32Atomics: VkBool32;
	shaderBufferFloat32AtomicAdd: VkBool32;
	shaderBufferFloat64Atomics: VkBool32;
	shaderBufferFloat64AtomicAdd: VkBool32;
	shaderSharedFloat32Atomics: VkBool32;
	shaderSharedFloat32AtomicAdd: VkBool32;
	shaderSharedFloat64Atomics: VkBool32;
	shaderSharedFloat64AtomicAdd: VkBool32;
	shaderImageFloat32Atomics: VkBool32;
	shaderImageFloat32AtomicAdd: VkBool32;
	sparseImageFloat32Atomics: VkBool32;
	sparseImageFloat32AtomicAdd: VkBool32;
}
VkPhysicalDeviceHostQueryResetFeaturesEXT :: VkPhysicalDeviceHostQueryResetFeatures;
PFN_vkResetQueryPoolEXT :: *fn (VkDevice, VkQueryPool, u32, u32);
vkResetQueryPoolEXT :: fn (device: VkDevice, queryPool: VkQueryPool, firstQuery: u32, queryCount: u32) #extern;
VkPhysicalDeviceIndexTypeUint8FeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	indexTypeUint8: VkBool32;
}
VkPhysicalDeviceExtendedDynamicStateFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	extendedDynamicState: VkBool32;
}
PFN_vkCmdSetCullModeEXT :: *fn (VkCommandBuffer, VkCullModeFlags);
PFN_vkCmdSetFrontFaceEXT :: *fn (VkCommandBuffer, VkFrontFace);
PFN_vkCmdSetPrimitiveTopologyEXT :: *fn (VkCommandBuffer, VkPrimitiveTopology);
PFN_vkCmdSetViewportWithCountEXT :: *fn (VkCommandBuffer, u32, *VkViewport);
PFN_vkCmdSetScissorWithCountEXT :: *fn (VkCommandBuffer, u32, *VkRect2D);
PFN_vkCmdBindVertexBuffers2EXT :: *fn (VkCommandBuffer, u32, u32, *VkBuffer, *VkDeviceSize, *VkDeviceSize, *VkDeviceSize);
PFN_vkCmdSetDepthTestEnableEXT :: *fn (VkCommandBuffer, VkBool32);
PFN_vkCmdSetDepthWriteEnableEXT :: *fn (VkCommandBuffer, VkBool32);
PFN_vkCmdSetDepthCompareOpEXT :: *fn (VkCommandBuffer, VkCompareOp);
PFN_vkCmdSetDepthBoundsTestEnableEXT :: *fn (VkCommandBuffer, VkBool32);
PFN_vkCmdSetStencilTestEnableEXT :: *fn (VkCommandBuffer, VkBool32);
PFN_vkCmdSetStencilOpEXT :: *fn (VkCommandBuffer, VkStencilFaceFlags, VkStencilOp, VkStencilOp, VkStencilOp, VkCompareOp);
vkCmdSetCullModeEXT :: fn (commandBuffer: VkCommandBuffer, cullMode: VkCullModeFlags) #extern;
vkCmdSetFrontFaceEXT :: fn (commandBuffer: VkCommandBuffer, frontFace: VkFrontFace) #extern;
vkCmdSetPrimitiveTopologyEXT :: fn (commandBuffer: VkCommandBuffer, primitiveTopology: VkPrimitiveTopology) #extern;
vkCmdSetViewportWithCountEXT :: fn (commandBuffer: VkCommandBuffer, viewportCount: u32, pViewports: *VkViewport) #extern;
vkCmdSetScissorWithCountEXT :: fn (commandBuffer: VkCommandBuffer, scissorCount: u32, pScissors: *VkRect2D) #extern;
vkCmdBindVertexBuffers2EXT :: fn (commandBuffer: VkCommandBuffer, firstBinding: u32, bindingCount: u32, pBuffers: *VkBuffer, pOffsets: *VkDeviceSize, pSizes: *VkDeviceSize, pStrides: *VkDeviceSize) #extern;
vkCmdSetDepthTestEnableEXT :: fn (commandBuffer: VkCommandBuffer, depthTestEnable: VkBool32) #extern;
vkCmdSetDepthWriteEnableEXT :: fn (commandBuffer: VkCommandBuffer, depthWriteEnable: VkBool32) #extern;
vkCmdSetDepthCompareOpEXT :: fn (commandBuffer: VkCommandBuffer, depthCompareOp: VkCompareOp) #extern;
vkCmdSetDepthBoundsTestEnableEXT :: fn (commandBuffer: VkCommandBuffer, depthBoundsTestEnable: VkBool32) #extern;
vkCmdSetStencilTestEnableEXT :: fn (commandBuffer: VkCommandBuffer, stencilTestEnable: VkBool32) #extern;
vkCmdSetStencilOpEXT :: fn (commandBuffer: VkCommandBuffer, faceMask: VkStencilFaceFlags, failOp: VkStencilOp, passOp: VkStencilOp, depthFailOp: VkStencilOp, compareOp: VkCompareOp) #extern;
VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shaderBufferFloat16Atomics: VkBool32;
	shaderBufferFloat16AtomicAdd: VkBool32;
	shaderBufferFloat16AtomicMinMax: VkBool32;
	shaderBufferFloat32AtomicMinMax: VkBool32;
	shaderBufferFloat64AtomicMinMax: VkBool32;
	shaderSharedFloat16Atomics: VkBool32;
	shaderSharedFloat16AtomicAdd: VkBool32;
	shaderSharedFloat16AtomicMinMax: VkBool32;
	shaderSharedFloat32AtomicMinMax: VkBool32;
	shaderSharedFloat64AtomicMinMax: VkBool32;
	shaderImageFloat32AtomicMinMax: VkBool32;
	sparseImageFloat32AtomicMinMax: VkBool32;
}
VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT :: VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures;
VkIndirectCommandsTokenTypeNV :: enum s32 {
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV = 0x0;
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV = 0x1;
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV = 0x2;
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV = 0x3;
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV = 0x4;
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV = 0x5;
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV = 0x6;
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV = 0x7;
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV = 0x3b9fcb40;
	VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NV = 0x7fffffff;
}
VkIndirectStateFlagBitsNV :: enum s32 {
	VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV = 0x1;
	VK_INDIRECT_STATE_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff;
}
VkIndirectStateFlagsNV :: VkFlags;
VkIndirectCommandsLayoutUsageFlagBitsNV :: enum s32 {
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV = 0x1;
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV = 0x2;
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV = 0x4;
	VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff;
}
VkIndirectCommandsLayoutUsageFlagsNV :: VkFlags;
VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	maxGraphicsShaderGroupCount: u32;
	maxIndirectSequenceCount: u32;
	maxIndirectCommandsTokenCount: u32;
	maxIndirectCommandsStreamCount: u32;
	maxIndirectCommandsTokenOffset: u32;
	maxIndirectCommandsStreamStride: u32;
	minSequencesCountBufferOffsetAlignment: u32;
	minSequencesIndexBufferOffsetAlignment: u32;
	minIndirectCommandsBufferOffsetAlignment: u32;
}
VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	deviceGeneratedCommands: VkBool32;
}
VkGraphicsShaderGroupCreateInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	stageCount: u32;
	pStages: *VkPipelineShaderStageCreateInfo;
	pVertexInputState: *VkPipelineVertexInputStateCreateInfo;
	pTessellationState: *VkPipelineTessellationStateCreateInfo;
}
VkGraphicsPipelineShaderGroupsCreateInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	groupCount: u32;
	pGroups: *VkGraphicsShaderGroupCreateInfoNV;
	pipelineCount: u32;
	pPipelines: *VkPipeline;
}
VkBindShaderGroupIndirectCommandNV :: struct {
	groupIndex: u32;
}
VkBindIndexBufferIndirectCommandNV :: struct {
	bufferAddress: VkDeviceAddress;
	size: u32;
	indexType: VkIndexType;
}
VkBindVertexBufferIndirectCommandNV :: struct {
	bufferAddress: VkDeviceAddress;
	size: u32;
	stride: u32;
}
VkSetStateFlagsIndirectCommandNV :: struct {
	data: u32;
}
VkIndirectCommandsStreamNV :: struct {
	buffer: VkBuffer;
	offset: VkDeviceSize;
}
VkIndirectCommandsLayoutTokenNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	tokenType: VkIndirectCommandsTokenTypeNV;
	stream: u32;
	offset: u32;
	vertexBindingUnit: u32;
	vertexDynamicStride: VkBool32;
	pushconstantPipelineLayout: VkPipelineLayout;
	pushconstantShaderStageFlags: VkShaderStageFlags;
	pushconstantOffset: u32;
	pushconstantSize: u32;
	indirectStateFlags: VkIndirectStateFlagsNV;
	indexTypeCount: u32;
	pIndexTypes: *VkIndexType;
	pIndexTypeValues: *u32;
}
VkIndirectCommandsLayoutCreateInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkIndirectCommandsLayoutUsageFlagsNV;
	pipelineBindPoint: VkPipelineBindPoint;
	tokenCount: u32;
	pTokens: *VkIndirectCommandsLayoutTokenNV;
	streamCount: u32;
	pStreamStrides: *u32;
}
VkGeneratedCommandsInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	pipelineBindPoint: VkPipelineBindPoint;
	pipeline: VkPipeline;
	indirectCommandsLayout: VkIndirectCommandsLayoutNV;
	streamCount: u32;
	pStreams: *VkIndirectCommandsStreamNV;
	sequencesCount: u32;
	preprocessBuffer: VkBuffer;
	preprocessOffset: VkDeviceSize;
	preprocessSize: VkDeviceSize;
	sequencesCountBuffer: VkBuffer;
	sequencesCountOffset: VkDeviceSize;
	sequencesIndexBuffer: VkBuffer;
	sequencesIndexOffset: VkDeviceSize;
}
VkGeneratedCommandsMemoryRequirementsInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	pipelineBindPoint: VkPipelineBindPoint;
	pipeline: VkPipeline;
	indirectCommandsLayout: VkIndirectCommandsLayoutNV;
	maxSequencesCount: u32;
}
PFN_vkGetGeneratedCommandsMemoryRequirementsNV :: *fn (VkDevice, *VkGeneratedCommandsMemoryRequirementsInfoNV, *VkMemoryRequirements2);
PFN_vkCmdPreprocessGeneratedCommandsNV :: *fn (VkCommandBuffer, *VkGeneratedCommandsInfoNV);
PFN_vkCmdExecuteGeneratedCommandsNV :: *fn (VkCommandBuffer, VkBool32, *VkGeneratedCommandsInfoNV);
PFN_vkCmdBindPipelineShaderGroupNV :: *fn (VkCommandBuffer, VkPipelineBindPoint, VkPipeline, u32);
PFN_vkCreateIndirectCommandsLayoutNV :: *fn (VkDevice, *VkIndirectCommandsLayoutCreateInfoNV, *VkAllocationCallbacks, *VkIndirectCommandsLayoutNV) VkResult;
PFN_vkDestroyIndirectCommandsLayoutNV :: *fn (VkDevice, VkIndirectCommandsLayoutNV, *VkAllocationCallbacks);
vkGetGeneratedCommandsMemoryRequirementsNV :: fn (device: VkDevice, pInfo: *VkGeneratedCommandsMemoryRequirementsInfoNV, pMemoryRequirements: *VkMemoryRequirements2) #extern;
vkCmdPreprocessGeneratedCommandsNV :: fn (commandBuffer: VkCommandBuffer, pGeneratedCommandsInfo: *VkGeneratedCommandsInfoNV) #extern;
vkCmdExecuteGeneratedCommandsNV :: fn (commandBuffer: VkCommandBuffer, isPreprocessed: VkBool32, pGeneratedCommandsInfo: *VkGeneratedCommandsInfoNV) #extern;
vkCmdBindPipelineShaderGroupNV :: fn (commandBuffer: VkCommandBuffer, pipelineBindPoint: VkPipelineBindPoint, pipeline: VkPipeline, groupIndex: u32) #extern;
vkCreateIndirectCommandsLayoutNV :: fn (device: VkDevice, pCreateInfo: *VkIndirectCommandsLayoutCreateInfoNV, pAllocator: *VkAllocationCallbacks, pIndirectCommandsLayout: *VkIndirectCommandsLayoutNV) VkResult #extern;
vkDestroyIndirectCommandsLayoutNV :: fn (device: VkDevice, indirectCommandsLayout: VkIndirectCommandsLayoutNV, pAllocator: *VkAllocationCallbacks) #extern;
VkPhysicalDeviceInheritedViewportScissorFeaturesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	inheritedViewportScissor2D: VkBool32;
}
VkCommandBufferInheritanceViewportScissorInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	viewportScissor2D: VkBool32;
	viewportDepthCount: u32;
	pViewportDepths: *VkViewport;
}
VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	texelBufferAlignment: VkBool32;
}
VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT :: VkPhysicalDeviceTexelBufferAlignmentProperties;
VkRenderPassTransformBeginInfoQCOM :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	transform: VkSurfaceTransformFlagBitsKHR;
}
VkCommandBufferInheritanceRenderPassTransformInfoQCOM :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	transform: VkSurfaceTransformFlagBitsKHR;
	renderArea: VkRect2D;
}
VkDeviceMemoryReportEventTypeEXT :: enum s32 {
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT = 0x0;
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT = 0x1;
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT = 0x2;
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT = 0x3;
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT = 0x4;
	VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_MAX_ENUM_EXT = 0x7fffffff;
}
VkDeviceMemoryReportFlagsEXT :: VkFlags;
VkPhysicalDeviceDeviceMemoryReportFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	deviceMemoryReport: VkBool32;
}
VkDeviceMemoryReportCallbackDataEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkDeviceMemoryReportFlagsEXT;
	t: VkDeviceMemoryReportEventTypeEXT;
	memoryObjectId: u64;
	size: VkDeviceSize;
	objectType: VkObjectType;
	objectHandle: u64;
	heapIndex: u32;
}
PFN_vkDeviceMemoryReportCallbackEXT :: *fn (*VkDeviceMemoryReportCallbackDataEXT, C.void_ptr);
VkDeviceDeviceMemoryReportCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkDeviceMemoryReportFlagsEXT;
	pfnUserCallback: PFN_vkDeviceMemoryReportCallbackEXT;
	pUserData: C.void_ptr;
}
PFN_vkAcquireDrmDisplayEXT :: *fn (VkPhysicalDevice, s32, VkDisplayKHR) VkResult;
PFN_vkGetDrmDisplayEXT :: *fn (VkPhysicalDevice, s32, u32, *VkDisplayKHR) VkResult;
vkAcquireDrmDisplayEXT :: fn (physicalDevice: VkPhysicalDevice, drmFd: s32, display: VkDisplayKHR) VkResult #extern;
vkGetDrmDisplayEXT :: fn (physicalDevice: VkPhysicalDevice, drmFd: s32, connectorId: u32, display: *VkDisplayKHR) VkResult #extern;
VkPhysicalDeviceRobustness2FeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	robustBufferAccess2: VkBool32;
	robustImageAccess2: VkBool32;
	nullDescriptor: VkBool32;
}
VkPhysicalDeviceRobustness2PropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	robustStorageBufferAccessSizeAlignment: VkDeviceSize;
	robustUniformBufferAccessSizeAlignment: VkDeviceSize;
}
VkSamplerCustomBorderColorCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	customBorderColor: VkClearColorValue;
	format: VkFormat;
}
VkPhysicalDeviceCustomBorderColorPropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	maxCustomBorderColorSamplers: u32;
}
VkPhysicalDeviceCustomBorderColorFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	customBorderColors: VkBool32;
	customBorderColorWithoutFormat: VkBool32;
}
VkPhysicalDevicePresentBarrierFeaturesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	presentBarrier: VkBool32;
}
VkSurfaceCapabilitiesPresentBarrierNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	presentBarrierSupported: VkBool32;
}
VkSwapchainPresentBarrierCreateInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	presentBarrierEnable: VkBool32;
}
VkPrivateDataSlotEXT :: VkPrivateDataSlot;
VkPrivateDataSlotCreateFlagsEXT :: VkPrivateDataSlotCreateFlags;
VkPhysicalDevicePrivateDataFeaturesEXT :: VkPhysicalDevicePrivateDataFeatures;
VkDevicePrivateDataCreateInfoEXT :: VkDevicePrivateDataCreateInfo;
VkPrivateDataSlotCreateInfoEXT :: VkPrivateDataSlotCreateInfo;
PFN_vkCreatePrivateDataSlotEXT :: *fn (VkDevice, *VkPrivateDataSlotCreateInfo, *VkAllocationCallbacks, *VkPrivateDataSlot) VkResult;
PFN_vkDestroyPrivateDataSlotEXT :: *fn (VkDevice, VkPrivateDataSlot, *VkAllocationCallbacks);
PFN_vkSetPrivateDataEXT :: *fn (VkDevice, VkObjectType, u64, VkPrivateDataSlot, u64) VkResult;
PFN_vkGetPrivateDataEXT :: *fn (VkDevice, VkObjectType, u64, VkPrivateDataSlot, *u64);
vkCreatePrivateDataSlotEXT :: fn (device: VkDevice, pCreateInfo: *VkPrivateDataSlotCreateInfo, pAllocator: *VkAllocationCallbacks, pPrivateDataSlot: *VkPrivateDataSlot) VkResult #extern;
vkDestroyPrivateDataSlotEXT :: fn (device: VkDevice, privateDataSlot: VkPrivateDataSlot, pAllocator: *VkAllocationCallbacks) #extern;
vkSetPrivateDataEXT :: fn (device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, data: u64) VkResult #extern;
vkGetPrivateDataEXT :: fn (device: VkDevice, objectType: VkObjectType, objectHandle: u64, privateDataSlot: VkPrivateDataSlot, pData: *u64) #extern;
VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT :: VkPhysicalDevicePipelineCreationCacheControlFeatures;
VkDeviceDiagnosticsConfigFlagBitsNV :: enum s32 {
	VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV = 0x1;
	VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV = 0x2;
	VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV = 0x4;
	VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV = 0x8;
	VK_DEVICE_DIAGNOSTICS_CONFIG_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff;
}
VkDeviceDiagnosticsConfigFlagsNV :: VkFlags;
VkPhysicalDeviceDiagnosticsConfigFeaturesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	diagnosticsConfig: VkBool32;
}
VkDeviceDiagnosticsConfigCreateInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkDeviceDiagnosticsConfigFlagsNV;
}
VkGraphicsPipelineLibraryFlagBitsEXT :: enum u32 #flags {
	VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT = 0x1;
	VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT = 0x2;
	VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT = 0x4;
	VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT = 0x8;
	VK_GRAPHICS_PIPELINE_LIBRARY_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff;
}
VkGraphicsPipelineLibraryFlagsEXT :: VkFlags;
VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	graphicsPipelineLibrary: VkBool32;
}
VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	graphicsPipelineLibraryFastLinking: VkBool32;
	graphicsPipelineLibraryIndependentInterpolationDecoration: VkBool32;
}
VkGraphicsPipelineLibraryCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkGraphicsPipelineLibraryFlagsEXT;
}
VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shaderEarlyAndLateFragmentTests: VkBool32;
}
VkFragmentShadingRateTypeNV :: enum s32 {
	VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV = 0x0;
	VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV = 0x1;
	VK_FRAGMENT_SHADING_RATE_TYPE_MAX_ENUM_NV = 0x7fffffff;
}
VkFragmentShadingRateNV :: enum s32 {
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV = 0x0;
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV = 0x1;
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV = 0x4;
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV = 0x5;
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV = 0x6;
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV = 0x9;
	VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV = 0xa;
	VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV = 0xb;
	VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV = 0xc;
	VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV = 0xd;
	VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV = 0xe;
	VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV = 0xf;
	VK_FRAGMENT_SHADING_RATE_MAX_ENUM_NV = 0x7fffffff;
}
VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	fragmentShadingRateEnums: VkBool32;
	supersampleFragmentShadingRates: VkBool32;
	noInvocationFragmentShadingRates: VkBool32;
}
VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	maxFragmentShadingRateInvocationCount: VkSampleCountFlagBits;
}
VkPipelineFragmentShadingRateEnumStateCreateInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shadingRateType: VkFragmentShadingRateTypeNV;
	shadingRate: VkFragmentShadingRateNV;
	combinerOps: [2]VkFragmentShadingRateCombinerOpKHR;
}
PFN_vkCmdSetFragmentShadingRateEnumNV :: *fn (VkCommandBuffer, VkFragmentShadingRateNV, [2]VkFragmentShadingRateCombinerOpKHR);
vkCmdSetFragmentShadingRateEnumNV :: fn (commandBuffer: VkCommandBuffer, shadingRate: VkFragmentShadingRateNV, combinerOps: [2]VkFragmentShadingRateCombinerOpKHR) #extern;
VkAccelerationStructureMotionInstanceTypeNV :: enum s32 {
	VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV = 0x0;
	VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV = 0x1;
	VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV = 0x2;
	VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MAX_ENUM_NV = 0x7fffffff;
}
VkAccelerationStructureMotionInfoFlagsNV :: VkFlags;
VkAccelerationStructureMotionInstanceFlagsNV :: VkFlags;
VkDeviceOrHostAddressConstKHR :: union {
	deviceAddress: VkDeviceAddress;
	hostAddress: C.void_ptr;
}
VkAccelerationStructureGeometryMotionTrianglesDataNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	vertexData: VkDeviceOrHostAddressConstKHR;
}
VkAccelerationStructureMotionInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	maxInstances: u32;
	flags: VkAccelerationStructureMotionInfoFlagsNV;
}
VkAccelerationStructureMatrixMotionInstanceNV :: struct {
	transformT0: VkTransformMatrixKHR;
	transformT1: VkTransformMatrixKHR;
	instanceCustomIndex: u32;
	mask: u32;
	instanceShaderBindingTableRecordOffset: u32;
	flags: VkGeometryInstanceFlagsKHR;
	accelerationStructureReference: u64;
}
VkSRTDataNV :: struct {
	sx: f32;
	a: f32;
	b: f32;
	pvx: f32;
	sy: f32;
	c: f32;
	pvy: f32;
	sz: f32;
	pvz: f32;
	qx: f32;
	qy: f32;
	qz: f32;
	qw: f32;
	tx: f32;
	ty: f32;
	tz: f32;
}
VkAccelerationStructureSRTMotionInstanceNV :: struct {
	transformT0: VkSRTDataNV;
	transformT1: VkSRTDataNV;
	instanceCustomIndex: u32;
	mask: u32;
	instanceShaderBindingTableRecordOffset: u32;
	flags: VkGeometryInstanceFlagsKHR;
	accelerationStructureReference: u64;
}
VkAccelerationStructureMotionInstanceDataNV :: union {
	staticInstance: VkAccelerationStructureInstanceKHR;
	matrixMotionInstance: VkAccelerationStructureMatrixMotionInstanceNV;
	srtMotionInstance: VkAccelerationStructureSRTMotionInstanceNV;
}
VkAccelerationStructureMotionInstanceNV :: struct {
	t: VkAccelerationStructureMotionInstanceTypeNV;
	flags: VkAccelerationStructureMotionInstanceFlagsNV;
	data: VkAccelerationStructureMotionInstanceDataNV;
}
VkPhysicalDeviceRayTracingMotionBlurFeaturesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	rayTracingMotionBlur: VkBool32;
	rayTracingMotionBlurPipelineTraceRaysIndirect: VkBool32;
}
VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	ycbcr2plane444Formats: VkBool32;
}
VkPhysicalDeviceFragmentDensityMap2FeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	fragmentDensityMapDeferred: VkBool32;
}
VkPhysicalDeviceFragmentDensityMap2PropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	subsampledLoads: VkBool32;
	subsampledCoarseReconstructionEarlyAccess: VkBool32;
	maxSubsampledArrayLayers: u32;
	maxDescriptorSetSubsampledSamplers: u32;
}
VkCopyCommandTransformInfoQCOM :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	transform: VkSurfaceTransformFlagBitsKHR;
}
VkPhysicalDeviceImageRobustnessFeaturesEXT :: VkPhysicalDeviceImageRobustnessFeatures;
VkImageCompressionFlagBitsEXT :: enum u32 #flags {
	VK_IMAGE_COMPRESSION_DEFAULT_EXT = 0x0;
	VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT = 0x1;
	VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT = 0x2;
	VK_IMAGE_COMPRESSION_DISABLED_EXT = 0x4;
	VK_IMAGE_COMPRESSION_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff;
}
VkImageCompressionFlagsEXT :: VkFlags;
VkImageCompressionFixedRateFlagBitsEXT :: enum u32 #flags {
	VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT = 0x0;
	VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT = 0x1;
	VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT = 0x2;
	VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT = 0x4;
	VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT = 0x8;
	VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT = 0x10;
	VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT = 0x20;
	VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT = 0x40;
	VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT = 0x80;
	VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT = 0x100;
	VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT = 0x200;
	VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT = 0x400;
	VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT = 0x800;
	VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT = 0x1000;
	VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT = 0x2000;
	VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT = 0x4000;
	VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT = 0x8000;
	VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT = 0x10000;
	VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT = 0x20000;
	VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT = 0x40000;
	VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT = 0x80000;
	VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT = 0x100000;
	VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT = 0x200000;
	VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT = 0x400000;
	VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT = 0x800000;
	VK_IMAGE_COMPRESSION_FIXED_RATE_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff;
}
VkImageCompressionFixedRateFlagsEXT :: VkFlags;
VkPhysicalDeviceImageCompressionControlFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	imageCompressionControl: VkBool32;
}
VkImageCompressionControlEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkImageCompressionFlagsEXT;
	compressionControlPlaneCount: u32;
	pFixedRateFlags: *VkImageCompressionFixedRateFlagsEXT;
}
VkSubresourceLayout2EXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	subresourceLayout: VkSubresourceLayout;
}
VkImageSubresource2EXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	imageSubresource: VkImageSubresource;
}
VkImageCompressionPropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	imageCompressionFlags: VkImageCompressionFlagsEXT;
	imageCompressionFixedRateFlags: VkImageCompressionFixedRateFlagsEXT;
}
PFN_vkGetImageSubresourceLayout2EXT :: *fn (VkDevice, VkImage, *VkImageSubresource2EXT, *VkSubresourceLayout2EXT);
vkGetImageSubresourceLayout2EXT :: fn (device: VkDevice, image: VkImage, pSubresource: *VkImageSubresource2EXT, pLayout: *VkSubresourceLayout2EXT) #extern;
VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	attachmentFeedbackLoopLayout: VkBool32;
}
VkPhysicalDevice4444FormatsFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	formatA4R4G4B4: VkBool32;
	formatA4B4G4R4: VkBool32;
}
VkDeviceFaultAddressTypeEXT :: enum s32 {
	VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT = 0x0;
	VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT = 0x1;
	VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT = 0x2;
	VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT = 0x3;
	VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT = 0x4;
	VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT = 0x5;
	VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT = 0x6;
	VK_DEVICE_FAULT_ADDRESS_TYPE_MAX_ENUM_EXT = 0x7fffffff;
}
VkDeviceFaultVendorBinaryHeaderVersionEXT :: enum s32 {
	VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT = 0x1;
	VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_MAX_ENUM_EXT = 0x7fffffff;
}
VkPhysicalDeviceFaultFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	deviceFault: VkBool32;
	deviceFaultVendorBinary: VkBool32;
}
VkDeviceFaultCountsEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	addressInfoCount: u32;
	vendorInfoCount: u32;
	vendorBinarySize: VkDeviceSize;
}
VkDeviceFaultAddressInfoEXT :: struct {
	addressType: VkDeviceFaultAddressTypeEXT;
	reportedAddress: VkDeviceAddress;
	addressPrecision: VkDeviceSize;
}
VkDeviceFaultVendorInfoEXT :: struct {
	description: [256]C.char;
	vendorFaultCode: u64;
	vendorFaultData: u64;
}
VkDeviceFaultInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	description: [256]C.char;
	pAddressInfos: *VkDeviceFaultAddressInfoEXT;
	pVendorInfos: *VkDeviceFaultVendorInfoEXT;
	pVendorBinaryData: C.void_ptr;
}
VkDeviceFaultVendorBinaryHeaderVersionOneEXT :: struct {
	headerSize: u32;
	headerVersion: VkDeviceFaultVendorBinaryHeaderVersionEXT;
	vendorID: u32;
	deviceID: u32;
	driverVersion: u32;
	pipelineCacheUUID: [16]u8;
	applicationNameOffset: u32;
	applicationVersion: u32;
	engineNameOffset: u32;
}
PFN_vkGetDeviceFaultInfoEXT :: *fn (VkDevice, *VkDeviceFaultCountsEXT, *VkDeviceFaultInfoEXT) VkResult;
vkGetDeviceFaultInfoEXT :: fn (device: VkDevice, pFaultCounts: *VkDeviceFaultCountsEXT, pFaultInfo: *VkDeviceFaultInfoEXT) VkResult #extern;
VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	rasterizationOrderColorAttachmentAccess: VkBool32;
	rasterizationOrderDepthAttachmentAccess: VkBool32;
	rasterizationOrderStencilAttachmentAccess: VkBool32;
}
VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM :: VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT;
VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	formatRgba10x6WithoutYCbCrSampler: VkBool32;
}
PFN_vkAcquireWinrtDisplayNV :: *fn (VkPhysicalDevice, VkDisplayKHR) VkResult;
PFN_vkGetWinrtDisplayNV :: *fn (VkPhysicalDevice, u32, *VkDisplayKHR) VkResult;
vkAcquireWinrtDisplayNV :: fn (physicalDevice: VkPhysicalDevice, display: VkDisplayKHR) VkResult #extern;
vkGetWinrtDisplayNV :: fn (physicalDevice: VkPhysicalDevice, deviceRelativeId: u32, pDisplay: *VkDisplayKHR) VkResult #extern;
VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	mutableDescriptorType: VkBool32;
}
VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE :: VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT;
VkMutableDescriptorTypeListEXT :: struct {
	descriptorTypeCount: u32;
	pDescriptorTypes: *VkDescriptorType;
}
VkMutableDescriptorTypeListVALVE :: VkMutableDescriptorTypeListEXT;
VkMutableDescriptorTypeCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	mutableDescriptorTypeListCount: u32;
	pMutableDescriptorTypeLists: *VkMutableDescriptorTypeListEXT;
}
VkMutableDescriptorTypeCreateInfoVALVE :: VkMutableDescriptorTypeCreateInfoEXT;
VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	vertexInputDynamicState: VkBool32;
}
VkVertexInputBindingDescription2EXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	binding: u32;
	stride: u32;
	inputRate: VkVertexInputRate;
	divisor: u32;
}
VkVertexInputAttributeDescription2EXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	location: u32;
	binding: u32;
	format: VkFormat;
	offset: u32;
}
PFN_vkCmdSetVertexInputEXT :: *fn (VkCommandBuffer, u32, *VkVertexInputBindingDescription2EXT, u32, *VkVertexInputAttributeDescription2EXT);
vkCmdSetVertexInputEXT :: fn (commandBuffer: VkCommandBuffer, vertexBindingDescriptionCount: u32, pVertexBindingDescriptions: *VkVertexInputBindingDescription2EXT, vertexAttributeDescriptionCount: u32, pVertexAttributeDescriptions: *VkVertexInputAttributeDescription2EXT) #extern;
VkPhysicalDeviceDrmPropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	hasPrimary: VkBool32;
	hasRender: VkBool32;
	primaryMajor: s64;
	primaryMinor: s64;
	renderMajor: s64;
	renderMinor: s64;
}
VkDeviceAddressBindingTypeEXT :: enum s32 {
	VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT = 0x0;
	VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT = 0x1;
	VK_DEVICE_ADDRESS_BINDING_TYPE_MAX_ENUM_EXT = 0x7fffffff;
}
VkDeviceAddressBindingFlagBitsEXT :: enum u32 #flags {
	VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT = 0x1;
	VK_DEVICE_ADDRESS_BINDING_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff;
}
VkDeviceAddressBindingFlagsEXT :: VkFlags;
VkPhysicalDeviceAddressBindingReportFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	reportAddressBinding: VkBool32;
}
VkDeviceAddressBindingCallbackDataEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkDeviceAddressBindingFlagsEXT;
	baseAddress: VkDeviceAddress;
	size: VkDeviceSize;
	bindingType: VkDeviceAddressBindingTypeEXT;
}
VkPhysicalDeviceDepthClipControlFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	depthClipControl: VkBool32;
}
VkPipelineViewportDepthClipControlCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	negativeOneToOne: VkBool32;
}
VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	primitiveTopologyListRestart: VkBool32;
	primitiveTopologyPatchListRestart: VkBool32;
}
VkSubpassShadingPipelineCreateInfoHUAWEI :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	renderPass: VkRenderPass;
	subpass: u32;
}
VkPhysicalDeviceSubpassShadingFeaturesHUAWEI :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	subpassShading: VkBool32;
}
VkPhysicalDeviceSubpassShadingPropertiesHUAWEI :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	maxSubpassShadingWorkgroupSizeAspectRatio: u32;
}
PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI :: *fn (VkDevice, VkRenderPass, *VkExtent2D) VkResult;
PFN_vkCmdSubpassShadingHUAWEI :: *fn (VkCommandBuffer);
vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI :: fn (device: VkDevice, renderpass: VkRenderPass, pMaxWorkgroupSize: *VkExtent2D) VkResult #extern;
vkCmdSubpassShadingHUAWEI :: fn (commandBuffer: VkCommandBuffer) #extern;
VkPhysicalDeviceInvocationMaskFeaturesHUAWEI :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	invocationMask: VkBool32;
}
PFN_vkCmdBindInvocationMaskHUAWEI :: *fn (VkCommandBuffer, VkImageView, VkImageLayout);
vkCmdBindInvocationMaskHUAWEI :: fn (commandBuffer: VkCommandBuffer, imageView: VkImageView, imageLayout: VkImageLayout) #extern;
VkRemoteAddressNV :: C.void_ptr;
VkMemoryGetRemoteAddressInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	memory: VkDeviceMemory;
	handleType: VkExternalMemoryHandleTypeFlagBits;
}
VkPhysicalDeviceExternalMemoryRDMAFeaturesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	externalMemoryRDMA: VkBool32;
}
PFN_vkGetMemoryRemoteAddressNV :: *fn (VkDevice, *VkMemoryGetRemoteAddressInfoNV, *VkRemoteAddressNV) VkResult;
vkGetMemoryRemoteAddressNV :: fn (device: VkDevice, pMemoryGetRemoteAddressInfo: *VkMemoryGetRemoteAddressInfoNV, pAddress: *VkRemoteAddressNV) VkResult #extern;
VkPipelineInfoEXT :: VkPipelineInfoKHR;
VkPipelinePropertiesIdentifierEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	pipelineIdentifier: [16]u8;
}
VkPhysicalDevicePipelinePropertiesFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	pipelinePropertiesIdentifier: VkBool32;
}
PFN_vkGetPipelinePropertiesEXT :: *fn (VkDevice, *VkPipelineInfoEXT, *VkBaseOutStructure) VkResult;
vkGetPipelinePropertiesEXT :: fn (device: VkDevice, pPipelineInfo: *VkPipelineInfoEXT, pPipelineProperties: *VkBaseOutStructure) VkResult #extern;
VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	multisampledRenderToSingleSampled: VkBool32;
}
VkSubpassResolvePerformanceQueryEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	optimal: VkBool32;
}
VkMultisampledRenderToSingleSampledInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	multisampledRenderToSingleSampledEnable: VkBool32;
	rasterizationSamples: VkSampleCountFlagBits;
}
VkPhysicalDeviceExtendedDynamicState2FeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	extendedDynamicState2: VkBool32;
	extendedDynamicState2LogicOp: VkBool32;
	extendedDynamicState2PatchControlPoints: VkBool32;
}
PFN_vkCmdSetPatchControlPointsEXT :: *fn (VkCommandBuffer, u32);
PFN_vkCmdSetRasterizerDiscardEnableEXT :: *fn (VkCommandBuffer, VkBool32);
PFN_vkCmdSetDepthBiasEnableEXT :: *fn (VkCommandBuffer, VkBool32);
PFN_vkCmdSetLogicOpEXT :: *fn (VkCommandBuffer, VkLogicOp);
PFN_vkCmdSetPrimitiveRestartEnableEXT :: *fn (VkCommandBuffer, VkBool32);
vkCmdSetPatchControlPointsEXT :: fn (commandBuffer: VkCommandBuffer, patchControlPoints: u32) #extern;
vkCmdSetRasterizerDiscardEnableEXT :: fn (commandBuffer: VkCommandBuffer, rasterizerDiscardEnable: VkBool32) #extern;
vkCmdSetDepthBiasEnableEXT :: fn (commandBuffer: VkCommandBuffer, depthBiasEnable: VkBool32) #extern;
vkCmdSetLogicOpEXT :: fn (commandBuffer: VkCommandBuffer, logicOp: VkLogicOp) #extern;
vkCmdSetPrimitiveRestartEnableEXT :: fn (commandBuffer: VkCommandBuffer, primitiveRestartEnable: VkBool32) #extern;
VkPhysicalDeviceColorWriteEnableFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	colorWriteEnable: VkBool32;
}
VkPipelineColorWriteCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	attachmentCount: u32;
	pColorWriteEnables: *VkBool32;
}
PFN_vkCmdSetColorWriteEnableEXT :: *fn (VkCommandBuffer, u32, *VkBool32);
vkCmdSetColorWriteEnableEXT :: fn (commandBuffer: VkCommandBuffer, attachmentCount: u32, pColorWriteEnables: *VkBool32) #extern;
VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	primitivesGeneratedQuery: VkBool32;
	primitivesGeneratedQueryWithRasterizerDiscard: VkBool32;
	primitivesGeneratedQueryWithNonZeroStreams: VkBool32;
}
VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT :: VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR;
VkQueueFamilyGlobalPriorityPropertiesEXT :: VkQueueFamilyGlobalPriorityPropertiesKHR;
VkPhysicalDeviceImageViewMinLodFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	minLod: VkBool32;
}
VkImageViewMinLodCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	minLod: f32;
}
VkPhysicalDeviceMultiDrawFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	multiDraw: VkBool32;
}
VkPhysicalDeviceMultiDrawPropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	maxMultiDrawCount: u32;
}
VkMultiDrawInfoEXT :: struct {
	firstVertex: u32;
	vertexCount: u32;
}
VkMultiDrawIndexedInfoEXT :: struct {
	firstIndex: u32;
	indexCount: u32;
	vertexOffset: s32;
}
PFN_vkCmdDrawMultiEXT :: *fn (VkCommandBuffer, u32, *VkMultiDrawInfoEXT, u32, u32, u32);
PFN_vkCmdDrawMultiIndexedEXT :: *fn (VkCommandBuffer, u32, *VkMultiDrawIndexedInfoEXT, u32, u32, u32, *s32);
vkCmdDrawMultiEXT :: fn (commandBuffer: VkCommandBuffer, drawCount: u32, pVertexInfo: *VkMultiDrawInfoEXT, instanceCount: u32, firstInstance: u32, stride: u32) #extern;
vkCmdDrawMultiIndexedEXT :: fn (commandBuffer: VkCommandBuffer, drawCount: u32, pIndexInfo: *VkMultiDrawIndexedInfoEXT, instanceCount: u32, firstInstance: u32, stride: u32, pVertexOffset: *s32) #extern;
VkPhysicalDeviceImage2DViewOf3DFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	image2DViewOf3D: VkBool32;
	sampler2DViewOf3D: VkBool32;
}
VkMicromapTypeEXT :: enum s32 {
	VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT = 0x0;
	VK_MICROMAP_TYPE_MAX_ENUM_EXT = 0x7fffffff;
}
VkBuildMicromapModeEXT :: enum s32 {
	VK_BUILD_MICROMAP_MODE_BUILD_EXT = 0x0;
	VK_BUILD_MICROMAP_MODE_MAX_ENUM_EXT = 0x7fffffff;
}
VkCopyMicromapModeEXT :: enum s32 {
	VK_COPY_MICROMAP_MODE_CLONE_EXT = 0x0;
	VK_COPY_MICROMAP_MODE_SERIALIZE_EXT = 0x1;
	VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT = 0x2;
	VK_COPY_MICROMAP_MODE_COMPACT_EXT = 0x3;
	VK_COPY_MICROMAP_MODE_MAX_ENUM_EXT = 0x7fffffff;
}
VkOpacityMicromapFormatEXT :: enum s32 {
	VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT = 0x1;
	VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT = 0x2;
	VK_OPACITY_MICROMAP_FORMAT_MAX_ENUM_EXT = 0x7fffffff;
}
VkOpacityMicromapSpecialIndexEXT :: enum s32 {
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT = -0x1;
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT = -0x2;
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT = -0x3;
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT = -0x4;
	VK_OPACITY_MICROMAP_SPECIAL_INDEX_MAX_ENUM_EXT = 0x7fffffff;
}
VkAccelerationStructureCompatibilityKHR :: enum s32 {
	VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR = 0x0;
	VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR = 0x1;
	VK_ACCELERATION_STRUCTURE_COMPATIBILITY_MAX_ENUM_KHR = 0x7fffffff;
}
VkAccelerationStructureBuildTypeKHR :: enum s32 {
	VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR = 0x0;
	VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR = 0x1;
	VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR = 0x2;
	VK_ACCELERATION_STRUCTURE_BUILD_TYPE_MAX_ENUM_KHR = 0x7fffffff;
}
VkBuildMicromapFlagBitsEXT :: enum u32 #flags {
	VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT = 0x1;
	VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT = 0x2;
	VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT = 0x4;
	VK_BUILD_MICROMAP_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff;
}
VkBuildMicromapFlagsEXT :: VkFlags;
VkMicromapCreateFlagBitsEXT :: enum u32 #flags {
	VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = 0x1;
	VK_MICROMAP_CREATE_FLAG_BITS_MAX_ENUM_EXT = 0x7fffffff;
}
VkMicromapCreateFlagsEXT :: VkFlags;
VkMicromapUsageEXT :: struct {
	count: u32;
	subdivisionLevel: u32;
	format: u32;
}
VkDeviceOrHostAddressKHR :: union {
	deviceAddress: VkDeviceAddress;
	hostAddress: C.void_ptr;
}
VkMicromapBuildInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	t: VkMicromapTypeEXT;
	flags: VkBuildMicromapFlagsEXT;
	mode: VkBuildMicromapModeEXT;
	dstMicromap: VkMicromapEXT;
	usageCountsCount: u32;
	pUsageCounts: *VkMicromapUsageEXT;
	ppUsageCounts: **VkMicromapUsageEXT;
	data: VkDeviceOrHostAddressConstKHR;
	scratchData: VkDeviceOrHostAddressKHR;
	triangleArray: VkDeviceOrHostAddressConstKHR;
	triangleArrayStride: VkDeviceSize;
}
VkMicromapCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	createFlags: VkMicromapCreateFlagsEXT;
	buffer: VkBuffer;
	offset: VkDeviceSize;
	size: VkDeviceSize;
	t: VkMicromapTypeEXT;
	deviceAddress: VkDeviceAddress;
}
VkPhysicalDeviceOpacityMicromapFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	micromap: VkBool32;
	micromapCaptureReplay: VkBool32;
	micromapHostCommands: VkBool32;
}
VkPhysicalDeviceOpacityMicromapPropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	maxOpacity2StateSubdivisionLevel: u32;
	maxOpacity4StateSubdivisionLevel: u32;
}
VkMicromapVersionInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	pVersionData: *u8;
}
VkCopyMicromapToMemoryInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	src: VkMicromapEXT;
	dst: VkDeviceOrHostAddressKHR;
	mode: VkCopyMicromapModeEXT;
}
VkCopyMemoryToMicromapInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	src: VkDeviceOrHostAddressConstKHR;
	dst: VkMicromapEXT;
	mode: VkCopyMicromapModeEXT;
}
VkCopyMicromapInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	src: VkMicromapEXT;
	dst: VkMicromapEXT;
	mode: VkCopyMicromapModeEXT;
}
VkMicromapBuildSizesInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	micromapSize: VkDeviceSize;
	buildScratchSize: VkDeviceSize;
	discardable: VkBool32;
}
VkAccelerationStructureTrianglesOpacityMicromapEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	indexType: VkIndexType;
	indexBuffer: VkDeviceOrHostAddressConstKHR;
	indexStride: VkDeviceSize;
	baseTriangle: u32;
	usageCountsCount: u32;
	pUsageCounts: *VkMicromapUsageEXT;
	ppUsageCounts: **VkMicromapUsageEXT;
	micromap: VkMicromapEXT;
}
VkMicromapTriangleEXT :: struct {
	dataOffset: u32;
	subdivisionLevel: u16;
	format: u16;
}
PFN_vkCreateMicromapEXT :: *fn (VkDevice, *VkMicromapCreateInfoEXT, *VkAllocationCallbacks, *VkMicromapEXT) VkResult;
PFN_vkDestroyMicromapEXT :: *fn (VkDevice, VkMicromapEXT, *VkAllocationCallbacks);
PFN_vkCmdBuildMicromapsEXT :: *fn (VkCommandBuffer, u32, *VkMicromapBuildInfoEXT);
PFN_vkBuildMicromapsEXT :: *fn (VkDevice, VkDeferredOperationKHR, u32, *VkMicromapBuildInfoEXT) VkResult;
PFN_vkCopyMicromapEXT :: *fn (VkDevice, VkDeferredOperationKHR, *VkCopyMicromapInfoEXT) VkResult;
PFN_vkCopyMicromapToMemoryEXT :: *fn (VkDevice, VkDeferredOperationKHR, *VkCopyMicromapToMemoryInfoEXT) VkResult;
PFN_vkCopyMemoryToMicromapEXT :: *fn (VkDevice, VkDeferredOperationKHR, *VkCopyMemoryToMicromapInfoEXT) VkResult;
PFN_vkWriteMicromapsPropertiesEXT :: *fn (VkDevice, u32, *VkMicromapEXT, VkQueryType, usize, C.void_ptr, usize) VkResult;
PFN_vkCmdCopyMicromapEXT :: *fn (VkCommandBuffer, *VkCopyMicromapInfoEXT);
PFN_vkCmdCopyMicromapToMemoryEXT :: *fn (VkCommandBuffer, *VkCopyMicromapToMemoryInfoEXT);
PFN_vkCmdCopyMemoryToMicromapEXT :: *fn (VkCommandBuffer, *VkCopyMemoryToMicromapInfoEXT);
PFN_vkCmdWriteMicromapsPropertiesEXT :: *fn (VkCommandBuffer, u32, *VkMicromapEXT, VkQueryType, VkQueryPool, u32);
PFN_vkGetDeviceMicromapCompatibilityEXT :: *fn (VkDevice, *VkMicromapVersionInfoEXT, *VkAccelerationStructureCompatibilityKHR);
PFN_vkGetMicromapBuildSizesEXT :: *fn (VkDevice, VkAccelerationStructureBuildTypeKHR, *VkMicromapBuildInfoEXT, *VkMicromapBuildSizesInfoEXT);
vkCreateMicromapEXT :: fn (device: VkDevice, pCreateInfo: *VkMicromapCreateInfoEXT, pAllocator: *VkAllocationCallbacks, pMicromap: *VkMicromapEXT) VkResult #extern;
vkDestroyMicromapEXT :: fn (device: VkDevice, micromap: VkMicromapEXT, pAllocator: *VkAllocationCallbacks) #extern;
vkCmdBuildMicromapsEXT :: fn (commandBuffer: VkCommandBuffer, infoCount: u32, pInfos: *VkMicromapBuildInfoEXT) #extern;
vkBuildMicromapsEXT :: fn (device: VkDevice, deferredOperation: VkDeferredOperationKHR, infoCount: u32, pInfos: *VkMicromapBuildInfoEXT) VkResult #extern;
vkCopyMicromapEXT :: fn (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *VkCopyMicromapInfoEXT) VkResult #extern;
vkCopyMicromapToMemoryEXT :: fn (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *VkCopyMicromapToMemoryInfoEXT) VkResult #extern;
vkCopyMemoryToMicromapEXT :: fn (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *VkCopyMemoryToMicromapInfoEXT) VkResult #extern;
vkWriteMicromapsPropertiesEXT :: fn (device: VkDevice, micromapCount: u32, pMicromaps: *VkMicromapEXT, queryType: VkQueryType, dataSize: usize, pData: C.void_ptr, stride: usize) VkResult #extern;
vkCmdCopyMicromapEXT :: fn (commandBuffer: VkCommandBuffer, pInfo: *VkCopyMicromapInfoEXT) #extern;
vkCmdCopyMicromapToMemoryEXT :: fn (commandBuffer: VkCommandBuffer, pInfo: *VkCopyMicromapToMemoryInfoEXT) #extern;
vkCmdCopyMemoryToMicromapEXT :: fn (commandBuffer: VkCommandBuffer, pInfo: *VkCopyMemoryToMicromapInfoEXT) #extern;
vkCmdWriteMicromapsPropertiesEXT :: fn (commandBuffer: VkCommandBuffer, micromapCount: u32, pMicromaps: *VkMicromapEXT, queryType: VkQueryType, queryPool: VkQueryPool, firstQuery: u32) #extern;
vkGetDeviceMicromapCompatibilityEXT :: fn (device: VkDevice, pVersionInfo: *VkMicromapVersionInfoEXT, pCompatibility: *VkAccelerationStructureCompatibilityKHR) #extern;
vkGetMicromapBuildSizesEXT :: fn (device: VkDevice, buildType: VkAccelerationStructureBuildTypeKHR, pBuildInfo: *VkMicromapBuildInfoEXT, pSizeInfo: *VkMicromapBuildSizesInfoEXT) #extern;
VkPhysicalDeviceBorderColorSwizzleFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	borderColorSwizzle: VkBool32;
	borderColorSwizzleFromImage: VkBool32;
}
VkSamplerBorderColorComponentMappingCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	components: VkComponentMapping;
	srgb: VkBool32;
}
VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	pageableDeviceLocalMemory: VkBool32;
}
PFN_vkSetDeviceMemoryPriorityEXT :: *fn (VkDevice, VkDeviceMemory, f32);
vkSetDeviceMemoryPriorityEXT :: fn (device: VkDevice, memory: VkDeviceMemory, priority: f32) #extern;
VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	descriptorSetHostMapping: VkBool32;
}
VkDescriptorSetBindingReferenceVALVE :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	descriptorSetLayout: VkDescriptorSetLayout;
	binding: u32;
}
VkDescriptorSetLayoutHostMappingInfoVALVE :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	descriptorOffset: usize;
	descriptorSize: u32;
}
PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE :: *fn (VkDevice, *VkDescriptorSetBindingReferenceVALVE, *VkDescriptorSetLayoutHostMappingInfoVALVE);
PFN_vkGetDescriptorSetHostMappingVALVE :: *fn (VkDevice, VkDescriptorSet, *C.void_ptr);
vkGetDescriptorSetLayoutHostMappingInfoVALVE :: fn (device: VkDevice, pBindingReference: *VkDescriptorSetBindingReferenceVALVE, pHostMapping: *VkDescriptorSetLayoutHostMappingInfoVALVE) #extern;
vkGetDescriptorSetHostMappingVALVE :: fn (device: VkDevice, descriptorSet: VkDescriptorSet, ppData: *C.void_ptr) #extern;
VkPhysicalDeviceDepthClampZeroOneFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	depthClampZeroOne: VkBool32;
}
VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	nonSeamlessCubeMap: VkBool32;
}
VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	fragmentDensityMapOffset: VkBool32;
}
VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	fragmentDensityOffsetGranularity: VkExtent2D;
}
VkSubpassFragmentDensityMapOffsetEndInfoQCOM :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	fragmentDensityOffsetCount: u32;
	pFragmentDensityOffsets: *VkOffset2D;
}
VkPhysicalDeviceLinearColorAttachmentFeaturesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	linearColorAttachment: VkBool32;
}
VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	imageCompressionControlSwapchain: VkBool32;
}
VkImageViewSampleWeightCreateInfoQCOM :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	filterCenter: VkOffset2D;
	filterSize: VkExtent2D;
	numPhases: u32;
}
VkPhysicalDeviceImageProcessingFeaturesQCOM :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	textureSampleWeighted: VkBool32;
	textureBoxFilter: VkBool32;
	textureBlockMatch: VkBool32;
}
VkPhysicalDeviceImageProcessingPropertiesQCOM :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	maxWeightFilterPhases: u32;
	maxWeightFilterDimension: VkExtent2D;
	maxBlockMatchRegion: VkExtent2D;
	maxBoxFilterBlockSize: VkExtent2D;
}
VkPhysicalDeviceExtendedDynamicState3FeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	extendedDynamicState3TessellationDomainOrigin: VkBool32;
	extendedDynamicState3DepthClampEnable: VkBool32;
	extendedDynamicState3PolygonMode: VkBool32;
	extendedDynamicState3RasterizationSamples: VkBool32;
	extendedDynamicState3SampleMask: VkBool32;
	extendedDynamicState3AlphaToCoverageEnable: VkBool32;
	extendedDynamicState3AlphaToOneEnable: VkBool32;
	extendedDynamicState3LogicOpEnable: VkBool32;
	extendedDynamicState3ColorBlendEnable: VkBool32;
	extendedDynamicState3ColorBlendEquation: VkBool32;
	extendedDynamicState3ColorWriteMask: VkBool32;
	extendedDynamicState3RasterizationStream: VkBool32;
	extendedDynamicState3ConservativeRasterizationMode: VkBool32;
	extendedDynamicState3ExtraPrimitiveOverestimationSize: VkBool32;
	extendedDynamicState3DepthClipEnable: VkBool32;
	extendedDynamicState3SampleLocationsEnable: VkBool32;
	extendedDynamicState3ColorBlendAdvanced: VkBool32;
	extendedDynamicState3ProvokingVertexMode: VkBool32;
	extendedDynamicState3LineRasterizationMode: VkBool32;
	extendedDynamicState3LineStippleEnable: VkBool32;
	extendedDynamicState3DepthClipNegativeOneToOne: VkBool32;
	extendedDynamicState3ViewportWScalingEnable: VkBool32;
	extendedDynamicState3ViewportSwizzle: VkBool32;
	extendedDynamicState3CoverageToColorEnable: VkBool32;
	extendedDynamicState3CoverageToColorLocation: VkBool32;
	extendedDynamicState3CoverageModulationMode: VkBool32;
	extendedDynamicState3CoverageModulationTableEnable: VkBool32;
	extendedDynamicState3CoverageModulationTable: VkBool32;
	extendedDynamicState3CoverageReductionMode: VkBool32;
	extendedDynamicState3RepresentativeFragmentTestEnable: VkBool32;
	extendedDynamicState3ShadingRateImageEnable: VkBool32;
}
VkPhysicalDeviceExtendedDynamicState3PropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	dynamicPrimitiveTopologyUnrestricted: VkBool32;
}
VkColorBlendEquationEXT :: struct {
	srcColorBlendFactor: VkBlendFactor;
	dstColorBlendFactor: VkBlendFactor;
	colorBlendOp: VkBlendOp;
	srcAlphaBlendFactor: VkBlendFactor;
	dstAlphaBlendFactor: VkBlendFactor;
	alphaBlendOp: VkBlendOp;
}
VkColorBlendAdvancedEXT :: struct {
	advancedBlendOp: VkBlendOp;
	srcPremultiplied: VkBool32;
	dstPremultiplied: VkBool32;
	blendOverlap: VkBlendOverlapEXT;
	clampResults: VkBool32;
}
PFN_vkCmdSetTessellationDomainOriginEXT :: *fn (VkCommandBuffer, VkTessellationDomainOrigin);
PFN_vkCmdSetDepthClampEnableEXT :: *fn (VkCommandBuffer, VkBool32);
PFN_vkCmdSetPolygonModeEXT :: *fn (VkCommandBuffer, VkPolygonMode);
PFN_vkCmdSetRasterizationSamplesEXT :: *fn (VkCommandBuffer, VkSampleCountFlagBits);
PFN_vkCmdSetSampleMaskEXT :: *fn (VkCommandBuffer, VkSampleCountFlagBits, *VkSampleMask);
PFN_vkCmdSetAlphaToCoverageEnableEXT :: *fn (VkCommandBuffer, VkBool32);
PFN_vkCmdSetAlphaToOneEnableEXT :: *fn (VkCommandBuffer, VkBool32);
PFN_vkCmdSetLogicOpEnableEXT :: *fn (VkCommandBuffer, VkBool32);
PFN_vkCmdSetColorBlendEnableEXT :: *fn (VkCommandBuffer, u32, u32, *VkBool32);
PFN_vkCmdSetColorBlendEquationEXT :: *fn (VkCommandBuffer, u32, u32, *VkColorBlendEquationEXT);
PFN_vkCmdSetColorWriteMaskEXT :: *fn (VkCommandBuffer, u32, u32, *VkColorComponentFlags);
PFN_vkCmdSetRasterizationStreamEXT :: *fn (VkCommandBuffer, u32);
PFN_vkCmdSetConservativeRasterizationModeEXT :: *fn (VkCommandBuffer, VkConservativeRasterizationModeEXT);
PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT :: *fn (VkCommandBuffer, f32);
PFN_vkCmdSetDepthClipEnableEXT :: *fn (VkCommandBuffer, VkBool32);
PFN_vkCmdSetSampleLocationsEnableEXT :: *fn (VkCommandBuffer, VkBool32);
PFN_vkCmdSetColorBlendAdvancedEXT :: *fn (VkCommandBuffer, u32, u32, *VkColorBlendAdvancedEXT);
PFN_vkCmdSetProvokingVertexModeEXT :: *fn (VkCommandBuffer, VkProvokingVertexModeEXT);
PFN_vkCmdSetLineRasterizationModeEXT :: *fn (VkCommandBuffer, VkLineRasterizationModeEXT);
PFN_vkCmdSetLineStippleEnableEXT :: *fn (VkCommandBuffer, VkBool32);
PFN_vkCmdSetDepthClipNegativeOneToOneEXT :: *fn (VkCommandBuffer, VkBool32);
PFN_vkCmdSetViewportWScalingEnableNV :: *fn (VkCommandBuffer, VkBool32);
PFN_vkCmdSetViewportSwizzleNV :: *fn (VkCommandBuffer, u32, u32, *VkViewportSwizzleNV);
PFN_vkCmdSetCoverageToColorEnableNV :: *fn (VkCommandBuffer, VkBool32);
PFN_vkCmdSetCoverageToColorLocationNV :: *fn (VkCommandBuffer, u32);
PFN_vkCmdSetCoverageModulationModeNV :: *fn (VkCommandBuffer, VkCoverageModulationModeNV);
PFN_vkCmdSetCoverageModulationTableEnableNV :: *fn (VkCommandBuffer, VkBool32);
PFN_vkCmdSetCoverageModulationTableNV :: *fn (VkCommandBuffer, u32, *f32);
PFN_vkCmdSetShadingRateImageEnableNV :: *fn (VkCommandBuffer, VkBool32);
PFN_vkCmdSetRepresentativeFragmentTestEnableNV :: *fn (VkCommandBuffer, VkBool32);
PFN_vkCmdSetCoverageReductionModeNV :: *fn (VkCommandBuffer, VkCoverageReductionModeNV);
vkCmdSetTessellationDomainOriginEXT :: fn (commandBuffer: VkCommandBuffer, domainOrigin: VkTessellationDomainOrigin) #extern;
vkCmdSetDepthClampEnableEXT :: fn (commandBuffer: VkCommandBuffer, depthClampEnable: VkBool32) #extern;
vkCmdSetPolygonModeEXT :: fn (commandBuffer: VkCommandBuffer, polygonMode: VkPolygonMode) #extern;
vkCmdSetRasterizationSamplesEXT :: fn (commandBuffer: VkCommandBuffer, rasterizationSamples: VkSampleCountFlagBits) #extern;
vkCmdSetSampleMaskEXT :: fn (commandBuffer: VkCommandBuffer, samples: VkSampleCountFlagBits, pSampleMask: *VkSampleMask) #extern;
vkCmdSetAlphaToCoverageEnableEXT :: fn (commandBuffer: VkCommandBuffer, alphaToCoverageEnable: VkBool32) #extern;
vkCmdSetAlphaToOneEnableEXT :: fn (commandBuffer: VkCommandBuffer, alphaToOneEnable: VkBool32) #extern;
vkCmdSetLogicOpEnableEXT :: fn (commandBuffer: VkCommandBuffer, logicOpEnable: VkBool32) #extern;
vkCmdSetColorBlendEnableEXT :: fn (commandBuffer: VkCommandBuffer, firstAttachment: u32, attachmentCount: u32, pColorBlendEnables: *VkBool32) #extern;
vkCmdSetColorBlendEquationEXT :: fn (commandBuffer: VkCommandBuffer, firstAttachment: u32, attachmentCount: u32, pColorBlendEquations: *VkColorBlendEquationEXT) #extern;
vkCmdSetColorWriteMaskEXT :: fn (commandBuffer: VkCommandBuffer, firstAttachment: u32, attachmentCount: u32, pColorWriteMasks: *VkColorComponentFlags) #extern;
vkCmdSetRasterizationStreamEXT :: fn (commandBuffer: VkCommandBuffer, rasterizationStream: u32) #extern;
vkCmdSetConservativeRasterizationModeEXT :: fn (commandBuffer: VkCommandBuffer, conservativeRasterizationMode: VkConservativeRasterizationModeEXT) #extern;
vkCmdSetExtraPrimitiveOverestimationSizeEXT :: fn (commandBuffer: VkCommandBuffer, extraPrimitiveOverestimationSize: f32) #extern;
vkCmdSetDepthClipEnableEXT :: fn (commandBuffer: VkCommandBuffer, depthClipEnable: VkBool32) #extern;
vkCmdSetSampleLocationsEnableEXT :: fn (commandBuffer: VkCommandBuffer, sampleLocationsEnable: VkBool32) #extern;
vkCmdSetColorBlendAdvancedEXT :: fn (commandBuffer: VkCommandBuffer, firstAttachment: u32, attachmentCount: u32, pColorBlendAdvanced: *VkColorBlendAdvancedEXT) #extern;
vkCmdSetProvokingVertexModeEXT :: fn (commandBuffer: VkCommandBuffer, provokingVertexMode: VkProvokingVertexModeEXT) #extern;
vkCmdSetLineRasterizationModeEXT :: fn (commandBuffer: VkCommandBuffer, lineRasterizationMode: VkLineRasterizationModeEXT) #extern;
vkCmdSetLineStippleEnableEXT :: fn (commandBuffer: VkCommandBuffer, stippledLineEnable: VkBool32) #extern;
vkCmdSetDepthClipNegativeOneToOneEXT :: fn (commandBuffer: VkCommandBuffer, negativeOneToOne: VkBool32) #extern;
vkCmdSetViewportWScalingEnableNV :: fn (commandBuffer: VkCommandBuffer, viewportWScalingEnable: VkBool32) #extern;
vkCmdSetViewportSwizzleNV :: fn (commandBuffer: VkCommandBuffer, firstViewport: u32, viewportCount: u32, pViewportSwizzles: *VkViewportSwizzleNV) #extern;
vkCmdSetCoverageToColorEnableNV :: fn (commandBuffer: VkCommandBuffer, coverageToColorEnable: VkBool32) #extern;
vkCmdSetCoverageToColorLocationNV :: fn (commandBuffer: VkCommandBuffer, coverageToColorLocation: u32) #extern;
vkCmdSetCoverageModulationModeNV :: fn (commandBuffer: VkCommandBuffer, coverageModulationMode: VkCoverageModulationModeNV) #extern;
vkCmdSetCoverageModulationTableEnableNV :: fn (commandBuffer: VkCommandBuffer, coverageModulationTableEnable: VkBool32) #extern;
vkCmdSetCoverageModulationTableNV :: fn (commandBuffer: VkCommandBuffer, coverageModulationTableCount: u32, pCoverageModulationTable: *f32) #extern;
vkCmdSetShadingRateImageEnableNV :: fn (commandBuffer: VkCommandBuffer, shadingRateImageEnable: VkBool32) #extern;
vkCmdSetRepresentativeFragmentTestEnableNV :: fn (commandBuffer: VkCommandBuffer, representativeFragmentTestEnable: VkBool32) #extern;
vkCmdSetCoverageReductionModeNV :: fn (commandBuffer: VkCommandBuffer, coverageReductionMode: VkCoverageReductionModeNV) #extern;
VkSubpassMergeStatusEXT :: enum s32 {
	VK_SUBPASS_MERGE_STATUS_MERGED_EXT = 0x0;
	VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT = 0x1;
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT = 0x2;
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT = 0x3;
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT = 0x4;
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT = 0x5;
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT = 0x6;
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT = 0x7;
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT = 0x8;
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT = 0x9;
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT = 0xa;
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT = 0xb;
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT = 0xc;
	VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT = 0xd;
	VK_SUBPASS_MERGE_STATUS_MAX_ENUM_EXT = 0x7fffffff;
}
VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	subpassMergeFeedback: VkBool32;
}
VkRenderPassCreationControlEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	disallowMerging: VkBool32;
}
VkRenderPassCreationFeedbackInfoEXT :: struct {
	postMergeSubpassCount: u32;
}
VkRenderPassCreationFeedbackCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	pRenderPassFeedback: *VkRenderPassCreationFeedbackInfoEXT;
}
VkRenderPassSubpassFeedbackInfoEXT :: struct {
	subpassMergeStatus: VkSubpassMergeStatusEXT;
	description: [256]C.char;
	postMergeIndex: u32;
}
VkRenderPassSubpassFeedbackCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	pSubpassFeedback: *VkRenderPassSubpassFeedbackInfoEXT;
}
VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shaderModuleIdentifier: VkBool32;
}
VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shaderModuleIdentifierAlgorithmUUID: [16]u8;
}
VkPipelineShaderStageModuleIdentifierCreateInfoEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	identifierSize: u32;
	pIdentifier: *u8;
}
VkShaderModuleIdentifierEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	identifierSize: u32;
	identifier: [32]u8;
}
PFN_vkGetShaderModuleIdentifierEXT :: *fn (VkDevice, VkShaderModule, *VkShaderModuleIdentifierEXT);
PFN_vkGetShaderModuleCreateInfoIdentifierEXT :: *fn (VkDevice, *VkShaderModuleCreateInfo, *VkShaderModuleIdentifierEXT);
vkGetShaderModuleIdentifierEXT :: fn (device: VkDevice, shaderModule: VkShaderModule, pIdentifier: *VkShaderModuleIdentifierEXT) #extern;
vkGetShaderModuleCreateInfoIdentifierEXT :: fn (device: VkDevice, pCreateInfo: *VkShaderModuleCreateInfo, pIdentifier: *VkShaderModuleIdentifierEXT) #extern;
VkOpticalFlowPerformanceLevelNV :: enum s32 {
	VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV = 0x0;
	VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV = 0x1;
	VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV = 0x2;
	VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV = 0x3;
	VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MAX_ENUM_NV = 0x7fffffff;
}
VkOpticalFlowSessionBindingPointNV :: enum s32 {
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV = 0x0;
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV = 0x1;
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV = 0x2;
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV = 0x3;
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV = 0x4;
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV = 0x5;
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV = 0x6;
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV = 0x7;
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV = 0x8;
	VK_OPTICAL_FLOW_SESSION_BINDING_POINT_MAX_ENUM_NV = 0x7fffffff;
}
VkOpticalFlowGridSizeFlagBitsNV :: enum s32 {
	VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV = 0x0;
	VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV = 0x1;
	VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV = 0x2;
	VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV = 0x4;
	VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV = 0x8;
	VK_OPTICAL_FLOW_GRID_SIZE_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff;
}
VkOpticalFlowGridSizeFlagsNV :: VkFlags;
VkOpticalFlowUsageFlagBitsNV :: enum s32 {
	VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV = 0x0;
	VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV = 0x1;
	VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV = 0x2;
	VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV = 0x4;
	VK_OPTICAL_FLOW_USAGE_COST_BIT_NV = 0x8;
	VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV = 0x10;
	VK_OPTICAL_FLOW_USAGE_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff;
}
VkOpticalFlowUsageFlagsNV :: VkFlags;
VkOpticalFlowSessionCreateFlagBitsNV :: enum s32 {
	VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV = 0x1;
	VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV = 0x2;
	VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV = 0x4;
	VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV = 0x8;
	VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV = 0x10;
	VK_OPTICAL_FLOW_SESSION_CREATE_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff;
}
VkOpticalFlowSessionCreateFlagsNV :: VkFlags;
VkOpticalFlowExecuteFlagBitsNV :: enum s32 {
	VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV = 0x1;
	VK_OPTICAL_FLOW_EXECUTE_FLAG_BITS_MAX_ENUM_NV = 0x7fffffff;
}
VkOpticalFlowExecuteFlagsNV :: VkFlags;
VkPhysicalDeviceOpticalFlowFeaturesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	opticalFlow: VkBool32;
}
VkPhysicalDeviceOpticalFlowPropertiesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	supportedOutputGridSizes: VkOpticalFlowGridSizeFlagsNV;
	supportedHintGridSizes: VkOpticalFlowGridSizeFlagsNV;
	hintSupported: VkBool32;
	costSupported: VkBool32;
	bidirectionalFlowSupported: VkBool32;
	globalFlowSupported: VkBool32;
	minWidth: u32;
	minHeight: u32;
	maxWidth: u32;
	maxHeight: u32;
	maxNumRegionsOfInterest: u32;
}
VkOpticalFlowImageFormatInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	usage: VkOpticalFlowUsageFlagsNV;
}
VkOpticalFlowImageFormatPropertiesNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	format: VkFormat;
}
VkOpticalFlowSessionCreateInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	width: u32;
	height: u32;
	imageFormat: VkFormat;
	flowVectorFormat: VkFormat;
	costFormat: VkFormat;
	outputGridSize: VkOpticalFlowGridSizeFlagsNV;
	hintGridSize: VkOpticalFlowGridSizeFlagsNV;
	performanceLevel: VkOpticalFlowPerformanceLevelNV;
	flags: VkOpticalFlowSessionCreateFlagsNV;
}
VkOpticalFlowSessionCreatePrivateDataInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	id: u32;
	size: u32;
	pPrivateData: C.void_ptr;
}
VkOpticalFlowExecuteInfoNV :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkOpticalFlowExecuteFlagsNV;
	regionCount: u32;
	pRegions: *VkRect2D;
}
PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV :: *fn (VkPhysicalDevice, *VkOpticalFlowImageFormatInfoNV, *u32, *VkOpticalFlowImageFormatPropertiesNV) VkResult;
PFN_vkCreateOpticalFlowSessionNV :: *fn (VkDevice, *VkOpticalFlowSessionCreateInfoNV, *VkAllocationCallbacks, *VkOpticalFlowSessionNV) VkResult;
PFN_vkDestroyOpticalFlowSessionNV :: *fn (VkDevice, VkOpticalFlowSessionNV, *VkAllocationCallbacks);
PFN_vkBindOpticalFlowSessionImageNV :: *fn (VkDevice, VkOpticalFlowSessionNV, VkOpticalFlowSessionBindingPointNV, VkImageView, VkImageLayout) VkResult;
PFN_vkCmdOpticalFlowExecuteNV :: *fn (VkCommandBuffer, VkOpticalFlowSessionNV, *VkOpticalFlowExecuteInfoNV);
vkGetPhysicalDeviceOpticalFlowImageFormatsNV :: fn (physicalDevice: VkPhysicalDevice, pOpticalFlowImageFormatInfo: *VkOpticalFlowImageFormatInfoNV, pFormatCount: *u32, pImageFormatProperties: *VkOpticalFlowImageFormatPropertiesNV) VkResult #extern;
vkCreateOpticalFlowSessionNV :: fn (device: VkDevice, pCreateInfo: *VkOpticalFlowSessionCreateInfoNV, pAllocator: *VkAllocationCallbacks, pSession: *VkOpticalFlowSessionNV) VkResult #extern;
vkDestroyOpticalFlowSessionNV :: fn (device: VkDevice, session: VkOpticalFlowSessionNV, pAllocator: *VkAllocationCallbacks) #extern;
vkBindOpticalFlowSessionImageNV :: fn (device: VkDevice, session: VkOpticalFlowSessionNV, bindingPoint: VkOpticalFlowSessionBindingPointNV, view: VkImageView, layout: VkImageLayout) VkResult #extern;
vkCmdOpticalFlowExecuteNV :: fn (commandBuffer: VkCommandBuffer, session: VkOpticalFlowSessionNV, pExecuteInfo: *VkOpticalFlowExecuteInfoNV) #extern;
VkPhysicalDeviceLegacyDitheringFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	legacyDithering: VkBool32;
}
VkPhysicalDevicePipelineProtectedAccessFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	pipelineProtectedAccess: VkBool32;
}
VkPhysicalDeviceTilePropertiesFeaturesQCOM :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	tileProperties: VkBool32;
}
VkTilePropertiesQCOM :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	tileSize: VkExtent3D;
	apronSize: VkExtent2D;
	origin: VkOffset2D;
}
PFN_vkGetFramebufferTilePropertiesQCOM :: *fn (VkDevice, VkFramebuffer, *u32, *VkTilePropertiesQCOM) VkResult;
PFN_vkGetDynamicRenderingTilePropertiesQCOM :: *fn (VkDevice, *VkRenderingInfo, *VkTilePropertiesQCOM) VkResult;
vkGetFramebufferTilePropertiesQCOM :: fn (device: VkDevice, framebuffer: VkFramebuffer, pPropertiesCount: *u32, pProperties: *VkTilePropertiesQCOM) VkResult #extern;
vkGetDynamicRenderingTilePropertiesQCOM :: fn (device: VkDevice, pRenderingInfo: *VkRenderingInfo, pProperties: *VkTilePropertiesQCOM) VkResult #extern;
VkPhysicalDeviceAmigoProfilingFeaturesSEC :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	amigoProfiling: VkBool32;
}
VkAmigoProfilingSubmitInfoSEC :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	firstDrawTimestamp: u64;
	swapBufferTimestamp: u64;
}
VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shaderCoreBuiltins: VkBool32;
}
VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shaderCoreCount: u32;
	shaderWarpsPerCore: u32;
}
VkBuildAccelerationStructureModeKHR :: enum s32 {
	VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR = 0x0;
	VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR = 0x1;
	VK_BUILD_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_KHR = 0x7fffffff;
}
VkAccelerationStructureCreateFlagBitsKHR :: enum s32 {
	VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = 0x1;
	VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV = 0x4;
	VK_ACCELERATION_STRUCTURE_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7fffffff;
}
VkAccelerationStructureCreateFlagsKHR :: VkFlags;
VkAccelerationStructureBuildRangeInfoKHR :: struct {
	primitiveCount: u32;
	primitiveOffset: u32;
	firstVertex: u32;
	transformOffset: u32;
}
VkAccelerationStructureGeometryTrianglesDataKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	vertexFormat: VkFormat;
	vertexData: VkDeviceOrHostAddressConstKHR;
	vertexStride: VkDeviceSize;
	maxVertex: u32;
	indexType: VkIndexType;
	indexData: VkDeviceOrHostAddressConstKHR;
	transformData: VkDeviceOrHostAddressConstKHR;
}
VkAccelerationStructureGeometryAabbsDataKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	data: VkDeviceOrHostAddressConstKHR;
	stride: VkDeviceSize;
}
VkAccelerationStructureGeometryInstancesDataKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	arrayOfPointers: VkBool32;
	data: VkDeviceOrHostAddressConstKHR;
}
VkAccelerationStructureGeometryDataKHR :: union {
	triangles: VkAccelerationStructureGeometryTrianglesDataKHR;
	aabbs: VkAccelerationStructureGeometryAabbsDataKHR;
	instances: VkAccelerationStructureGeometryInstancesDataKHR;
}
VkAccelerationStructureGeometryKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	geometryType: VkGeometryTypeKHR;
	geometry: VkAccelerationStructureGeometryDataKHR;
	flags: VkGeometryFlagsKHR;
}
VkAccelerationStructureBuildGeometryInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	t: VkAccelerationStructureTypeKHR;
	flags: VkBuildAccelerationStructureFlagsKHR;
	mode: VkBuildAccelerationStructureModeKHR;
	srcAccelerationStructure: VkAccelerationStructureKHR;
	dstAccelerationStructure: VkAccelerationStructureKHR;
	geometryCount: u32;
	pGeometries: *VkAccelerationStructureGeometryKHR;
	ppGeometries: **VkAccelerationStructureGeometryKHR;
	scratchData: VkDeviceOrHostAddressKHR;
}
VkAccelerationStructureCreateInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	createFlags: VkAccelerationStructureCreateFlagsKHR;
	buffer: VkBuffer;
	offset: VkDeviceSize;
	size: VkDeviceSize;
	t: VkAccelerationStructureTypeKHR;
	deviceAddress: VkDeviceAddress;
}
VkWriteDescriptorSetAccelerationStructureKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	accelerationStructureCount: u32;
	pAccelerationStructures: *VkAccelerationStructureKHR;
}
VkPhysicalDeviceAccelerationStructureFeaturesKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	accelerationStructure: VkBool32;
	accelerationStructureCaptureReplay: VkBool32;
	accelerationStructureIndirectBuild: VkBool32;
	accelerationStructureHostCommands: VkBool32;
	descriptorBindingAccelerationStructureUpdateAfterBind: VkBool32;
}
VkPhysicalDeviceAccelerationStructurePropertiesKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	maxGeometryCount: u64;
	maxInstanceCount: u64;
	maxPrimitiveCount: u64;
	maxPerStageDescriptorAccelerationStructures: u32;
	maxPerStageDescriptorUpdateAfterBindAccelerationStructures: u32;
	maxDescriptorSetAccelerationStructures: u32;
	maxDescriptorSetUpdateAfterBindAccelerationStructures: u32;
	minAccelerationStructureScratchOffsetAlignment: u32;
}
VkAccelerationStructureDeviceAddressInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	accelerationStructure: VkAccelerationStructureKHR;
}
VkAccelerationStructureVersionInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	pVersionData: *u8;
}
VkCopyAccelerationStructureToMemoryInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	src: VkAccelerationStructureKHR;
	dst: VkDeviceOrHostAddressKHR;
	mode: VkCopyAccelerationStructureModeKHR;
}
VkCopyMemoryToAccelerationStructureInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	src: VkDeviceOrHostAddressConstKHR;
	dst: VkAccelerationStructureKHR;
	mode: VkCopyAccelerationStructureModeKHR;
}
VkCopyAccelerationStructureInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	src: VkAccelerationStructureKHR;
	dst: VkAccelerationStructureKHR;
	mode: VkCopyAccelerationStructureModeKHR;
}
VkAccelerationStructureBuildSizesInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	accelerationStructureSize: VkDeviceSize;
	updateScratchSize: VkDeviceSize;
	buildScratchSize: VkDeviceSize;
}
PFN_vkCreateAccelerationStructureKHR :: *fn (VkDevice, *VkAccelerationStructureCreateInfoKHR, *VkAllocationCallbacks, *VkAccelerationStructureKHR) VkResult;
PFN_vkDestroyAccelerationStructureKHR :: *fn (VkDevice, VkAccelerationStructureKHR, *VkAllocationCallbacks);
PFN_vkCmdBuildAccelerationStructuresKHR :: *fn (VkCommandBuffer, u32, *VkAccelerationStructureBuildGeometryInfoKHR, **VkAccelerationStructureBuildRangeInfoKHR);
PFN_vkCmdBuildAccelerationStructuresIndirectKHR :: *fn (VkCommandBuffer, u32, *VkAccelerationStructureBuildGeometryInfoKHR, *VkDeviceAddress, *u32, **u32);
PFN_vkBuildAccelerationStructuresKHR :: *fn (VkDevice, VkDeferredOperationKHR, u32, *VkAccelerationStructureBuildGeometryInfoKHR, **VkAccelerationStructureBuildRangeInfoKHR) VkResult;
PFN_vkCopyAccelerationStructureKHR :: *fn (VkDevice, VkDeferredOperationKHR, *VkCopyAccelerationStructureInfoKHR) VkResult;
PFN_vkCopyAccelerationStructureToMemoryKHR :: *fn (VkDevice, VkDeferredOperationKHR, *VkCopyAccelerationStructureToMemoryInfoKHR) VkResult;
PFN_vkCopyMemoryToAccelerationStructureKHR :: *fn (VkDevice, VkDeferredOperationKHR, *VkCopyMemoryToAccelerationStructureInfoKHR) VkResult;
PFN_vkWriteAccelerationStructuresPropertiesKHR :: *fn (VkDevice, u32, *VkAccelerationStructureKHR, VkQueryType, usize, C.void_ptr, usize) VkResult;
PFN_vkCmdCopyAccelerationStructureKHR :: *fn (VkCommandBuffer, *VkCopyAccelerationStructureInfoKHR);
PFN_vkCmdCopyAccelerationStructureToMemoryKHR :: *fn (VkCommandBuffer, *VkCopyAccelerationStructureToMemoryInfoKHR);
PFN_vkCmdCopyMemoryToAccelerationStructureKHR :: *fn (VkCommandBuffer, *VkCopyMemoryToAccelerationStructureInfoKHR);
PFN_vkGetAccelerationStructureDeviceAddressKHR :: *fn (VkDevice, *VkAccelerationStructureDeviceAddressInfoKHR) VkDeviceAddress;
PFN_vkCmdWriteAccelerationStructuresPropertiesKHR :: *fn (VkCommandBuffer, u32, *VkAccelerationStructureKHR, VkQueryType, VkQueryPool, u32);
PFN_vkGetDeviceAccelerationStructureCompatibilityKHR :: *fn (VkDevice, *VkAccelerationStructureVersionInfoKHR, *VkAccelerationStructureCompatibilityKHR);
PFN_vkGetAccelerationStructureBuildSizesKHR :: *fn (VkDevice, VkAccelerationStructureBuildTypeKHR, *VkAccelerationStructureBuildGeometryInfoKHR, *u32, *VkAccelerationStructureBuildSizesInfoKHR);
vkCreateAccelerationStructureKHR :: fn (device: VkDevice, pCreateInfo: *VkAccelerationStructureCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pAccelerationStructure: *VkAccelerationStructureKHR) VkResult #extern;
vkDestroyAccelerationStructureKHR :: fn (device: VkDevice, accelerationStructure: VkAccelerationStructureKHR, pAllocator: *VkAllocationCallbacks) #extern;
vkCmdBuildAccelerationStructuresKHR :: fn (commandBuffer: VkCommandBuffer, infoCount: u32, pInfos: *VkAccelerationStructureBuildGeometryInfoKHR, ppBuildRangeInfos: **VkAccelerationStructureBuildRangeInfoKHR) #extern;
vkCmdBuildAccelerationStructuresIndirectKHR :: fn (commandBuffer: VkCommandBuffer, infoCount: u32, pInfos: *VkAccelerationStructureBuildGeometryInfoKHR, pIndirectDeviceAddresses: *VkDeviceAddress, pIndirectStrides: *u32, ppMaxPrimitiveCounts: **u32) #extern;
vkBuildAccelerationStructuresKHR :: fn (device: VkDevice, deferredOperation: VkDeferredOperationKHR, infoCount: u32, pInfos: *VkAccelerationStructureBuildGeometryInfoKHR, ppBuildRangeInfos: **VkAccelerationStructureBuildRangeInfoKHR) VkResult #extern;
vkCopyAccelerationStructureKHR :: fn (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *VkCopyAccelerationStructureInfoKHR) VkResult #extern;
vkCopyAccelerationStructureToMemoryKHR :: fn (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *VkCopyAccelerationStructureToMemoryInfoKHR) VkResult #extern;
vkCopyMemoryToAccelerationStructureKHR :: fn (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pInfo: *VkCopyMemoryToAccelerationStructureInfoKHR) VkResult #extern;
vkWriteAccelerationStructuresPropertiesKHR :: fn (device: VkDevice, accelerationStructureCount: u32, pAccelerationStructures: *VkAccelerationStructureKHR, queryType: VkQueryType, dataSize: usize, pData: C.void_ptr, stride: usize) VkResult #extern;
vkCmdCopyAccelerationStructureKHR :: fn (commandBuffer: VkCommandBuffer, pInfo: *VkCopyAccelerationStructureInfoKHR) #extern;
vkCmdCopyAccelerationStructureToMemoryKHR :: fn (commandBuffer: VkCommandBuffer, pInfo: *VkCopyAccelerationStructureToMemoryInfoKHR) #extern;
vkCmdCopyMemoryToAccelerationStructureKHR :: fn (commandBuffer: VkCommandBuffer, pInfo: *VkCopyMemoryToAccelerationStructureInfoKHR) #extern;
vkGetAccelerationStructureDeviceAddressKHR :: fn (device: VkDevice, pInfo: *VkAccelerationStructureDeviceAddressInfoKHR) VkDeviceAddress #extern;
vkCmdWriteAccelerationStructuresPropertiesKHR :: fn (commandBuffer: VkCommandBuffer, accelerationStructureCount: u32, pAccelerationStructures: *VkAccelerationStructureKHR, queryType: VkQueryType, queryPool: VkQueryPool, firstQuery: u32) #extern;
vkGetDeviceAccelerationStructureCompatibilityKHR :: fn (device: VkDevice, pVersionInfo: *VkAccelerationStructureVersionInfoKHR, pCompatibility: *VkAccelerationStructureCompatibilityKHR) #extern;
vkGetAccelerationStructureBuildSizesKHR :: fn (device: VkDevice, buildType: VkAccelerationStructureBuildTypeKHR, pBuildInfo: *VkAccelerationStructureBuildGeometryInfoKHR, pMaxPrimitiveCounts: *u32, pSizeInfo: *VkAccelerationStructureBuildSizesInfoKHR) #extern;
VkShaderGroupShaderKHR :: enum s32 {
	VK_SHADER_GROUP_SHADER_GENERAL_KHR = 0x0;
	VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR = 0x1;
	VK_SHADER_GROUP_SHADER_ANY_HIT_KHR = 0x2;
	VK_SHADER_GROUP_SHADER_INTERSECTION_KHR = 0x3;
	VK_SHADER_GROUP_SHADER_MAX_ENUM_KHR = 0x7fffffff;
}
VkRayTracingShaderGroupCreateInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	t: VkRayTracingShaderGroupTypeKHR;
	generalShader: u32;
	closestHitShader: u32;
	anyHitShader: u32;
	intersectionShader: u32;
	pShaderGroupCaptureReplayHandle: C.void_ptr;
}
VkRayTracingPipelineInterfaceCreateInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	maxPipelineRayPayloadSize: u32;
	maxPipelineRayHitAttributeSize: u32;
}
VkRayTracingPipelineCreateInfoKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	flags: VkPipelineCreateFlags;
	stageCount: u32;
	pStages: *VkPipelineShaderStageCreateInfo;
	groupCount: u32;
	pGroups: *VkRayTracingShaderGroupCreateInfoKHR;
	maxPipelineRayRecursionDepth: u32;
	pLibraryInfo: *VkPipelineLibraryCreateInfoKHR;
	pLibraryInterface: *VkRayTracingPipelineInterfaceCreateInfoKHR;
	pDynamicState: *VkPipelineDynamicStateCreateInfo;
	layout: VkPipelineLayout;
	basePipelineHandle: VkPipeline;
	basePipelineIndex: s32;
}
VkPhysicalDeviceRayTracingPipelineFeaturesKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	rayTracingPipeline: VkBool32;
	rayTracingPipelineShaderGroupHandleCaptureReplay: VkBool32;
	rayTracingPipelineShaderGroupHandleCaptureReplayMixed: VkBool32;
	rayTracingPipelineTraceRaysIndirect: VkBool32;
	rayTraversalPrimitiveCulling: VkBool32;
}
VkPhysicalDeviceRayTracingPipelinePropertiesKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	shaderGroupHandleSize: u32;
	maxRayRecursionDepth: u32;
	maxShaderGroupStride: u32;
	shaderGroupBaseAlignment: u32;
	shaderGroupHandleCaptureReplaySize: u32;
	maxRayDispatchInvocationCount: u32;
	shaderGroupHandleAlignment: u32;
	maxRayHitAttributeSize: u32;
}
VkStridedDeviceAddressRegionKHR :: struct {
	deviceAddress: VkDeviceAddress;
	stride: VkDeviceSize;
	size: VkDeviceSize;
}
VkTraceRaysIndirectCommandKHR :: struct {
	width: u32;
	height: u32;
	depth: u32;
}
PFN_vkCmdTraceRaysKHR :: *fn (VkCommandBuffer, *VkStridedDeviceAddressRegionKHR, *VkStridedDeviceAddressRegionKHR, *VkStridedDeviceAddressRegionKHR, *VkStridedDeviceAddressRegionKHR, u32, u32, u32);
PFN_vkCreateRayTracingPipelinesKHR :: *fn (VkDevice, VkDeferredOperationKHR, VkPipelineCache, u32, *VkRayTracingPipelineCreateInfoKHR, *VkAllocationCallbacks, *VkPipeline) VkResult;
PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR :: *fn (VkDevice, VkPipeline, u32, u32, usize, C.void_ptr) VkResult;
PFN_vkCmdTraceRaysIndirectKHR :: *fn (VkCommandBuffer, *VkStridedDeviceAddressRegionKHR, *VkStridedDeviceAddressRegionKHR, *VkStridedDeviceAddressRegionKHR, *VkStridedDeviceAddressRegionKHR, VkDeviceAddress);
PFN_vkGetRayTracingShaderGroupStackSizeKHR :: *fn (VkDevice, VkPipeline, u32, VkShaderGroupShaderKHR) VkDeviceSize;
PFN_vkCmdSetRayTracingPipelineStackSizeKHR :: *fn (VkCommandBuffer, u32);
vkCmdTraceRaysKHR :: fn (commandBuffer: VkCommandBuffer, pRaygenShaderBindingTable: *VkStridedDeviceAddressRegionKHR, pMissShaderBindingTable: *VkStridedDeviceAddressRegionKHR, pHitShaderBindingTable: *VkStridedDeviceAddressRegionKHR, pCallableShaderBindingTable: *VkStridedDeviceAddressRegionKHR, width: u32, height: u32, depth: u32) #extern;
vkCreateRayTracingPipelinesKHR :: fn (device: VkDevice, deferredOperation: VkDeferredOperationKHR, pipelineCache: VkPipelineCache, createInfoCount: u32, pCreateInfos: *VkRayTracingPipelineCreateInfoKHR, pAllocator: *VkAllocationCallbacks, pPipelines: *VkPipeline) VkResult #extern;
vkGetRayTracingCaptureReplayShaderGroupHandlesKHR :: fn (device: VkDevice, pipeline: VkPipeline, firstGroup: u32, groupCount: u32, dataSize: usize, pData: C.void_ptr) VkResult #extern;
vkCmdTraceRaysIndirectKHR :: fn (commandBuffer: VkCommandBuffer, pRaygenShaderBindingTable: *VkStridedDeviceAddressRegionKHR, pMissShaderBindingTable: *VkStridedDeviceAddressRegionKHR, pHitShaderBindingTable: *VkStridedDeviceAddressRegionKHR, pCallableShaderBindingTable: *VkStridedDeviceAddressRegionKHR, indirectDeviceAddress: VkDeviceAddress) #extern;
vkGetRayTracingShaderGroupStackSizeKHR :: fn (device: VkDevice, pipeline: VkPipeline, group: u32, groupShader: VkShaderGroupShaderKHR) VkDeviceSize #extern;
vkCmdSetRayTracingPipelineStackSizeKHR :: fn (commandBuffer: VkCommandBuffer, pipelineStackSize: u32) #extern;
VkPhysicalDeviceRayQueryFeaturesKHR :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	rayQuery: VkBool32;
}
VkPhysicalDeviceMeshShaderFeaturesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	taskShader: VkBool32;
	meshShader: VkBool32;
	multiviewMeshShader: VkBool32;
	primitiveFragmentShadingRateMeshShader: VkBool32;
	meshShaderQueries: VkBool32;
}
VkPhysicalDeviceMeshShaderPropertiesEXT :: struct {
	sType: VkStructureType;
	pNext: C.void_ptr;
	maxTaskWorkGroupTotalCount: u32;
	maxTaskWorkGroupCount: [3]u32;
	maxTaskWorkGroupInvocations: u32;
	maxTaskWorkGroupSize: [3]u32;
	maxTaskPayloadSize: u32;
	maxTaskSharedMemorySize: u32;
	maxTaskPayloadAndSharedMemorySize: u32;
	maxMeshWorkGroupTotalCount: u32;
	maxMeshWorkGroupCount: [3]u32;
	maxMeshWorkGroupInvocations: u32;
	maxMeshWorkGroupSize: [3]u32;
	maxMeshSharedMemorySize: u32;
	maxMeshPayloadAndSharedMemorySize: u32;
	maxMeshOutputMemorySize: u32;
	maxMeshPayloadAndOutputMemorySize: u32;
	maxMeshOutputComponents: u32;
	maxMeshOutputVertices: u32;
	maxMeshOutputPrimitives: u32;
	maxMeshOutputLayers: u32;
	maxMeshMultiviewViewCount: u32;
	meshOutputPerVertexGranularity: u32;
	meshOutputPerPrimitiveGranularity: u32;
	maxPreferredTaskWorkGroupInvocations: u32;
	maxPreferredMeshWorkGroupInvocations: u32;
	prefersLocalInvocationVertexOutput: VkBool32;
	prefersLocalInvocationPrimitiveOutput: VkBool32;
	prefersCompactVertexOutput: VkBool32;
	prefersCompactPrimitiveOutput: VkBool32;
}
VkDrawMeshTasksIndirectCommandEXT :: struct {
	groupCountX: u32;
	groupCountY: u32;
	groupCountZ: u32;
}
PFN_vkCmdDrawMeshTasksEXT :: *fn (VkCommandBuffer, u32, u32, u32);
PFN_vkCmdDrawMeshTasksIndirectEXT :: *fn (VkCommandBuffer, VkBuffer, VkDeviceSize, u32, u32);
PFN_vkCmdDrawMeshTasksIndirectCountEXT :: *fn (VkCommandBuffer, VkBuffer, VkDeviceSize, VkBuffer, VkDeviceSize, u32, u32);
vkCmdDrawMeshTasksEXT :: fn (commandBuffer: VkCommandBuffer, groupCountX: u32, groupCountY: u32, groupCountZ: u32) #extern;
vkCmdDrawMeshTasksIndirectEXT :: fn (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, drawCount: u32, stride: u32) #extern;
vkCmdDrawMeshTasksIndirectCountEXT :: fn (commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize, countBuffer: VkBuffer, countBufferOffset: VkDeviceSize, maxDrawCount: u32, stride: u32) #extern;

VkPhysicalDeviceRayTracingValidationFeaturesNV :: struct {
	sType: VkStructureType;
	pNext: *u8;
	rayTracingValidation: VkBool32;
}

#scope_private
C :: #import "libc";