//! # Draw
//!
//! `#import "extra/draw"`
//!
//! Collection of simple 2D primitive rendering functions. Internally the module uses OpenGL core
//! profile for rendering and is supposed to be used for simple games or quick prototyping.
//!
//! The `draw` module is not supposed to be an OpenGL replacement, if you want to do some advanced
//! rendering, use OpenGL directly.
//!
//! ## Features
//!
//! - Rendering of colored 2D rectangles with rotation.
//! - Rendering of textured 2D rectangles with rotation.
//! - Text rendering.
//! - PNG texture loading using `png` module.
//! - TTF font loading using `freetype2` module.
//!
//! ## Notes
//!
//! - Module does not handle window creation and system events. Use i.e. `glfw` to do it.
//! - The module is not feature-complete and still under development, all missing/required functionality
//!   should be implemented in the future; current implementation is mainly used to demonstrate the language
//!   capabilities.
//!
//! ## General desing
//! The `draw` API is based on switching the global context of rendering primitives (rectangles). In example
//! to draw bunch of colored rectangles we must set the propper shader first:
//!
//! ```bl
//! set_shader_color(); // Prepare renderer for rendering of colored rectangles.
//!
//! rect(10.f, 10.f, 100.f, 100.f, v4.{ 1.f, 0.f, 0.f, 1.f });
//! rect(200.f, 10.f, 100.f, 100.f, v4.{ 0.f, 1.f, 0.f, 1.f });
//! rect(400.f, 10.f, 100.f, 100.f, v4.{ 0.f, 0.f, 1.f, 1.f });
//! ```
//!
//! Internally each call to `rect` just appends the geometry caches; actual rendering is done when currenty
//! used shader is changed or [flush](#drawflush) is called explicitly. This approach reduces count of required draw
//! calls a bit.
//!
//! See the [example](https://github.com/biscuitlang/bl/tree/master/how-to/gunner).

// =================================================================================================
// Main API
// =================================================================================================

/// Draw library initialization must be called once before the module is used. The `viewport_width` and
/// `viewport_height` defines the viewport size in current opengl context. These values are usually the
/// same as the window size.
///
/// The [terminate](#drawterminate) must be called when draw module is not needed anymore.
///
/// The current OpenGL context must be aready set, the minimal required OpenGL version is 3.3 "Core Profile". You can use
/// i.e. `glfw` or similar tool to create window and propper OpenGL context.
///
/// The `gl_init` function is called internally.
///
/// !!! note
///     Window resizing is not supported right now.
init :: fn (viewport_width: s32, viewport_height: s32, initialize_opengl := true) Error {
	if initialize_opengl { gl_init(); }
	current_gl_major_version, current_gl_minor_version :: gl_get_version_numbers();
	if current_gl_major_version < 3 && current_gl_minor_version < 3 {
		return error("Minimal supported OpenGL version is 3.3, current context version is %.%.", current_gl_major_version, current_gl_minor_version);
	}

	gl.Enable(GL_BLEND);
	gl.Enable(GL_LINE_SMOOTH);
	gl.Enable(GL_MULTISAMPLE);
	gl.DepthFunc(GL_LEQUAL);
	gl.BlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	gl.Hint(auto GL_TEXTURE_COMPRESSION_HINT, GL_NICEST);
	gl.Hint(auto GL_POLYGON_SMOOTH_HINT, GL_NICEST);
	// gl.CullFace(GL_BACK);
	set_viewport_size(viewport_width, viewport_height);

	generate_gl_buffers();

	err: Error;
	err = font_library_init();
	if err { return err; }

	err = shader_init(&simple_color_shader, SHADER_SIMPLE_COLOR_SOURCE, "simple-color");
	if err { return err; }

	err = shader_init(&texture_shader, SHADER_TEXTURE_SOURCE, "texture");
	if err { return err; }

	err = shader_init(&text_shader, SHADER_TEXT_SOURCE, "text");
	if err { return err; }

	// gl_check();
	is_initialized = true;
	return OK;
}

/// Set the size of the viewport, this is done automatically in the `init` function call, however this one
/// can be used e.g. in case of the window resize.
set_viewport_size :: fn (viewport_width: s32, viewport_height: s32) {
	gl.Viewport(0, 0, viewport_width, viewport_height);
	mat4_init_ortho(&view_matrix, 0.f, auto viewport_width, auto viewport_height, 0.f, 0.f, 1.f);
}

toggle_gamma_correction :: fn (v: bool) #inline {
	apply_gamma_correction = v;
}

/// Release all resources used by the module. This should be called when the module is not needed anymore.
///
/// The `gl_terminate` function is called internally.
terminate :: fn (terminate_opengl := true) {
	array_terminate(&vertex_buffer);
	array_terminate(&color_buffer);
	array_terminate(&uv_buffer);
	array_terminate(&index_buffer);

	shader_terminate(&texture_shader);
	shader_terminate(&simple_color_shader);
	shader_terminate(&text_shader);
	font_library_terminate();
	delete_gl_buffers();
	if terminate_opengl { gl_terminate(); }
	is_initialized = false;
}

/// Fill the current frame buffer with `color`. This is usually called each frame.
clear_color :: fn (color := v4_zero) #inline {
	gl.ClearColor(color.x, color.y, color.z, color.w);
	gl.Clear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
}

/// Prepare renderer for rendering colored rectangles. Each rectangle can use different color. This method
/// is supposed to be called before [rect](#drawrect) or [rect_centered](#drawrect_centered).
set_shader_color :: fn () #inline {
	new_context :: make_context_color();
	if !compare_context(&context, &new_context) {
		do_render();
		context = new_context;
	}
}

/// Prepare renderer for rendering textured rectangles. This method is supposed to be called before
/// [rect](#drawrect) or [rect_centered](#drawrect_centered) (all rectangles will use the same texture).
set_shader_texture :: fn (texture: *Texture) #inline {
	assert(texture, "Invalid texture.");
	new_context :: make_context_texture(texture);
	if !compare_context(&context, &new_context) {
		do_render();
		context = new_context;
	}
}

/// Prepare the renderer for rendering of a text.
set_shader_font :: fn (font: *Font) #inline {
	assert(font, "Invalid font.");
	new_context :: make_context_font(font);
	if !compare_context(&context, &new_context) {
		do_render();
		context = new_context;
	}
}

/// Draw a single colored rectangle or texture into the frame buffer.
rect :: fn {
	fn (position_x: f32, position_y: f32, width: f32, height: f32, color := v4_one) #inline {
		add_rect([4]v2.{
			v2.{ position_x,         position_y          },
			v2.{ position_x + width, position_y          },
			v2.{ position_x,         position_y + height },
			v2.{ position_x + width, position_y + height }
		}, [4]v4.{ color, color, color, color });
	};
	fn (position_x: f32, position_y: f32, width: f32, height: f32, colors: []v4) #inline {
		assert(colors.len == 4, "You have to provide color for each rectangle corner.");
		add_rect([4]v2.{
			v2.{ position_x,         position_y          },
			v2.{ position_x + width, position_y          },
			v2.{ position_x,         position_y + height },
			v2.{ position_x + width, position_y + height }
		}, colors);
	};
}

/// Draw a single colored rectangle or texture into the frame buffer.
rect_centered :: fn (center_x: f32, center_y: f32, width: f32, height: f32, color := v4_one) #inline {
	rect(center_x - width * 0.5f, center_y - height * 0.5f, width, height, color);
}

rect_rounded :: fn (position_x: f32, position_y: f32, width: f32, height: f32, r: f32, inner_color := v4_one, outer_color := v4_one) #inline {
	if r == 0.f {
		rect(position_x, position_y, width, height, inner_color);
		return;
	}

	px :: position_x;
	py :: position_y;
	w  :: width;
	h  :: height;
	iw :: w - r;
	ih :: h - r;

	base_index :: cast(u32) vertex_buffer.len;

	vertices :: [12]v2.{
		v2.{ px + r, py },
		v2.{ px + iw, py },
		v2.{ px + r, py + r },
		v2.{ px + iw, py + r },
		v2.{ px + r, py + ih },
		v2.{ px + iw, py + ih },
		v2.{ px + r, py + h },
		v2.{ px + iw, py + h },
		v2.{ px, py + r },
		v2.{ px, py + ih },
		v2.{ px + r + iw, py + r },
		v2.{ px + r + iw, py + ih },
	};
	array_push_all(&vertex_buffer, vertices);


	array_push_all(&color_buffer, [12]v4.{
		outer_color, outer_color,
		inner_color, inner_color,
		inner_color, inner_color,
		outer_color, outer_color,
		outer_color, outer_color,
		outer_color, outer_color,
	});

	indices :: [30]u32.{
		base_index + 0,
		base_index + 1,
		base_index + 2,
		base_index + 1,
		base_index + 3,
		base_index + 2,
		base_index + 2,
		base_index + 3,
		base_index + 4,
		base_index + 3,
		base_index + 5,
		base_index + 4,
		base_index + 4,
		base_index + 5,
		base_index + 6,
		base_index + 5,
		base_index + 7,
		base_index + 6,
		base_index + 8,
		base_index + 2,
		base_index + 9,
		base_index + 2,
		base_index + 4,
		base_index + 9,
		base_index + 3,
		base_index + 10,
		base_index + 5,
		base_index + 10,
		base_index + 11,
		base_index + 5,
	};
	array_push_all(&index_buffer, indices);

	add_segment :: fn (px: f32, py: f32, r: f32, c: v4, corner_index: u32, segment: s32) #inline {
		base_index :: cast(u32) vertex_buffer.len;
		steps :: math.max(cast(u32) (r * 0.25f), 3);

		loop i : u32 = 0; i < steps+1; i += 1 {
			a :: (cast(f32) i / cast(f32) steps) * math.F32_HALF_PI + math.F32_HALF_PI * auto segment;
			array_push(&vertex_buffer, v2.{ px - r * math.sin(a), py - r * math.cos(a) } );
			array_push(&color_buffer, c);
		}

		loop i : u32 = 0; i < steps; i += 1 {
			array_push_all(&index_buffer, [3]u32.{
				corner_index,
				base_index + i + 1,
				base_index + i,
			});
		}
	};

	add_segment(px + r, py + r, r, outer_color, base_index + 2, 0);
	add_segment(px + r, py + ih, r, outer_color, base_index + 4, 1);
	add_segment(px + iw, py + ih, r, outer_color, base_index + 5, 2);
	add_segment(px + iw, py + r, r, outer_color, base_index + 3, 3);
}

/// Draw a single colored rectangle or texture with rotation into the frame buffer.
rect_centered_rotated :: fn (center_x: f32, center_y: f32, width: f32, height: f32, angle_in_radians: f32, color := v4_one) #inline {
	pivot :: v2.{ width * 0.5f, height * 0.5f };
	q :: quat_axis_angle(v3.{ 0.f, 0.f, 1.f }, angle_in_radians);
	v_1 := quat_rotate_v3(q, v3.{ -pivot.x,  pivot.y });
	v_2 := quat_rotate_v3(q, v3.{  pivot.x,  pivot.y });
	v_3 := quat_rotate_v3(q, v3.{ -pivot.x, -pivot.y });
	v_4 := quat_rotate_v3(q, v3.{  pivot.x, -pivot.y });

	add_rect([4]v2.{
		v2.{ v_1.x + center_x, v_1.y + center_y},
		v2.{ v_2.x + center_x, v_2.y + center_y},
		v2.{ v_3.x + center_x, v_3.y + center_y},
		v2.{ v_4.x + center_x, v_4.y + center_y},
	}, [4]v4.{ color, color, color, color });
}

/// Draw text into the frame buffer.
text :: fn (position_x: f32, position_y: f32, text: string_view, text_color: v4 = v4_one) #inline {
	code(position_x, position_y, text, []u8.{}, [1]v4.{ text_color });
}

code :: fn (position_x: f32, position_y: f32, code: string_view, character_color_indices: []u8, color_table: []v4) #inline {
	assert(color_table.len > 0);
	assert(context.font, "No font set, please call 'set_shader_font' first.");
	assert(context.shader == &text_shader, "Invalid current shader in use, please call 'set_shader_font' first.");

	if code.len == 0 { return; }

	// fixed_position_x :: math.ceil(position_x);
	// fixed_position_y :: math.ceil(position_y);

	fixed_position_x :: math.round(position_x);
	fixed_position_y :: math.round(position_y);

	aw :: cast(f32) context.font.atlas.width;
	ah :: cast(f32) context.font.atlas.height;

	//directing_glyph_info :: get_glyph_utf32(context.font, cast(u32) 'X');
	space_glyph_info:: get_glyph_utf32(context.font, cast(u32) ' ');

	// p := v2.{ y = directing_glyph_info.top };
	// p := v2.{ y = context.font.height * 0.5f };
	p := v2.{ y = context.font.base_offset_y };

	converted_bytes: s32;
	loop converted_bytes < code.len {
		word :: str_sub(code, converted_bytes);

		text_color := color_table[0];
		if converted_bytes < character_color_indices.len {
			text_color = color_table[auto character_color_indices[converted_bytes]];
		}

		utf32char, decoded_bytes, err_decode := utf8_to_utf32_single_char(word);
		if err_decode {
			utf32char = auto '?';
			decoded_bytes = 1;
		}
		converted_bytes += decoded_bytes;

		if utf32char == cast(u32) '\t' {
			loop i := 0; i < context.font.tab_size; i += 1 {
				p.x += space_glyph_info.advance_x;
			}
			continue;
		} else if utf32char == 0xA0 {
			p.x += space_glyph_info.advance_x;
			continue;
		}

		ci :: get_glyph_utf32(context.font, utf32char);
		x2 ::  p.x + ci.left;
		y2 :: -p.y - ci.top;

		w  :=  ci.width;
		h  :=  ci.height;

		p.x += ci.advance_x;
		p.y += ci.advance_y;

		if w < math.F32_EPSILON || h < math.F32_EPSILON { continue; }

		base_index :: cast(u32) vertex_buffer.len;
		gx :: fixed_position_x + x2;
		gy :: fixed_position_y - y2;

		array_push_all(&vertex_buffer, [4]v2.{
			v2.{ gx    , gy     },
			v2.{ gx + w, gy     },
			v2.{ gx    , gy + h },
			v2.{ gx + w, gy + h },
		});

		gsw :: (ci.width * 3.f) / aw;
		gth :: ci.height / ah;

		array_push_all(&uv_buffer, [4]v2.{
			v2.{ ci.atlas_u_offset      , ci.atlas_v_offset       },
			v2.{ ci.atlas_u_offset + gsw, ci.atlas_v_offset       },
			v2.{ ci.atlas_u_offset      , ci.atlas_v_offset + gth },
			v2.{ ci.atlas_u_offset + gsw, ci.atlas_v_offset + gth }
		});

		array_push_all(&color_buffer, [4]v4.{ text_color, text_color, text_color, text_color });

		array_push_all(&index_buffer, [6]u32.{
			base_index + 0,
			base_index + 1,
			base_index + 2,
			base_index + 1,
			base_index + 3,
			base_index + 2,
		});
	}
}

/// Immediately render all cached stuff into the frame buffer.
flush :: fn () #inline {
	do_render();
}

// =================================================================================================
// Texture
// =================================================================================================

/// Texture channel distribution format.
TextureFormat :: enum u8 {
	RED = 1;
	RGB = 3;
	RGBA = 4;
}

/// Texture representation in `draw` module.
Texture :: struct {
	/// Texture channel distribution format.
	format: TextureFormat;
	/// Bit depth of each channel.
	bit_depth: u8;
	/// Texture image width.
	width: u32;
	/// Texture image height.
	height: u32;
	handle: GLuint;
}

/// Load `png` texture from the `directory/filename`.
texture_init :: fn (texture: *Texture, directory: string_view, filename: string_view) Error {
	// @Incomplete: we should support custom allocators here.
	assert(texture);
	data: *u8;
	filepath := filename;
	if directory.len > 0 {
		filepath = tprint("%/%", directory, filename);
	}
	err :: png_load_from_file(filepath, &data, &texture.width, &texture.height, &texture.bit_depth, &texture.format);
	if err { return err; }
	gl_init_texture_2d(texture, data);
	free(data);
	return OK;
}

/// Release texture data.
texture_terminate :: fn (texture: *Texture) {
	assert(texture);
	gl_terminate_texture(texture);
}

// =================================================================================================
// PNG
// =================================================================================================

/// Loads `png` image from `filepath` into `out_data`. The `out_data` shoud be released by `free` call on caller side.
png_load_from_file :: fn (filepath: string_view, out_data: **u8, out_width: *u32, out_height: *u32, out_bit_depth: *u8, out_format: *TextureFormat) Error {
	stream, err_input :: open_file(filepath, OpenFileMode.READ);
	if err_input { return err_input; }
	defer close_file(&stream);

	return png_load_from_stream(&stream, out_data, out_width, out_height, out_bit_depth, out_format);
}

png_load_from_memory :: fn (data: []u8, out_data: **u8, out_width: *u32, out_height: *u32, out_bit_depth: *u8, out_format: *TextureFormat) Error {
	stream :: make_data_stream(data);
	return png_load_from_stream(&stream, out_data, out_width, out_height, out_bit_depth, out_format);
}

png_load_from_stream :: fn (stream: *io.Stream, out_data: **u8, out_width: *u32, out_height: *u32, out_bit_depth: *u8, out_format: *TextureFormat) Error {
	assert(stream);
	err_sig :: png_validate_signature(stream);
	if err_sig { return err_sig; }

	png_ptr :: png.create_read_struct(png.LIBPNG_VER_STRING.ptr, null, &png_handle_error, &png_handle_warning);
	assert(png_ptr);
	info_ptr :: png.create_info_struct(png_ptr);
	assert(info_ptr);
	png.set_read_fn(png_ptr, auto stream, &png_reader);
	png.set_sig_bytes(png_ptr, auto PNG_SIG_LENGTH);
	png.read_info(png_ptr, info_ptr);

	color_type, bit_depth: s32;
	w, h: u32;
	png.get_IHDR(png_ptr, info_ptr, &w, &h, &bit_depth, &color_type, null, null, null);
	png.read_update_info(png_ptr, info_ptr);
	rowbytes := cast(u32) png.get_rowbytes(png_ptr, info_ptr);
	rowbytes += 3 - ((rowbytes-1) % 4);
	image_data: *png.byte;
	mem, image_data_alloc_err :: alloc(rowbytes * h * sizeof(png.byte)+15);
	if image_data_alloc_err { panic(image_data_alloc_err); }
	image_data = mem;
	row_pointers: []png.bytep;
	row_pointers.len = auto h;
	row_mem, row_alloc_err :: alloc(h * sizeof(png.bytep));
	if row_alloc_err { panic(row_alloc_err); }
	row_pointers.ptr = auto row_mem;
	defer free(auto row_pointers.ptr);
	if row_pointers.ptr == null {
		panic("Bad alloc!");
	}
	loop i : u32 = 0; i < h; i += 1 {
		ptr :: ptr_shift_bytes(image_data, auto i * rowbytes);
		row_pointers[auto h - 1 - i] = ptr;
	}

	png.read_image(png_ptr, row_pointers.ptr);
	png.destroy_read_struct(&png_ptr, &info_ptr, null);

	if out_width { (@out_width) = w; }
	if out_height { (@out_height) = h; }
	if out_bit_depth { (@out_bit_depth) = auto bit_depth; }
	if out_format {
		switch color_type {
			png.COLOR_TYPE_RGB  { (@out_format) = TextureFormat.RGB;  }
			png.COLOR_TYPE_RGBA { (@out_format) = TextureFormat.RGBA; }
			png.COLOR_TYPE_GRAY { (@out_format) = TextureFormat.RED;  }
			default {
				free(image_data);
				return error("Unsupported color format %.", color_type);
			}
		}
	}

	assert(out_data);
	(@out_data) = image_data;

	return OK;
}

// =================================================================================================
// Font Rendering
// =================================================================================================
Font :: struct {
	char_table: Table(u32, GlyphInfo);
	atlas: Texture;
	size: f32;
	height: f32;
	base_offset_y: f32;
	tab_size: s32;
}

GlyphInfo :: struct {
	advance_x: f32;
	advance_y: f32;
	width:     f32;
	height:    f32;
	left:      f32;
	top:       f32;

	atlas_u_offset: f32; // x offset of glyph in texture coordinates
	atlas_v_offset: f32; // y offset of glyph in texture coordinates
}

/// Returns default ASCII character table.
font_default_char_set :: fn () []u32 #inline { return ASCII_CHAR_TABLE; }

/// Generate new character table based on input `chars`.
font_generate_char_set :: fn (chars: string_view, out_set: *[..]u32) {
	err :: utf8_to_utf32(chars, out_set);
	if err { panic(err); } // @Incomplete: return error?
}

/// Initialize new `font` from the 'TTF' file at `directory/filename` at required `size`. Custom `char_set` can be specified in case
/// we need to render some non-ascii unicode characters. Each loaded font must be terminated by [font_terminate](#drawfont_terminate).
font_init_at_size :: fn (font: *Font, directory: string_view, filename: string_view, size: s32, char_set := []u32.{}) Error {
	filepath := filename;
	if directory.len > 0 {
		filepath = tprint("%/%", directory, filename);
	}
	face: *ft2.Face;
	err :: ft2.New_Face(freetype_library, filepath.ptr, 0, &face);
	defer ft2.Done_Face(face);
	if err != 0 {
		return error("Cannot load font % with error %!", filepath, err);
	}

	return font_init(font, face, size, char_set);
}

font_init_at_size_from_memory :: fn (font: *Font, file_data: []u8, size: s32, char_set := []u32.{}) Error {
	face: *ft2.Face;
	err :: ft2.New_Memory_Face(freetype_library, file_data.ptr, auto file_data.len, 0, &face);
	defer ft2.Done_Face(face);
	if err != 0 {
		return error("Cannot load font with error %!", err);
	}

	return font_init(font, face, size, char_set);
}

/// Terminate loaded font.
font_terminate :: fn (font: *Font) {
	if !font { return; }
	tbl_terminate(&font.char_table);
	texture_terminate(&font.atlas);
}

/// Set size of a tab character as `space_count` count of spaces.
font_set_tab_size :: fn (font: *Font, space_count: s32) {
	assert(font);
	assert(space_count >= 0);
	font.tab_size = space_count;
}

text_size :: fn (text: string_view, font: *Font, _len := -1) (width: f32, height: f32) {
	assert(font);

	len := text.len;
	if _len > -1 { len = math.min(text.len, _len); }

	w := 0.f;
	converted_bytes: s32;
	loop converted_bytes < len {
		word :: str_sub(text, converted_bytes);
		glyph: *GlyphInfo;

		if word[0] == '\t' {
			glyph = get_glyph_utf32(font, cast(u32) ' ');
			converted_bytes += 1;
			w += glyph.advance_x * auto font.tab_size;
		} else {
			utf32char, decoded_bytes, err_decode := utf8_to_utf32_single_char(word);
			if err_decode {
				utf32char = auto '?';
				decoded_bytes = 1;
			}
			converted_bytes += decoded_bytes;
			glyph = get_glyph_utf32(font, utf32char);
			w += glyph.advance_x;
		}
	}
	return math.ceil(w), font.height;
}

get_character_count_to_fit :: fn (text: string_view, font: *Font, fit_to: f32, split_by_words := false) s32 {
	assert(font);
	w := 0.f;
	converted_bytes, num, last_space_position: s32;
	space_glyph :: get_glyph_utf32(font, cast(u32) ' ');
	loop converted_bytes < text.len {
		rest :: str_sub(text, converted_bytes);
		glyph: *GlyphInfo;
		if rest[0] == '\t' {
			w += space_glyph.advance_x * auto font.tab_size;
			converted_bytes += 1;
		} else if split_by_words && rest[0] == ' ' {
			w += space_glyph.advance_x;
			last_space_position = converted_bytes;
			converted_bytes += 1;
		} else {
			utf32char, decoded_bytes, err_decode := utf8_to_utf32_single_char(rest);
			if err_decode {
				utf32char = auto '?';
				decoded_bytes = 1;
			}
			converted_bytes += decoded_bytes;
			glyph = get_glyph_utf32(font, utf32char);
			w += glyph.advance_x;
		}
		if w > fit_to {
			if last_space_position > 0 {
				return last_space_position;
			}
			return num;
		}
		num += 1;
	}
	return num;
}

split_text_to_fit :: fn (text: string_view, font: *Font, fit_to: f32, split_by_words := false) (left: string_view, right: string_view) {
	if text.len == 0 { return "", ""; }
	num :: get_character_count_to_fit(text, font, fit_to, split_by_words);
	if num == 0 { return "", text; }
	if num == text.len { return text, ""; }

	return slice_range(text, 0, num), slice_range(text, num+1, text.len);
}

set_scissor :: fn (position_x: f32, position_y: f32, width: f32, height: f32) {
	do_render();
	gl.Enable(GL_SCISSOR_TEST);

	v: [4]GLint;
	gl.GetIntegerv(GL_VIEWPORT, v.ptr);
	gl.Scissor(auto position_x, v[3] - auto position_y + height, auto width, auto height);
}

clear_scissor :: fn () {
	gl.Disable(GL_SCISSOR_TEST);
}

#scope_private
#import "extra/gl"
#import "extra/glm"
#import "std/fs"
#import "std/table"
#import "std/print"
#import "std/array"
#import "std/string"

io   :: #import "std/io";
math :: #import "std/math";
png  :: #import "extra/png";
ft2  :: #import "extra/freetype2";
C    :: #import "libc";

Context :: struct {
	shader:  *Shader;
	texture: *Texture;
	font:    *Font;
}

compare_context :: fn (a: *Context, b: *Context) bool #inline {
	if a.shader  != b.shader  { return false; }
	if a.texture != b.texture { return false; }
	if a.font    != b.font    { return false; }
	return true;
}

make_context_color :: fn () Context #inline {
	return Context.{ shader = &simple_color_shader };
}

make_context_texture :: fn (texture: *Texture) Context #inline {
	return Context.{ shader = &texture_shader, texture = texture };
}

make_context_font :: fn (font: *Font) Context #inline {
	return Context.{ shader = &text_shader, font = font, texture = &font.atlas };
}

context:             Context;
view_matrix:         mat4;
simple_color_shader: Shader;
texture_shader:      Shader;
text_shader:         Shader;
vertex_buffer:       [..]v2;
color_buffer:        [..]v4;
uv_buffer:           [..]v2;
index_buffer:        [..]u32;

apply_gamma_correction := false;

VBO_VERTEX :: 0;
VBO_COLOR  :: 1;
VBO_UV     :: 2;

glbuffers: struct {
	vbo:  [3]GLuint; // vertices, colors, uvs

	ebo: GLuint;
	vao: GLuint;
};

freetype_library: ft2.Library;

is_initialized: bool;

// =================================================================================================
// Rendering
// =================================================================================================

add_rect :: fn (v: []v2, colors: []v4) {
	assert(context.shader == &simple_color_shader || context.shader == &texture_shader, "Invalid current shader in use, please call 'set_shader_*' first.");
	base_index :: cast(u32) vertex_buffer.len;
	array_push_all(&vertex_buffer, v);
	if shader_has_attribute(context.shader, ShaderAttribute.COLOR) {
		array_push_all(&color_buffer, colors);
	}
	if shader_has_attribute(context.shader, ShaderAttribute.UV) {
		array_push_all(&uv_buffer, [_]v2.{
			v2.{ 0.f, 1.f },
			v2.{ 1.f, 1.f },
			v2.{ 0.f, 0.f },
			v2.{ 1.f, 0.f }
		});
	}
	array_push_all(&index_buffer, [_]u32.{
		base_index + 0,
		base_index + 1,
		base_index + 2,
		base_index + 1,
		base_index + 3,
		base_index + 2,
	});
}

do_render :: fn () {
	using ShaderUniform;
	using ShaderAttribute;
	if index_buffer.len == 0 { return; }
	assert(context.shader, "No shader set! Call 'set_shader_*' first.");
	assert(is_initialized, "Rendering engine is not initialized, call 'init' first!");

	USAGE :: GL_DYNAMIC_DRAW;

	gl.BindVertexArray(glbuffers.vao);
	gl.BindBuffer(GL_ARRAY_BUFFER, glbuffers.vbo[VBO_VERTEX]);
	gl.BufferData(
		GL_ARRAY_BUFFER,
		auto cast(usize)vertex_buffer.len * sizeof(v2),
		auto vertex_buffer.ptr,
		USAGE
	);

	if shader_has_attribute(context.shader, COLOR) {
		gl.BindBuffer(GL_ARRAY_BUFFER, glbuffers.vbo[VBO_COLOR]);
		gl.BufferData(
			GL_ARRAY_BUFFER,
			auto cast(usize)color_buffer.len * sizeof(v4),
			auto color_buffer.ptr,
			USAGE
		);
	}

	if shader_has_attribute(context.shader, UV) {
		gl.BindBuffer(GL_ARRAY_BUFFER, glbuffers.vbo[VBO_UV]);
		gl.BufferData(
			GL_ARRAY_BUFFER,
			auto cast(usize)uv_buffer.len * sizeof(v2),
			auto uv_buffer.ptr,
			USAGE
		);
	}

	gl.BindVertexArray(0);

	gl.BindBuffer(GL_ELEMENT_ARRAY_BUFFER, glbuffers.ebo);
	gl.BufferData(
		GL_ELEMENT_ARRAY_BUFFER,
		auto cast(usize)index_buffer.len * sizeof(u32),
		auto index_buffer.ptr,
		USAGE
	);

	shader_use(context.shader);
	defer shader_unuse();

	if context.shader == &text_shader {
		gl.BlendFunc(GL_SRC1_COLOR, GL_ONE_MINUS_SRC1_COLOR);
	} else {
		gl.BlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	}

	shader_bind_uniform(context.shader, MV, view_matrix);
	shader_bind_uniform(context.shader, APPLY_GAMMA, if apply_gamma_correction then 1 else 0);
	if context.texture {
		shader_bind_texture(context.shader, context.texture, DIFFUSE);
	}

	gl.BindVertexArray(glbuffers.vao);

	gl.BindBuffer(GL_ARRAY_BUFFER, glbuffers.vbo[VBO_VERTEX]);
	shader_attrib_ptr(context.shader, VERTEX, v2, 0);

	if shader_has_attribute(context.shader, COLOR) {
		gl.BindBuffer(GL_ARRAY_BUFFER, glbuffers.vbo[VBO_COLOR]);
		shader_attrib_ptr(context.shader, COLOR, v4, 0);
	}

	if shader_has_attribute(context.shader, UV) {
		gl.BindBuffer(GL_ARRAY_BUFFER, glbuffers.vbo[VBO_UV]);
		shader_attrib_ptr(context.shader, UV, v2, 0);
	}

	gl.BindBuffer(GL_ELEMENT_ARRAY_BUFFER, glbuffers.ebo);

	gl.DrawElements(GL_TRIANGLES, auto index_buffer.len, GL_UNSIGNED_INT, null);
	shader_attrib_disable_all(context.shader);

	gl.BlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	vertex_buffer.len  = 0;
	color_buffer.len   = 0;
	uv_buffer.len      = 0;
	index_buffer.len   = 0;
}

generate_gl_buffers :: fn () {
	gl.GenVertexArrays(1, &glbuffers.vao);
	gl.GenBuffers(auto glbuffers.vbo.len, &glbuffers.vbo.ptr);
	gl.GenBuffers(1, &glbuffers.ebo);
}

delete_gl_buffers :: fn () {
	gl.DeleteVertexArrays(1, &glbuffers.vao);
	gl.DeleteBuffers(auto glbuffers.vbo.len, &glbuffers.vbo.ptr);
	gl.DeleteBuffers(1, &glbuffers.ebo);
}

// =================================================================================================
// Texture
// =================================================================================================
gl_init_texture_2d :: fn (texture: *Texture, texture_data: *u8) {
	if texture.handle != 0 {
		gl_terminate_texture(texture);
	}
	gl.GenTextures(1, &texture.handle);
	gl.BindTexture(GL_TEXTURE_2D, texture.handle);
	defer gl.BindTexture(GL_TEXTURE_2D, 0);
	// gl.TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_BASE_LEVEL, 0);
	// gl.TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0);
	gl_format, gl_internal_format: GLenum;
	switch texture.format {
		TextureFormat.RGB  {
			gl_format = GL_RGB;
			gl_internal_format = GL_RGB;
		}
		TextureFormat.RGBA {
			gl_format = GL_RGBA;
			gl_internal_format = GL_RGBA;
		}
		TextureFormat.RED {
			gl_format = GL_RED;
			gl_internal_format = GL_RED;
		}
		default { panic("Invalid color format."); }
	}

	gl.PixelStorei(GL_UNPACK_ROW_LENGTH, 0);
	gl.PixelStorei(GL_UNPACK_IMAGE_HEIGHT, 0);
	gl.TexImage2D(GL_TEXTURE_2D, 0, auto gl_internal_format, auto texture.width, auto texture.height, 0, gl_format, GL_UNSIGNED_BYTE, texture_data);
	gl.TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, auto GL_CLAMP_TO_EDGE);
	gl.TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, auto GL_CLAMP_TO_EDGE);
	gl.TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, auto GL_LINEAR);
	gl.TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, auto GL_LINEAR);
}

gl_terminate_texture :: fn (texture: *Texture) {
	gl.DeleteTextures(1, &texture.handle);
	zeromem(auto texture, sizeof(Texture));
}

// =================================================================================================
// Shader
// =================================================================================================
ShaderUniform :: enum {
	MV;
	APPLY_GAMMA;
	DIFFUSE;
}

ShaderAttribute :: enum {
	VERTEX;
	COLOR;
	UV;
}

Shader :: struct {
	handle: GLuint;
	attrib_locs:  [enum_count(ShaderAttribute)]GLint;
	uniform_locs: [enum_count(ShaderUniform)]GLint;

	texture_unit: s32;
}

shader_init :: fn (shader: *Shader, source: string_view, name: string_view) Error {
	if shader.handle != 0 {
		gl.DeleteProgram(shader.handle);
		zeromem(auto shader, sizeof(@shader));
	}

	shader.handle = compile(source);
	if shader.handle == 0 { return error("Compilation failed of '%' failed.", name); }

	h :: shader.handle;
	shader.attrib_locs[auto ShaderAttribute.VERTEX] = gl_get_attribute(h, "v");
	shader.attrib_locs[auto ShaderAttribute.COLOR]  = gl_get_attribute(h, "fgc");
	shader.attrib_locs[auto ShaderAttribute.UV]     = gl_get_attribute(h, "uv");

	shader.uniform_locs[auto ShaderUniform.MV] = gl_get_uniform(h, "mv");
	shader.uniform_locs[auto ShaderUniform.APPLY_GAMMA] = gl_get_uniform(h, "apply_gamma");
	shader.uniform_locs[auto ShaderUniform.DIFFUSE] = gl_get_uniform(h, "diffuse");

	return OK;
}

shader_terminate :: fn (shader: *Shader) {
	gl.DeleteProgram(shader.handle);
}

shader_use :: fn (shader: *Shader) #inline {
	shader.texture_unit = 0;
	gl.UseProgram(shader.handle);
};

shader_unuse :: fn () #inline {
	gl.UseProgram(0);
};

shader_bind_texture :: fn (shader: *Shader, texture: *Texture, uniform: ShaderUniform) #inline {
	if !shader_has_uniform(shader, uniform) { return; }
	gl.ActiveTexture(GL_TEXTURE0 + auto shader.texture_unit);
	gl.BindTexture(GL_TEXTURE_2D, texture.handle);
	shader_bind_uniform(shader, uniform, shader.texture_unit);
	shader.texture_unit += 1;
}

shader_has_attribute :: fn (shader: *Shader, kind: ShaderAttribute) bool #inline {
	id :: shader.attrib_locs[auto kind];
	return id != -1;
}

shader_has_uniform :: fn (shader: *Shader, kind: ShaderUniform) bool #inline {
	id :: shader.uniform_locs[auto kind];
	return id != -1;
}

shader_bind_uniform :: fn (shader: *Shader, kind: ShaderUniform, v: ?T) {
	id :: shader.uniform_locs[auto kind];
	if id == -1 { return; } // not used or presented in shader program

	#if T == mat4 {
		gl.UniformMatrix4fv(id, 1, auto GL_FALSE, auto &v);
	} else if T == v4 {
		gl.Uniform4f(id, v.x, v.y, v.z, v.w);
	} else if T == v3 {
		gl.Uniform3f(id, v.x, v.y, v.z);
	} else if T == v2 {
		gl.Uniform2f(id, v.x, v.y);
	} else if T == s32 {
		gl.Uniform1i(id, v);
	} else if T == u32 {
		gl.Uniform1ui(id, v);
	} else if T == bool {
		if v {
			gl.Uniform1i(id, 1);
		} else {
			gl.Uniform1i(id, 0);
		}
	} else if T == f32 {
		gl.Uniform1f(id, v);
	} else {
		compiler_error("Unsupported uniform type");
	}
}

shader_attrib_ptr :: fn (shader: *Shader, kind: ShaderAttribute, T: Any, offset: s64) {
	id :: shader.attrib_locs[auto kind];
	if T.type_info.kind != TypeKind.TYPE { panic("Invalid type!"); }
	if offset == -1 { return; } // no such data in buffer
	if id == -1 { return; } // not used or presented in shader program

	gl.EnableVertexAttribArray(auto id);
	type_info :: cast(*TypeInfo) T.data;
	if type_info == typeinfo(v2) {
		gl.VertexAttribPointer(auto id, 2, GL_FLOAT, GL_FALSE, 0, auto offset);
	} else if type_info == typeinfo(v3) {
		gl.VertexAttribPointer(auto id, 3, GL_FLOAT, GL_FALSE, 0, auto offset);
	} else if type_info == typeinfo(v4) {
		gl.VertexAttribPointer(auto id, 4, GL_FLOAT, GL_FALSE, 0, auto offset);
	} else if type_info == typeinfo(s32) {
		gl.VertexAttribIPointer(auto id, 1, GL_INT, GL_FALSE, 0, auto offset);
	} else if type_info == typeinfo(u32) {
		gl.VertexAttribIPointer(auto id, 1, GL_UNSIGNED_INT, GL_FALSE, 0, auto offset);
	} else {
		panic("Invalid attribute pointer value type '%'.", @type_info);
	}
}

shader_attrib_disable_all :: fn (shader: *Shader) {
	loop i := 0; i < shader.attrib_locs.len; i += 1 {
		id :: shader.attrib_locs[i];
		if id == -1 { continue; }
		gl.DisableVertexAttribArray(auto id);
	}
}

compile :: fn (source: string_view) GLuint {
	vs := compile_unit(GL_VERTEX_SHADER, source);
	fs := compile_unit(GL_FRAGMENT_SHADER, source);
	defer gl.DeleteShader(vs);
	defer gl.DeleteShader(fs);
	if vs == 0 || fs == 0 { return 0; }
	program := link(vs, fs);
	return program;
}

link :: fn (vs: u32, fs: u32) u32 {
	program := gl.CreateProgram();
	gl.AttachShader(program, vs);
	gl.AttachShader(program, fs);

	gl.LinkProgram(program);
	is_linked := GL_FALSE;
	gl.GetProgramiv(program, GL_LINK_STATUS, &is_linked);
	if is_linked != GL_TRUE {
		max_length := 0;
		gl.GetProgramiv(program, GL_INFO_LOG_LENGTH, &max_length);
		info := str_make(max_length);
		info.len = max_length;
		defer str_terminate(&info);
		gl.GetProgramInfoLog(program, max_length, &max_length, info.ptr);
		print_err("Shader linker error: \n%\n", info);
		gl.DeleteProgram(program);
		return 0;
	}

	gl.DetachShader(program, fs);
	gl.DetachShader(program, vs);
	return program;
}

compile_unit :: fn (kind: u32, source: string_view) u32 {
	prefix: string_view;
	switch kind {
		GL_VERTEX_SHADER   { prefix = "#version 330 core\n#define SUBPROGRAM_VERTEX\n";   }
		GL_FRAGMENT_SHADER { prefix = "#version 330 core\n#define SUBPROGRAM_FRAGMENT\n"; }
		default { panic(); }
	}
	shader := gl.CreateShader(kind);
	data :: [2]*u8.{ prefix.ptr, source.ptr };
	gl.ShaderSource(shader, auto data.len, data.ptr, 0);
	gl.CompileShader(shader);
	is_compiled := GL_FALSE;
	gl.GetShaderiv(shader, GL_COMPILE_STATUS, &is_compiled);
	if is_compiled != GL_TRUE {
		max_length := 0;
		gl.GetShaderiv(shader, GL_INFO_LOG_LENGTH, &max_length);
		info := str_make(max_length);
		info.len = max_length;
		defer str_terminate(&info);
		gl.GetShaderInfoLog(shader, max_length, &max_length, info.ptr);
		print_err(info);

		return 0;
	}

	return shader;
}

// =================================================================================================
// PNG
// =================================================================================================

PNG_SIG_LENGTH :: 8;

png_validate_signature :: fn (stream: *io.Stream) Error {
	data: [PNG_SIG_LENGTH]u8 #noinit;
	read_bytes, err_read :: io.read(stream, data.ptr, data.len);
	if err_read { return err_read; }
	if read_bytes != PNG_SIG_LENGTH {
		return error("Png data stream malformed.");
	}
	if png.sig_cmp(data.ptr, 0, auto PNG_SIG_LENGTH) != 0 {
		return error("Png data is not recognized as a PNG file format.");
	}

	return OK;
}

png_handle_warning :: fn (_: png.structp, msg: png.const_charp) {
	tmp :: string_view.{ auto C.strlen(auto msg), msg };
	print_warn("[PNG] %.", tmp);
}

png_handle_error :: fn (_: png.structp, msg: png.const_charp) {
	tmp :: string_view.{ auto C.strlen(auto msg), msg };
	print_err("[PNG] %.", tmp);
}

png_reader :: fn (png_ptr: png.structp, out_bytes: png.bytep, count: png.size_t) {
	stream :: cast(*io.Stream) png.get_io_ptr(png_ptr);
	_, err_read :: io.read(stream, out_bytes, auto count);
	if err_read { panic(); }
}

ReadDataStream :: struct #base io.Stream {
	buf:      []u8;
	position: s64;
}

READ_DATA_STREAM_VTABLE :: io.StreamVTable.{
	read  = auto &data_read,
};

// Actual read function implementation.
data_read :: fn (stream: *ReadDataStream, dest: *u8, bytes_to_read: s64) (s64, Error) {
	if stream.position + bytes_to_read >= stream.buf.len {
		return 0, error("Data read overflow!");
	}
	memcpy(dest, &stream.buf[stream.position], auto bytes_to_read);
	stream.position += bytes_to_read;
	return bytes_to_read, OK;
}

make_data_stream :: fn (data: []u8) ReadDataStream {
	tmp: ReadDataStream;
	tmp.vtable = &READ_DATA_STREAM_VTABLE;
	tmp.buf    = data;
	return tmp;
}

// =================================================================================================
// Font Rendering
// =================================================================================================
EMPTY_GLYPH :: GlyphInfo.{};

ASCII_CHAR_TABLE :: [95]u32.{
	32, 33, 34, 35,
	36, 37, 38, 39,
	40, 41, 42, 43,
	44, 45, 46, 47,
	48, 49, 50, 51,
	52, 53, 54, 55,
	56, 57, 58, 59,
	60, 61, 62, 63,
	64, 65, 66, 67,
	68, 69, 70, 71,
	72, 73, 74, 75,
	76, 77, 78, 79,
	80, 81, 82, 83,
	84, 85, 86, 87,
	88, 89, 90, 91,
	92, 93, 94, 95,
	96, 97, 98, 99,
	100, 101, 102, 103,
	104, 105, 106, 107,
	108, 109, 110, 111,
	112, 113, 114, 115,
	116, 117, 118, 119,
	120, 121, 122, 123,
	124, 125, 126,
};

font_library_init :: fn () Error {
	err := ft2.Init_FreeType(&freetype_library);
	if err != 0 {
		return error("Cannot initialize freetype! (%)", err);
	}
	return OK;
}

font_library_terminate :: fn () {
	ft2.Done_FreeType(freetype_library);
}

font_init :: fn (font: *Font, face: *ft2.Face, size: s32, char_set: []u32) Error {
	zeromem(auto font, sizeof(@font));

	err: ft2.Error;

	//err := Set_Char_Size(face, 0, 64 * size, 72, 72);
	err = ft2.Set_Pixel_Sizes(face, 0, auto size);
	if err != 0 {
		return error("Cannot set font size! (%)", err);
	}

	err = ft2.Select_Charmap(face, ft2.ENCODING_UNICODE);
	if err != 0 {
		return error("Cannot set encoding! (%)", err);
	}

	font.size = auto size;
	tbl_init(&font.char_table, 256);

	// Use default char set if not specified.
	if char_set.len == 0 {
		get_char_table(font, font_default_char_set());
	} else {
		get_char_table(font, char_set);
	}

	prepare_atlas(font, face);
	gen_glyphs(font, face);
	font.tab_size = 4;

	return OK;
}

get_glyph_utf32 :: fn (font: *Font, c: u32) *GlyphInfo #inline {
	switch c {
		'\r',
		'\n' { return &EMPTY_GLYPH; }
		default;
	}

	glyph_info :: tbl_lookup_ptr(&font.char_table, c);
	if glyph_info == null {
		return tbl_lookup_ptr(&font.char_table, auto '?');
	}
	return glyph_info;
}

get_char_table :: fn (font: *Font, char_set: []u32) {
	loop i := 0; i < char_set.len; i += 1 {
		tbl_insert(&font.char_table, char_set[i]);
	}
}

prepare_atlas :: fn (font: *Font, face: *ft2.Face) {
	glyph_slot :: face.glyph;
	atlas_w, atlas_h, row_w, row_h: u32;
	loop i := 0; i < font.char_table.len; i += 1 {
		char_code :: font.char_table.keys[i];
		glyph_index := cast(u32) ft2.Get_Char_Index(face, char_code);
		if glyph_index == 0 {
			print_err("Glyph % not found!", char_code);
			continue;
		}

		if ft2.Load_Glyph(face, glyph_index, ft2.LOAD_DEFAULT) != 0 {
			print_err("Cannot load glyph!");
			continue;
		}

		if ft2.Render_Glyph(face.glyph, ft2.RENDER_MODE_LCD) != 0 {
			print_err("Cannot render glyph!");
			continue;
		}

		gw :: glyph_slot.bitmap.width;
		gh :: glyph_slot.bitmap.rows;
		row_w += gw;
		row_h = math.max(row_h, gh);
	}
	atlas_w = row_w;
	atlas_h = row_h;
	// Generate GL atlas texture
	atlas: GLuint;
	gl.GenTextures(1, &atlas);
	gl.BindTexture(GL_TEXTURE_2D, atlas);
	gl.TexImage2D(GL_TEXTURE_2D, 0, auto GL_R8, auto atlas_w, auto atlas_h, 0, GL_RED, GL_UNSIGNED_BYTE, null);
	gl.TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, auto GL_NEAREST);
	gl.TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, auto GL_NEAREST);

	// gl_check();
	font.atlas.handle = atlas;
	font.atlas.width  = atlas_w;
	font.atlas.height = atlas_h;
	gl.BindTexture(GL_TEXTURE_2D, 0);
}

gen_glyphs :: fn (font: *Font, face: *ft2.Face) {
	ox, oy: u32;
	max_height, max_base_offset_y: f32;
	
	max_height = font.size;

	gl.BindTexture(GL_TEXTURE_2D, font.atlas.handle);

	loop i := 0; i < font.char_table.len; i += 1 {
		glyph_info := &font.char_table.values[i];
		char_code ::  font.char_table.keys[i];

		glyph_index := cast(u32) ft2.Get_Char_Index(face, char_code);
		if glyph_index == 0 {
			print_err("Glyph % not found!", char_code);
			continue;
		}

		if ft2.Load_Glyph(face, glyph_index, ft2.LOAD_DEFAULT) != 0 {
			print_err("Cannot load glyph!");
			continue;
		}

		if ft2.Render_Glyph(face.glyph, ft2.RENDER_MODE_LCD) != 0 {
			print_err("Cannot render glyph!");
			continue;
		}

		width  :: face.glyph.bitmap.width;
		height :: face.glyph.bitmap.rows;
		gl.TexSubImage2D(
			GL_TEXTURE_2D,
			0,
			auto ox,
			auto oy,
			auto width,
			auto height,
			GL_RED,
			GL_UNSIGNED_BYTE,
			auto face.glyph.bitmap.buffer
		);

		@glyph_info = GlyphInfo.{
			advance_x      = auto (face.glyph.advance.x >> 6),
			advance_y      = auto (face.glyph.advance.y >> 6),
			width          = auto width / 3, // due to LCD rendering mode
			height         = auto height,
			left           = auto face.glyph.bitmap_left,
			top            = auto face.glyph.bitmap_top,
			atlas_u_offset = cast(f32)ox / cast(f32)font.atlas.width,
			atlas_v_offset = cast(f32)oy / cast(f32)font.atlas.height,
		};

		if char_code < 127 {
			max_base_offset_y = math.max(cast(f32) (face.glyph.metrics.horiBearingY >> 6), max_base_offset_y);
			max_height        = math.max(cast(f32) (face.glyph.metrics.height >> 6), max_height);
		}
		ox += width;
	}

	gl.BindTexture(GL_TEXTURE_2D, 0);
	font.height        = max_height;
	font.base_offset_y = max_base_offset_y;
}

// =================================================================================================
// GLSL
// =================================================================================================

SHADER_SIMPLE_COLOR_SOURCE ::
	"#ifdef SUBPROGRAM_VERTEX\n"
	"layout(location = 0) in vec2 v;\n"
	"layout(location = 1) in vec4 fgc;\n"
	"uniform mat4 mv;\n"
	"out vec4 color;\n"
	"void main(void) {\n"
	"    gl_Position = mv * vec4(v.x, v.y, 0.f, 1.0f);\n"
	"    color = fgc;\n"
	"}\n"
	"#endif\n"
	"#ifdef SUBPROGRAM_FRAGMENT\n"
	"in vec4 color;\n"
	"out vec4 frag_color;\n"
    "uniform int apply_gamma;\n"
	"void main(void) {\n"
    "    if (apply_gamma != 0) { frag_color = vec4(pow(color.rgb, vec3(1.0/2.2)), color.a); }\n"
    "    else { frag_color = color; }\n"
	"}\n"
	"#endif\n"
	;

SHADER_TEXTURE_SOURCE ::
	"#ifdef SUBPROGRAM_VERTEX\n"
	"layout(location = 0) in vec2 v;\n"
	"layout(location = 1) in vec2 uv;\n"
	"uniform mat4 mv;\n"
	"out vec2 st;\n"
	"void main(void) {\n"
	"    gl_Position = mv * vec4(v.x, v.y, 0.f, 1.0f);\n"
	"    st = uv;\n"
	"}\n"
	"#endif\n"
	"#ifdef SUBPROGRAM_FRAGMENT\n"
	"uniform sampler2D diffuse;\n"
	"in vec2 st;\n"
	"out vec4 frag_color;\n"
    "uniform int apply_gamma;\n"
	"void main(void) {\n"
    "    vec4 texel = texture(diffuse, st);\n"
    "    if (apply_gamma != 0) { frag_color = vec4(pow(texel.rgb, vec3(1.0/2.2)), texel.a); }\n"
    "    else { frag_color = texel; }\n"
	"}\n"
	"#endif\n"
	;

SHADER_TEXT_SOURCE ::
	"#ifdef SUBPROGRAM_VERTEX\n"
	"layout(location = 0) in vec2 v;\n"
	"layout(location = 1) in vec2 uv;\n"
	"layout(location = 2) in vec4 fgc;\n"
	"uniform mat4 mv;\n"
	"out vec2 st;\n"
	"out vec4 color;\n"
	"void main(void) {\n"
	"    gl_Position = mv * vec4(v.x, v.y, 0.f, 1.0f);\n"
	"    st = uv;\n"
	"    color = fgc;\n"
	"}\n"
	"#endif\n"
	"#ifdef SUBPROGRAM_FRAGMENT\n"
	"uniform sampler2D diffuse;\n"
	"in vec2 st;\n"
	"in vec4 color;\n"
	"layout(location = 0, index = 0) out vec4 frag_color;\n"
	"layout(location = 0, index = 1) out vec4 mask_color;\n"
    "uniform int apply_gamma;\n"
	"void main(void) {\n"
	"    float sample_left   = textureOffset(diffuse, st, ivec2(-1, 0)).r;\n"
	"    float sample_center = texture(diffuse, st).r;\n"
	"    float sample_right  = textureOffset(diffuse, st, ivec2( 1, 0)).r;\n"
    "    if (apply_gamma != 0) { frag_color = vec4(pow(color.rgb, vec3(1.0/2.2)), color.a); }\n"
    "    else { frag_color = color; }\n"
	"    mask_color = vec4(sample_left * frag_color.a, sample_center * frag_color.a, sample_right * frag_color.a, 1.0);\n"
	"}\n"
	"#endif\n"
	;
