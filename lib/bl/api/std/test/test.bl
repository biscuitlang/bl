// =================================================================================================
// bl
//
// File:   test.bl
// Author: Martin Dorazil
// Date:   2/11/19
//
// Copyright 2018 Martin Dorazil
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// =================================================================================================

// @CLEANUP These functions can be rewritten as polymorphs.

//! # Test
//!
//! `#import "std/test.bl"`
//!
//! Integrated unit testing API.

/// ### Overloads
///
/// ```bl
/// fn (got: string_view, expected: string_view, loc := #call_location)
/// fn (got: string, expected: string_view, loc := #call_location)
/// fn (got: string_view, expected: string, loc := #call_location)
/// fn (got: string, expected: string, loc := #call_location)
/// fn (got: f32, expected: f32, epsilon: f32 = F32_EPSILON, loc := #call_location)
/// fn (got: f64, expected: f64, epsilon: f64 = F64_EPSILON, loc := #call_location)
/// fn (got: ?T, expected: T, loc := #call_location)
/// ```
///
/// Test whether `got` value is equal to `expected` value.
test_eq :: fn {
	// @Cleanup: there is probably better way how to compare strings.
	fn (got: string_view, expected: string_view, loc := #call_location) {
		if str_match(expected, got) { return; }
		print_err("\nExpected: '%'\nGot:      '%'.", expected, got);
		stop(loc);
	};

	fn (got: string, expected: string_view, loc := #call_location) {
		if str_match(expected, got) { return; }
		print_err("\nExpected: '%'\nGot:      '%'.", expected, got);
		stop(loc);
	};

	fn (got: string_view, expected: string, loc := #call_location) {
		if str_match(expected, got) { return; }
		print_err("\nExpected: '%'\nGot:      '%'.", expected, got);
		stop(loc);
	};

	fn (got: string, expected: string, loc := #call_location) {
		if str_match(expected, got) { return; }
		print_err("\nExpected: '%'\nGot:      '%'.", expected, got);
		stop(loc);
	};

	fn (got: f32, expected: f32, epsilon: f32 = math.F32_EPSILON, loc := #call_location) {
		if math.compare(got, expected, epsilon) { return; }
		print_err("\nExpected: '%'\nGot:      '%'.", expected, got);
		stop(loc);
	};

	fn (got: f64, expected: f64, epsilon: f64 = math.F64_EPSILON, loc := #call_location) {
		if math.compare(got, expected, epsilon) { return; }
		print_err("\nExpected: '%'\nGot:      '%'.", expected, got);
		stop(loc);
	};

	fn (got: ?T, expected: T, loc := #call_location) {
		if expected == got { return; }
		print_err("\nExpected: '%'\nGot:      '%'.", expected, got);
		stop(loc);
	};
}

/// ### Overloads
///
/// ```bl
/// fn (got: string, not_expected: string, loc := #call_location)
/// fn (got: string, expected: string_view, loc := #call_location)
/// fn (got: string_view, expected: string, loc := #call_location)
/// fn (got: string, expected: string, loc := #call_location)
/// fn (got: f32, not_expected: f32, epsilon: f32 = F32_EPSILON, loc := #call_location)
/// fn (got: f64, not_expected: f64, epsilon: f64 = F64_EPSILON, loc := #call_location)
/// fn (got: ?T, not_expected: T, loc := #call_location)
/// ```
///
/// Test whether `got` value is not equal to `not_expected` value.
test_neq :: fn {
	// @Cleanup: there is probably better way how to compare strings.
	fn (got: string_view, expected: string_view, loc := #call_location) {
		if !str_match(expected, got) { return; }
		print_err("\nExpected: '%'\nGot:      '%'.", expected, got);
		stop(loc);
	};

	fn (got: string, expected: string_view, loc := #call_location) {
		if !str_match(expected, got) { return; }
		print_err("\nExpected: '%'\nGot:      '%'.", expected, got);
		stop(loc);
	};

	fn (got: string_view, expected: string, loc := #call_location) {
		if !str_match(expected, got) { return; }
		print_err("\nExpected: '%'\nGot:      '%'.", expected, got);
		stop(loc);
	};

	fn (got: string, expected: string, loc := #call_location) {
		if !str_match(expected, got) { return; }
		print_err("\nExpected: '%'\nGot:      '%'.", expected, got);
		stop(loc);
	};

	fn (got: f32, not_expected: f32, epsilon: f32 = math.F32_EPSILON, loc := #call_location) {
		if !math.compare(got, not_expected, epsilon) { return; }
		print_err("Expected not to be '%'.", not_expected);
		stop(loc);
	};
	fn (got: f64, not_expected: f64, epsilon: f64 = math.F64_EPSILON, loc := #call_location) {
		if !math.compare(got, not_expected, epsilon) { return; }
		print_err("Expected not to be '%'.", not_expected);
		stop(loc);
	};
	fn (got: ?T, not_expected: T, loc := #call_location) {
		if got != not_expected { return; }
		print_err("Expected not to be '%'.", not_expected);
		stop(loc);
	};
}

/// Test whether `v1` is greater than `v2`
test_gt :: fn (v1: ?T, v2: T, loc := #call_location) {
	if v1 > v2 { return; }
	print_err("Value '%' is expected to be grater than '%'.", v1, v2);
	stop(loc);
}

/// Test whether `v1` is less than `v2`
test_lt :: fn (v1: ?T, v2: T, loc := #call_location) {
	if v1 < v2 { return; }
	print_err("Value '%' is expected to be less than '%'.", v1, v2);
	stop(loc);
}

/// Test whether `v` value is `true`.
test_true :: fn (v: bool, loc := #call_location) {
	if v { return; }
	print_err("Value expected to be true.");
	stop(loc);
}

/// Test whether `v` value is `false`.
test_false :: fn (v: bool, loc := #call_location) {
	if !v { return; }
	print_err("Value expected to be false.");
	stop(loc);
}

/// Test whether `ptr` pointer value is `null`.
test_null :: fn (ptr: *?T, loc := #call_location) {
	if ptr == null { return; }
	print_err("Pointer is expected to be null.");
	stop(loc);
}

/// Test whether `ptr` pointer value is not `null`.
test_not_null :: fn (ptr: *?T, loc := #call_location) {
	if ptr != null { return; }
	print_err("Pointer is expected not to be null.");
	stop(loc);
}

/// Test whether `err` is OK.
test_ok :: fn (err: Error, loc := #call_location) #inline {
	if err == null { return; }
	print_err("Expected to be OK not '%'.", err);
	stop(loc);
}

/// Test whether `err` is not OK.
test_not_ok :: fn (err: Error, loc := #call_location) #inline {
	if err { return; }
	print_err("Expected not to be OK.");
	stop(loc);
}

/// Test whether `got_err` code is `expected_code`.
test_is_error :: fn (got_err: Error, expected_code: s32, loc := #call_location) #inline {
	if is_error(got_err, expected_code) { return; }
	if got_err {
		print_err(
			"\n"
			"Unexpected error:    '%'\n"
			"Expected error code: '%'\n"
			"Got:                 '%'.", got_err, expected_code, got_err.code);
	} else {
		print_err(
			"\n"
			"Unexpected error:    null\n"
			"Expected error code: '%'\n"
			"Got:                 null.", expected_code);
	}
	stop(loc);
}

/// Execute all registered test cases in current assembly. The `test_run` function uses compiler
/// builtin `TEST_CASES` constant containing slice of all registered test cases in the current
/// assembly (all functions with hash directive `#test`).
///
/// Test case execution can be used in runtime and compile time, in both cases function remap
/// default behaviour of `panic()` function call and try to report all failing tests without
/// termination.
///
/// Formatted output containing information about every test run status and summary report is
/// produced during execution of this function. In case of test failure all needed information
/// about fail source location is reported into standard output.
///
/// Returns number of failed tests.
///
/// ### Example
///
/// ```bl
/// #import "std/test.bl"
/// #import "std/print"
///
/// my_test :: fn () #test {
///     print("Hello from test case!!!\n");
/// }
///
/// main :: fn () s32 {
///     return test_run();
/// }
/// ```
test_run :: fn (print_results := true, ansi_colors := false) s32 {
	sighup :: fn (_: C.int) {};
	C.signal(C.SIGHUP, &sighup);

	print_colors = ansi_colors;

	cases := TEST_CASES;
	if cases.len == 0 then return 0;

	// setup cases
	array_init(&run_queue);
	array_reserve(&run_queue, cases.len);
	defer array_terminate(&run_queue);

	string_pool :: pool_make(application_context.allocator);
	defer release_allocator(&string_pool);

	loop i := 0; i < cases.len; i += 1 {
		case :: &cases[i];
		name := str_new(&string_pool);
		str_concat(&name, case.file, ":", case.line, ": ", case.name);
		array_push(&run_queue, .{ case.func, name });
	}

	old_context :: application_context;
	application_context.abort_fn = &abort_handler;

	run_index = 0;
	loop ; run_index < run_queue.len; run_index += 1 {
		if C.setjmp(&jmp_buffer) == 1 {
			continue;
		}

		test :: &run_queue[run_index];
		test.start_time = os_ftick_ms();
		test.func();
		test.runtime_ms = os_ftick_ms() - test.start_time;
		test.passed = true;

		print("[ % |      ] % (% ms)\n", colorize("PASS", 32), test.name, test.runtime_ms);
	}
	application_context = old_context;

	failed_count: s64;
	loop i := 0; i < run_queue.len; i += 1 {
		if !run_queue[i].passed {
			failed_count += 1;
		}
	}

	if print_results {
		print("\nResults:\n");
		print("%\n", TEXT_LINE);
		loop i := 0; i < run_queue.len; i += 1 {
			test :: &run_queue[i];
			if !test.passed {
				print("[      | % ] % (% ms)\n", colorize("FILE", 31), test.name, test.runtime_ms);
			}
		}
		perc := 100;
		if failed_count > 0 {
			perc = cast(s32) (cast(f32) (run_queue.len - failed_count) / ((cast(f32) run_queue.len) * 0.01f));
			print("%\n", TEXT_LINE);
		}
		// @HACK: Cannot print percent, escape sequence cannot be easily detected here.
		print("Executed: %, passed %%.\n", run_queue.len, perc, "%");
		print("%\n", TEXT_LINE);
	}

	return auto failed_count;
}

#scope_private
#import "std/thread"
#import "std/string"
#import "std/array"
#import "std/pool"
#import "std/print"

math :: #import "std/math";
C    :: #import "libc";

TestRun :: struct {
	func: *fn();
	name: string_view;
	passed: bool;
	runtime_ms: f64;
	start_time: f64;
}

TEXT_LINE :: "--------------------------------------------------------------------------------";
run_queue: [..]TestRun;
run_index: s64;

print_colors: bool;
jmp_buffer: C.jmp_buf;

colorized_buffer: [128]u8;

colorize :: fn (text: string_view, color: u8) string_view {
	if !print_colors then return text;
	len :: bprint(colorized_buffer, "\033[%m%\033[0m", color, text);
	return .{ len, colorized_buffer.ptr };
}

abort_handler :: fn () {
	if __os_is_debugger_present() then __os_debug_break();

	test :: &run_queue[run_index];
	test.runtime_ms = os_ftick_ms() - test.start_time;
	test.passed     = false;
	print("[      | % ] % (% ms)\n", colorize("FAIL", 31), test.name, test.runtime_ms);

	C.longjmp(&jmp_buffer, 1);
}

stop :: fn (loc: *CodeLocation) #inline {
	application_context.print_log_fn(PrintLogKind.ERROR, loc.file, loc.line, "Test failed!");
	unreachable;
}
