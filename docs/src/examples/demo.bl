main :: fn () s32 {
	variables();
	if_statements();
	loops();
	defer_statements();
	arrays();
	array_slices();
	dynamic_arrays();
	string_views();
	dynamic_strings();
	type_info();
	structs();
	function_taking_any();
	polymorph_functions();
	comptime_functions();
	load_data_to_stack();

	return 0;
}

variables :: fn () {
	print_log("=== variables ===");

	// Mutable variable declaration.
	n1 := 10;
	print_log("n1 = %", n1);

	// Mutable variable declaration with explicit type.
	n2 : s32 = 20;
	print_log("n2 = %", n2);

	// Immutable variable declaration.
	N :: 30;
	print_log("N = %", N);

	// BL variables are by default zero initialized unless you
	// use #noinit directive.
	n3: s32;
	print_log("n3 = %", n3);

	n4: s32 #noinit; // Not initialized to 0.
	print_log("n4 = %", n4);
}

if_statements :: fn () {
	print_log("=== if_statements ===");

	v :: 10;

	// Inline if statement.
	if v == 10 then print_log("v is 10");

	// Inline if statement with else branch.
	if v == 10 then print_log("v is 10") else print_log("v is not 10");

	// If statement using blocks (then is optional).
	if v == 10 {
		print_log("v is 10");
	} else {
		print_log("v is not 10");
	}

	// We can use if statement as expresion.
	n := if v == 10 then 20 else 40;
	print_log("n = %", n);
}

loops :: fn () {
	print_log("=== loops ===");

	i := 0;
	loop {
		print_log("i = %", i);
		i += 1;
		// Use break statement to stop the looping.
		if i == 10 then break;
	}

	j := 0;
	loop j < 10 {
		print_log("j = %", j);
		j += 1;
	}

	loop k := 0; k < 10; k += 1 {
		print_log("k = %", k);
	}
}

defer_statements :: fn () {
	print_log("=== defer_statements ===");

	// We have defer as any other "cool" language these days. It can
	// be used to postpone statement execution at the end of scope. So
	// we can pair init/terminate functions together.

	foo :: fn () {
		print_log("A");

		defer print_log("C");
		defer print_log("B");
	};

	foo();
}

arrays :: fn () {
	print_log("=== arrays ===");

	arr: [10]s32; // Zero initialized array of 10 integers.

	// Initialize the array.
	arr = .{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

	// Each array has builtin 'len' as s64 count of elements in
	// the array, and 'ptr' as pointer to the array memory.
	print_log("len = %", arr.len);
	print_log("ptr = %", arr.ptr);

	// Print each element.
	loop i := 0; i < arr.len; i += 1 {
		// Use [index] to access individual array elements.
		print_log("arr[%] = %", i, arr[i]);
	}

	// We can print whole array directly like this.
	print_log("arr = %", arr);
}

array_slices :: fn () {
	print_log("=== array_slices ===");

	// Slices are widely used across the language, in general,
	// slice is just a structure with pointer to first array
	// element and count of elements.

	// Note that in case we have fixed number of elements, we
	// can use "blank identifier" '_' to automatically set the array
	// length bases on element count of the initializer.
	arr :: [_]s32.{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

	// Arrays can be implicitly converted to slices.
	s : []s32 = arr;
	print_log("s = %", s);

	// This feature might be useful in case we for example want pass
	// array of arbitrary sizes into function.

	sum :: fn (arr: []s32) s32 {
		sum := 0;
		loop i := 0; i < arr.len; i += 1 {
			sum += arr[i];
		}
		return sum;
	};

	print_log("sum(arr) = %", sum(arr));
	print_log("sum(arr) = %", sum([3]s32.{ 10, 20, 30 }));
}

dynamic_arrays :: fn () {
	print_log("=== dynamic_arrays ===");

	// BL provides builtin dynamic arrays (implemented in Array module).
	arr: [..]s32;

	loop i := 0; i < 10; i += 1 {
		// Append at the array end.
		array_push(&arr, i);
	}

	// Print count of elements.
	print_log("arr.len = %", arr.len);

	// Print whole array.
	print_log("arr = %", arr);

	// Dynamic arrays can be converted to slices too.
	sum :: fn (arr: []s32) s32 {
		sum := 0;
		loop i := 0; i < arr.len; i += 1 {
			sum += arr[i];
		}
		return sum;
	};

	print_log("sum(arr) = %", sum(arr));

	// Don't forget to release memory allocated by the array.
	array_terminate(&arr);
}

string_views :: fn () {
	print_log("=== string_views ===");

	// Comptime constant string literal.
	name :: "Martin";

	// String views are just slices pointing to actual string data.

	// Print the string directly.
	print_log("My name is %.", name);
	print_log("len = %", name.len);
}

dynamic_strings :: fn () {
	print_log("=== dynamic_strings ===");

	// Dynamic string (similar to dynamic arrays) are again provided by
	// default API in 'std' namespace.

	// Allocate new dynamic string.
	str :: std.str_new("Hello");

	// Append the string.
	std.str_append(&str, " World!");

	// Print the string.
	print_log("str = %", str);

	// Don't forget to release memory allocated by the string.
	std.str_delete(&str);
}

type_info :: fn () {
	print_log("=== type_info ===");

	// Language provides detailed runtime type information via 'typeinfo()'
	// builtin function.

	// Print the type info for 'print' function.
	print_log("%", typeinfo(print));
}

structs :: fn () {
	print_log("=== structs ===");

	{
		// Struct type declaration.
		Entity :: struct {
			position: [3]s32;
			id: u32;
		};

		// To initialize variable of this type you can use compound initializer.
		entity := Entity.{
			position = .{ 10, 20, 30 },
			id = 666,
		};

		// You can againg directly print the structure. Like this:
		print_log("entity = %", entity);

		// What is maybe more cool, you can print even the structure type:
		print_log("T = %", Entity);
	}

	{
		// Structure members can be tagged by u64 value known in compile-time.
		NO_SERIALIZE : u64 : 1;

		Entity :: struct {
			position: [3]s32;
			render_data: *u8 #tag NO_SERIALIZE;
			id: u32;
		};

		// Tag is later accessible in structure member related type info, and
		// can be used in runtime.
		// Here we exclude automatically all members tagged as NO_SERIALIZE from
		// serialization.

		info_struct :: cast(*TypeInfoStruct) typeinfo(Entity);
		loop i := 0; i < info_struct.members.len; i += 1 {
			member :: info_struct.members[i];
			if member.tag == NO_SERIALIZE then continue;
			print_log("Serialize member '%'!", member.name);
		}
	}
}

function_taking_any :: fn () {
	print_log("=== function_taking_any ===");

	// The value of Any type contains pointer to type information and pointer
	// to data. This way we can implement reusable "generic" function (like for example
	// print/print_log we already used a lot).

	print_number_or_bool :: fn (v: Any) {
		if v.type_info.kind == TypeKind.INT {
			// v.data is pointer to u8 type.
			v_int :: @(cast(*s32)v.data); // @ is dereference of pointer
			print_log("Number: %", v_int);
		} else if v.type_info.kind == TypeKind.BOOL {
			v_bool :: @(cast(*bool)v.data);
			print_log("Boolean: %", if v_bool then "TRUE" else "FALSE");
		}
	};

	// Notice we do not need to do explicit conversion here, anything can by converted
	// to Any implicitly. (Even types)
	print_number_or_bool(10);
	print_number_or_bool(false);
}

function_returning_multiple_values :: fn () {
	print_log("=== function_returning_multiple_values ===");
}

polymorph_functions :: fn () {
	print_log("=== polymorph_functions ===");
}

comptime_functions :: fn () {
	print_log("=== comptime_functions ===");
}

load_data_to_stack :: fn () {
	print_log("=== load_data_to_stack ===");
}


