<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="styles.css">
<link rel="icon" type="image/x-icon" href="favicon.png">
</head>
<body>
<div class="container">
<div class="column" id="column1">
<div class="logo">
<img src="biscuit_logo.svg">
<label class="version">0.11.0</label>
</div>
<ul id="menu-top-level">
<li id="menu-top-level-item"><a href="index.html">Home</a></li>
<li id="menu-top-level-item"><a href="installation.html">Installation</a></li>
<li id="menu-top-level-item"><a href="manual.html">Manual</a></li>
<li id="menu-top-level-item"><a href="modules.html">Modules</a></li>
<li id="menu-top-level-item"><a href="examples.html">Examples</a></li>
</ul>
</div>
<div class="column" id="column2">
<h1 id="Memory">Memory</h1>

<pre><code><span class="syntax-directive">#load</span> "std/memory.bl"
</code></pre>
<p>Toolset for manipulation with the system memory.</p>
<h2 id="Memory-allocator">Memory allocator</h2>
<p>Memory allocators are used across the entire program to manage allocated memory resources used
in runtime. Since memory allocation can be an expensive operation in some cases, it's good to
provide an explicit API, giving information enough to fix bugs, memory leaks and performance
issues.</p>
<p>Memory allocator in BL world is just some context <a href="#allocator">Allocator</a> structure used by an
allocator <a href="#allocfn">handler function</a>.</p>
<p>Functions like <a href="#alloc">alloc</a> and <a href="#free">free</a> internally use allocator set in global executable
context <code>application_context</code> variable. Global context allocator is by default set to <code>default_allocator</code>
and can be changed as needed.</p>
<h2 id="DEFAULT_ALIGNMENT">DEFAULT_ALIGNMENT</h2>

<pre><code>DEFAULT_ALIGNMENT : usize : 
</code></pre>
<p>Default memory allocation alignment.</p>
<p><em>File: memory.bl</em></p>
<h2 id="default_allocator">default_allocator</h2>

<pre><code>default_allocator :: 
</code></pre>
<p>Default memory allocator using libc malloc internally.</p>
<h3 id="Supported-Operation">Supported Operation</h3>

<pre><code>- [x] Allocate
- [x] Reallocate
- [x] Free
- [ ] Release
- [ ] Reset
</code></pre>
<p><em>File: memory.bl</em></p>
<h2 id="default_temporary_allocator">default_temporary_allocator</h2>

<pre><code>default_temporary_allocator :: 
</code></pre>
<p>Default temporary allocator instance using pool internally (by default set into the application context).</p>
<p>The temporary allocator (used i.e. by <a href="print.md#tprint">tprint</a> function) is useful in cases we
don't need to keep allocated memory for a long period of time. In general in such a case we allocate,
use and free the memory.</p>
<p>Temporary allocated memory does not need to be explicitly freed (in fact temporary allocator does not
free individual allocations at all even if <code>free</code> is called). A large memory block is preallocated instead
and every allocation lands into this block. Later (at some safe point of execution) when
<a href="#temporary_reset">temporary_reset</a> is called, all previous allocations done via temporary allocator became
invalid (marked as a free space in preallocated block) and can be reused lated.</p>
<p>When temporary allocator is not needed anymore, <a href="temporary_release">temporary_release</a> shall be called to
free all internally preallocated blocks.</p>
<p>Underlying allocator works with thread-local data storage (it's safe to use it in threads without any synchronization
required). But, when used from thread, each thread-local instance must be terminated by <a href="#temporary_release">temporary_release</a>
call. In case you use <code>async</code> module the release is called automatically when internal threads exits.</p>
<h3 id="Example">Example</h3>

<pre><code>main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    <span class="syntax-comment">// Release allocated memory at the end of the scope.</span>
    <span class="syntax-keyword">defer</span> temporary_release();

    <span class="syntax-keyword">loop</span> i := 0; i &lt; 1000; i += 1 <span class="syntax-keyword">{</span>
         <span class="syntax-comment">// Reset the allocator here (all previous alocation are invalid since now).</span>
        <span class="syntax-keyword">defer</span> temporary_reset();

        <span class="syntax-comment">// Allocate memory using temporary allocator.</span>
        int_ptr := <span class="syntax-keyword">cast</span>(*s32) alloc(<span class="syntax-keyword">sizeof</span>(s32), <span class="syntax-keyword">alignof</span>(s32), &default_temporary_allocator);

        <span class="syntax-comment">// Do something here with allocated memory.</span>
        @int_ptr = i;

        <span class="syntax-comment">// There is no need to free allocated memory here.</span>
    <span class="syntax-keyword">}</span>
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<p><span class="hint-note"><b>Note:</b>
The temporary allocator internally use <a href="pool.md#pool_allocator">pool allocator</a>, see the documentation for
more details.</span></p>
<p><em>File: memory.bl</em></p>
<h2 id="AllocOp">AllocOp</h2>

<pre><code>AllocOp :: enum {
    ALLOCATE;
    REALLOCATE;
    FREE;
    RESET;
    RELEASE;
}
</code></pre>
<p>Specify allocator opratation.</p>
<h3 id="Variants">Variants</h3>
<ul>
<li><code>ALLOCATE</code> - Allocation of new memory block is required.</li>
<li><code>REALLOCATE</code> - Reallocate previously allocated memory.</li>
<li><code>FREE</code> - Free of previously allocated memory. This operation is optional (i.e. for pools).</li>
<li><code>RESET</code> - Reset the allocated resources, but keep them for later use.</li>
<li><code>RELEASE</code> - Release all resources but keep the allocator instance in initialized state.</li>
</ul>
<p><em>File: memory.bl</em></p>
<h2 id="AllocFn">AllocFn</h2>

<pre><code>AllocFn :: *fn (ctx: *Allocator, operation: AllocOp, ptr: *u8, size: usize, alignment: usize, file: string_view, line: s32) (mem: *u8, err: Error)
</code></pre>
<p>Allocator handle function type.</p>
<p><em>File: memory.bl</em></p>
<h2 id="Allocator">Allocator</h2>

<pre><code>Allocator :: struct {
    handler: AllocFn;
}
</code></pre>
<p>Default allocator context base. This structure can be used as a base structure for any allocator
implementation.</p>
<h3 id="Members">Members</h3>
<ul>
<li><code>handler</code> - Pointer to the main allocator handler function.</li>
</ul>
<p><em>File: memory.bl</em></p>
<h2 id="alloc">alloc</h2>

<pre><code>alloc :: fn (size: usize, alignment :: DEFAULT_ALIGNMENT, preferred_allocator : *Allocator: null, loc :: #call_location) (mem: *u8, err: Error) #inline
</code></pre>
<p>Allocate memory using specified <code>preferred_allocator</code>. In case the <code>preferred_allocator</code> is null, default application context
allocator is used.</p>
<p>Returns pointer to the newly allocated memory capable to handle <code>size</code> bytes, or fails with <code>Error</code> in case the
allocation is not possible.</p>
<p>The allocation <code>size</code> must be at least 1 byte and the optional <code>alignment</code> must be value of power of two. Use <code>alignof</code>
helper function to resolve the best memory alignment for the required type.</p>
<p><em>File: memory.bl</em></p>
<h2 id="realloc">realloc</h2>

<pre><code>realloc :: fn (ptr: *u8, size: usize, alignment :: DEFAULT_ALIGNMENT, preferred_allocator : *Allocator: null, loc :: #call_location) (mem: *u8, err: Error) #inline
</code></pre>
<p>Reallocate previously allocated memory using the <code>preferred_allocator</code>. In case the <code>preferred_allocator</code> is null,
default application context allocator is used.</p>
<p>Behavior depends on allocator being used. Usually when the previous allocation pointer <code>ptr</code> is specified, the
implementation should try to resize already allocated block of memory to the requested <code>size</code>. In case resize is not
possible, or is not supported by the allocator, new memory block is allocated to handle <code>size</code> of bytes, and data from the
previous block are copied (memory area with size equal the lesser of the new and the old allocation sizes) into the newly
allocated block. The previous allocated block is freed.</p>
<p>The allocation <code>size</code> must be at least 1 byte and the optional <code>alignment</code> must be value of power of two. Use <code>alignof</code>
helper function to resolve the best memory alignment for the required type.</p>
<p>In case the <code>ptr</code> is <code>null</code>, behavior is supposed to be the same as <a href="#alloc">alloc</a>.</p>
<p><em>File: memory.bl</em></p>
<h2 id="new">new</h2>

<pre><code>new :: fn (T: type, noinit :: false, preferred_allocator : *Allocator: null, loc :: #call_location) (ptr: *T, err: Error) #inline
</code></pre>
<p>Allocates new object of type <code>T</code> on heap using <code>preferred_allocator</code>, in case the allocator is not specified, the current context
allocator is used.</p>
<p>Newly allocated memory block is zero initialized by default unless the <code>noinit</code> is <code>true</code>.</p>
<p>Use <a href="#free">free</a> to release allocated memory when it's not needed anymore.</p>
<p><em>File: memory.bl</em></p>
<h2 id="new_slice">new_slice</h2>

<pre><code>new_slice :: fn (TElement: type, element_count: s64, noinit :: false, preferred_allocator : *Allocator: null, loc :: #call_location) (slice: []TElement, err: Error)
</code></pre>
<p>Allocates new slice of 'element_count' elements of 'TElement' type.</p>
<p>Newly allocated memory block is zero initialized by default unless the <code>noinit</code> is <code>true</code>.</p>
<p>Use <a href="#free_slice">free_slice</a> to release allocated memory when it's not needed anymore.</p>
<p><em>File: memory.bl</em></p>
<h2 id="free">free</h2>

<pre><code>free :: fn (ptr: *u8, preferred_allocator : *Allocator: null, loc :: #call_location)  #inline
</code></pre>
<p>Free memory previously allocated by specific <code>preferred_allocator</code>. In case the <code>preferred_allocator</code> is null,
the default application context allocator is used. The <code>ptr</code> can be null.</p>
<p><em>File: memory.bl</em></p>
<h2 id="free_slice">free_slice</h2>

<pre><code>free_slice :: fn (slice: *[]?T, allocator : *Allocator: null, loc :: #call_location) 
</code></pre>
<p>Release slice memory allocated by <a href="#alloc_slice">alloc_slice</a> or <a href="#new_slice">new_slice</a> call. The input slice is
set to the zero initialized state.</p>
<p><span class="hint-warning"><b>Warning:</b>
The <code>allocator</code> must match the allocator used by 'alloc_slice' or 'new_slice'.</span></p>
<p><em>File: memory.bl</em></p>
<h2 id="reset_allocator">reset_allocator</h2>

<pre><code>reset_allocator :: fn (allocator: *Allocator, loc :: #call_location)  #inline
</code></pre>
<p>Invoke the reset operation on the <code>allocator</code>. If supported, the <code>allocator</code> should reset its internal state (make
all allocation invalid) and reuse already allocated memory eventually for following allocations.</p>
<p><em>File: memory.bl</em></p>
<h2 id="release_allocator">release_allocator</h2>

<pre><code>release_allocator :: fn (allocator: *Allocator, loc :: #call_location)  #inline
</code></pre>
<p>Invoke the release operation on the <code>allocator</code>. If the operation is supported, the allocator should release all resources and free
all internally allocated memory.</p>
<p><em>File: memory.bl</em></p>
<h2 id="memcpy">memcpy</h2>

<pre><code>memcpy :: fn (destination: *u8, source: *u8, size: usize) 
</code></pre>
<p>Copy memory of defined <code>size</code> from <code>source</code> to <code>destination</code>. Destination and source size must be at least
<code>size</code> bytes.</p>
<p><em>File: memory.bl</em></p>
<h2 id="memset">memset</h2>

<pre><code>memset :: fn (destination: *u8, value: u8, size: usize) *u8
</code></pre>
<p>Set memory to desired value and return <code>destination</code> pointer. Destination size must be at least <code>size</code> bytes.</p>
<p><em>File: memory.bl</em></p>
<h2 id="memmove">memmove</h2>

<pre><code>memmove :: fn (destination: *u8, source: *u8, size: usize) *u8
</code></pre>
<p>Copy 'size' bytes of data from memory location at 'source' to the 'destination' and returns 'destination'.</p>
<p><em>File: memory.bl</em></p>
<h2 id="zeromem">zeromem</h2>

<pre><code>zeromem :: fn (destination: *u8, size: usize) *u8
</code></pre>
<p>Zero out <code>destination</code> memory of <code>size</code> and return the original <code>destination</code> pointer.
This function is internally optimized to zero the <code>destination</code> memory in 64 bit blocks if possible.</p>
<p><em>File: memory.bl</em></p>
<h2 id="zeroinit">zeroinit</h2>

<pre><code>zeroinit :: fn (ptr: *?T) *T #inline
</code></pre>
<p>Zero initialize memory block at <code>ptr</code> and <code>sizeof(T)</code>. Returns passed <code>ptr</code> this might be useful in case of
"inline chaining".</p>
<h3 id="Example">Example</h3>

<pre><code>foo :: zeroinit(array_push(&my_array));
</code></pre>
<p><em>File: memory.bl</em></p>
<h2 id="zero_slice">zero_slice</h2>

<pre><code>zero_slice :: fn (slice: []?T)  #inline
</code></pre>
<p><em>File: memory.bl</em></p>
<h2 id="swap">swap</h2>

<pre><code>swap :: fn (first: *?T, second: *T)  #inline
</code></pre>
<p>Swaps content of memory at address <code>first</code> and <code>second</code>.</p>
<p><em>File: memory.bl</em></p>
<h2 id="is_aligned">is_aligned</h2>

<pre><code>is_aligned :: fn (ptr: *?T, alignment: usize) bool #inline
</code></pre>
<p>Checks whether passed pointer <code>ptr</code> is properly aligned by <code>alignment</code>.</p>
<p><em>File: memory.bl</em></p>
<h2 id="align_ptr_up">align_ptr_up</h2>

<pre><code>align_ptr_up :: fn (p: *u8, alignment: usize) (p: *u8, adjustment: usize)
</code></pre>
<p>Align pointer <code>p</code> to <code>alignment</code> and return adjusted pointer and number of bytes needed for
adjustment.</p>
<p><span class="hint-warning"><b>Warning:</b>
Cause panic when alignment is not power of two.</span></p>
<p><em>File: memory.bl</em></p>
<h2 id="alloc_slice">alloc_slice</h2>

<pre><code>alloc_slice :: fn (slice: *[]?T, n: s64, zero_initialized :: true, allocator : *Allocator: null, loc :: #call_location) Error
</code></pre>
<p>Allocate heap memory for <code>n</code> elements in the <code>slice</code>. Newly allocated slice can be zero initialized
by setting <code>zero_init</code> to <code>true</code>. Custom allocator can be provided as <code>allocator</code>, the application context
allocator is used in case the <code>allocator</code> is null.</p>
<p>Allocated memory must be released by <a href="#free_slice">free_slice</a> call.</p>
<h3 id="Example">Example</h3>

<pre><code>main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    <span class="syntax-comment">// Allocate slice of 10 numbers</span>
    sl: []s32;
    alloc_slice(&sl, 10);

    <span class="syntax-keyword">loop</span> i := 0; i &lt; sl.len; i += 1 <span class="syntax-keyword">{</span>
        sl[i] = i;
    <span class="syntax-keyword">}</span>

    <span class="syntax-comment">// Release allocated memory</span>
    free_slice(&sl);
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<p><span class="hint-note"><b>Note:</b>
Zero initialization of allocated memory block can be expensive in case of large number of elements.</span></p>
<p><em>File: memory.bl</em></p>
<h2 id="slice_range">slice_range</h2>

<pre><code>slice_range :: fn (slice: []?T, start: s64, end : s64: -1) []T #inline
</code></pre>
<p>Create slice subset defined as range <code>&lt;start-index, end-index)</code>. Notice that <code>end</code> index
is excluded from range, so <code>slice_range(other, 0, other.len)</code> is valid and returns
new slice pointing to the same data as <code>other</code> slice, and with same size.</p>
<p>Indexing rules:</p>

<pre><code>start &gt;= 0
start &lt; slice.len 
end &gt;= 0
end &lt;= slice.len 
</code></pre>
<p><span class="hint-warning"><b>Warning:</b>
Function cause panic in case combination of <code>start</code> and <code>end</code> is out of <code>slice</code> range.</span></p>
<p><em>File: memory.bl</em></p>
<h2 id="temporary_reset">temporary_reset</h2>

<pre><code>temporary_reset :: fn ()  #inline
</code></pre>
<p>Reduce allocated memory in application context temporary allocator storage, but keeps biggest allocated chunk for
the later use.</p>
<p><span class="hint-warning"><b>Warning:</b>
All resources previously allocated by this allocator became invalid after reset.</span></p>
<p><span class="hint-note"><b>Note:</b>
Call this method i.e. in every event loop (update) iteration.</span></p>
<p><em>File: memory.bl</em></p>
<h2 id="temporary_release">temporary_release</h2>

<pre><code>temporary_release :: fn ()  #inline
</code></pre>
<p>Release all memory allocated by the application context temporary allocator.</p>
<p><span class="hint-warning"><b>Warning:</b>
All resources previously allocated by this allocator became invalid after release.</span></p>
<p><span class="hint-note"><b>Note:</b>
This method is implicitly called at exit of executable (after main).</span></p>
<p><em>File: memory.bl</em></p>
<h2 id="ptr_shift_bytes">ptr_shift_bytes</h2>

<pre><code>ptr_shift_bytes :: fn (ptr: *?T, bytes: s64) *T #inline
</code></pre>
<p>Produce right-shift of input <code>ptr</code> by count of <code>bytes</code>.</p>
<p><em>File: memory.bl</em></p>
<h2 id="ptr_diff">ptr_diff</h2>

<pre><code>ptr_diff :: fn (a: *?T1, b: *?T2) s64 #inline
</code></pre>
<p>Calculates pointer difference <code>a</code> - <code>b</code>.</p>
<p><em>File: memory.bl</em></p>
</div>
<div class="column" id="column3">
<ul id="menu-top-level">
<li id="menu-top-level-item"><a href="#Memory">Memory</a></li>
<ul>
<li><a href="#Memory-allocator">Memory allocator</a></li>
<li><a href="#DEFAULT_ALIGNMENT">DEFAULT_ALIGNMENT</a></li>
<li><a href="#default_allocator">default_allocator</a></li>
<li><a href="#default_temporary_allocator">default_temporary_allocator</a></li>
<li><a href="#AllocOp">AllocOp</a></li>
<li><a href="#AllocFn">AllocFn</a></li>
<li><a href="#Allocator">Allocator</a></li>
<li><a href="#alloc">alloc</a></li>
<li><a href="#realloc">realloc</a></li>
<li><a href="#new">new</a></li>
<li><a href="#new_slice">new_slice</a></li>
<li><a href="#free">free</a></li>
<li><a href="#free_slice">free_slice</a></li>
<li><a href="#reset_allocator">reset_allocator</a></li>
<li><a href="#release_allocator">release_allocator</a></li>
<li><a href="#memcpy">memcpy</a></li>
<li><a href="#memset">memset</a></li>
<li><a href="#memmove">memmove</a></li>
<li><a href="#zeromem">zeromem</a></li>
<li><a href="#zeroinit">zeroinit</a></li>
<li><a href="#zero_slice">zero_slice</a></li>
<li><a href="#swap">swap</a></li>
<li><a href="#is_aligned">is_aligned</a></li>
<li><a href="#align_ptr_up">align_ptr_up</a></li>
<li><a href="#alloc_slice">alloc_slice</a></li>
<li><a href="#slice_range">slice_range</a></li>
<li><a href="#temporary_reset">temporary_reset</a></li>
<li><a href="#temporary_release">temporary_release</a></li>
<li><a href="#ptr_shift_bytes">ptr_shift_bytes</a></li>
<li><a href="#ptr_diff">ptr_diff</a></li>
</ul>
</ul>
</div>
</div>
</body>
</html>
