<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="styles.css">
<link rel="icon" type="image/x-icon" href="favicon.png">
</head>
<body>
<div class="container">
<div class="column" id="column1">
<div class="logo">
<img src="biscuit_logo.svg">
<label class="version">master</label>
</div>
<ul id="menu-top-level">
<li id="menu-top-level-item"><a href="index.html">Home</a></li>
<li id="menu-top-level-item"><a href="installation.html">Installation</a></li>
<li id="menu-top-level-item"><a href="manual.html">Manual</a></li>
<li id="menu-top-level-item"><a href="modules.html">Modules</a></li>
<li id="menu-top-level-item"><a href="examples.html">Examples</a></li>
</ul>
</div>
<div class="column" id="column2">
<h1 id="Introduction">Introduction</h1>
<p><em>Note that the following documentation may be in some cases incomplete and we'll try to improve it soon...</em></p>
<p>Biscuit Language (BL) is an experimental, general-purpose, compiled or interpreted programming language inspired by new C/C++ followers such as Odin, JAI and Zig. The main goal of the language is to create a simple, explicit and pleasant environment for programmers looking for something more abstract than C but not bloated as C++.</p>
<p>Due to this, some of the popular and common concepts are not supported in the language, i.e. there are no <em>objects</em>, complicated inheritance or exceptions in BL. However, some higher-level features such as polymorphic (template) functions, function overloading, runtime type information and compile-time execution are present.</p>
<p>BL compiler is open-source software (distributed under the MIT license) written in C. The compiler itself comes with a slowly growing <em>Standard Library</em> providing various functionality out of the box. The BL compiler uses <em>LLVM</em> backend to produce the final optimized executable.</p>
<p>Currently, all major 64-bit operating systems are supported (Windows, Linux and Mac), however, most of the language development is done on Windows and the compiler or <em>Standard Library</em> may be less reliable on other platforms.</p>
<p>The following sections of this document should guide you through the language from simple, fundamental basics to more complicated concepts. We suppose the reader is familiar with other programming languages such as C or C++ and does have some basic knowledge of how to use a terminal and other programming tools.</p>
<p>So let's start with <em>Hello World</em> program...</p>
<h1 id="Hello-World">Hello World</h1>
<p>In this chapter, we try to create a simple BL program printing out "Hello world!" message into the command line.</p>
<h2 id="The-Main-Function">The Main Function</h2>
<p>To start a new project, we simply need to create a file containing the <em>main</em> function used as an application entry point. So let's call our file <em>hello.bl</em>. Every BL executable requires the <em>main</em> function to be present in the program. Every <em>main</em> function is supposed to return <em>s32</em> (32-bit signed number) as its result state.</p>
<p>The content of <em>hello.bl</em> can look like this:</p>

<pre><code>main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    print("Hello world!\n");
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<h3 id="Print">Print</h3>
<p>Inside the function body, we call <em>print</em> function to print the passed string "Hello world!" into the standard output. The declaration of the <em>print</em> function looks like this:</p>

<pre><code>print :: <span class="syntax-keyword">fn</span> (format: string_view, args: ...) s32 <span class="syntax-keyword">{</span>
    <span class="syntax-comment">// ...</span>
<span class="syntax-keyword">}</span>
</code></pre>
<p>It's declared inside <em>std/print</em> module and it's available by default. From the declaration you can see it takes <em>format</em> and <em>args</em> as input arguments. The type of the <em>format</em> argument is compiler internal type <em>string_view</em> (representation of any string in the language); <em>args</em> argument type is <em>...</em> which allows any number of additional values to be passed into the function.</p>
<h3 id="Return">Return</h3>
<p>The last statement in the <em>main</em> function body is the <code>return</code> statement. The <code>return</code> statement, as in other languages, terminates the execution of the current function and provides some return value. In our case, it's just a 0.</p>
<h2 id="Compile-&-Run">Compile & Run</h2>
<p>To compile our simple program, just type <code>blc hello.bl</code> into the terminal (in the directory containing <code>hello.bl</code> file). The new <code>out.exe</code> executable should be created next to your source file.</p>
<p>This way the BL compiler (called <code>blc</code>) can produce native executable binary for the platform you're running, however, since the BL code can be also interpreted, we can directly execute our program using the same <code>blc</code> command by adding <code>-run</code> parameter before the source file name: <code>blc -run hello.bl</code>. The <em>main</em> function from our example is executed without any native compiled binary creation needed.</p>
<p>The output should look like this:</p>

<pre><code>blc -run hello.bl

Executing 'main' in compile time...
Hello world!
Execution finished with state: 0

Finished in 0.031 seconds.
</code></pre>
<h1 id="Hello-Project">Hello Project</h1>
<p>As you maybe noticed from the previous example, our executable file was called <em>out.exe</em>, so what if we want to change the name without needing to do it manually after each recompilation? To fix this we need to feed the compiler with some additional settings; we need to create a configuration build file to do so.</p>
<p>One common approach to adjusting the build settings configuration is having some kind of build system involved in the language ecosystem. If you're coming from the C/C++ world, you may know <em>CMake</em> or similar tools to manage the project configuration and compilation. However, instead of introducing a whole new system and language, programmers must know to build something, we decided to do it using BL itself, and integrate such a feature directly into the compiler.</p>
<h2 id="Configuration">Configuration</h2>
<p>To use the BL compiler-integrated build pipeline, we have to create the configuration file first. The compiler expects the project's configuration file to be called <code>build.bl</code>. We can reuse our "Hello World" program from the previous chapter, and create <code>build.bl</code> file next to it. The most basic build configuration looks like this:</p>

<pre><code>build :: <span class="syntax-keyword">fn</span> () <span class="syntax-directive">#build_entry</span> <span class="syntax-keyword">{</span>
    exe := add_executable("hello");
    add_unit(exe, "hello.bl");
    compile(exe);
<span class="syntax-keyword">}</span>
</code></pre>
<p>The function <em>build</em> marked as a <em>build_entry</em> is later automatically executed by the compiler. Inside the function body, we create a new executable target "hello" by <em>add_executable</em> function call. Then we add our <code>hello.bl</code> source file into it, and finally, we compile the target.</p>
<h2 id="Compilation">Compilation</h2>
<p>To use our new build script, simply type <code>blc -build</code> into the terminal (in the folder where the <code>build.bl</code> is located). The newly created executable <code>hello.exe</code> should be generated next to the build file.</p>
<h2 id="How-It-Works">How It Works</h2>
<p>The build script file is nothing else than the regular BL program executed directly when <code>-build</code> compiler flag is used. That means we can do any advanced programming here, you can use <code>fs</code> module API to create new files, and directories or to generate any advanced build output.</p>
<p>See also <a href="/modules/build">Build System</a></p>
<h1 id="Variables">Variables</h1>
<h2 id="Syntax-And-Mutability">Syntax And Mutability</h2>
<p>Now let's talk about the language syntax. In BL, the name comes first followed by a colon separating the name of the symbol from its type. Most type specifications in BL can be left empty if the type is obvious from the value assigned to the symbol. The second colon separates the type from the actual value of the symbol. This may be a bit confusing so let's take a look at the simplest case; the variable.</p>

<pre><code>number : s32;

</code></pre>
<p>In this case, we declare a variable named <em>number</em> of type <em>s32</em> and we do not specify any value of the number (the second colon and value are missing). In this case, the type <em>s32</em> is mandatory (there is no value to guess the type from). Also, one very important thing is that if we do not specify the value of the variable explicitly, it's implicitly set to the default value (0 in this case). <em>Note: This is not a case in C for example where the variable stays uninitialized.</em></p>

<pre><code>number : s32 : 10;

</code></pre>
<p>Now our variable <em>number</em> is explicitly initialized to 10 using the literal value. All numeric literals are by default of <em>s32</em> type so we can make the same declaration like this:</p>

<pre><code>number :: 10;

</code></pre>
<p>One important note about the second colon is that it affects the variable mutablitly. Variables can be declared as <em>mutable</em> the variable that can be changed at any time, or <em>immutable</em> we must initialize the variable with some value, and the value cannot be changed later. When the colon is used, we say the variable is <em>immutable</em> or <em>constant</em>.</p>

<pre><code>number :: 10;
number = 20; <span class="syntax-comment">// This is an error. Variable is immutable.</span>

</code></pre>

<pre><code>hello.bl:3:12: error(0036): Cannot assign to immutable constant.
   2 |  number :: 10;
&gt;  3 |  number = 20;
     |            ^
   4 |  return 0;

error: Compilation of target 'hello' failed.
</code></pre>
<p>To declare the variable as <em>mutable</em> we have to do the following:</p>

<pre><code>number := 10; <span class="syntax-comment">// '=' means the variable is mutable.</span>
number = 20;  <span class="syntax-comment">// This is OK now.</span>

</code></pre>
<p>And in case there is no value specified, the variable is every time considered to be mutable.</p>

<pre><code>number: s32; <span class="syntax-comment">// Default value 0.</span>
number = 20; <span class="syntax-comment">// This is also OK.</span>

</code></pre>
<h2 id="Mutability-Of-Structure-Members">Mutability Of Structure Members</h2>
<p>Mutability introduced to variables of <em>struct</em> type is preserved also to all members unless a dereference is introduced explicitly or implicitly. That means the direct member modification is not allowed for immutable variables of <em>struct</em> type, however, if accessed via a pointer, the value can be changed.</p>

<pre><code>Person :: <span class="syntax-keyword">struct</span> <span class="syntax-keyword">{</span>
    name: string_view;
    age: s32;
<span class="syntax-keyword">}</span>

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    person :: Person.<span class="syntax-keyword">{</span><span class="syntax-keyword">}</span>;
    person.age = 10; <span class="syntax-comment">// ERROR</span>

    person_ptr :: &person;
    person_ptr.name = "foo"; <span class="syntax-comment">// OK, access via pointer.</span>

    person_ptr = null; <span class="syntax-comment">// ERROR, the pointer itself is immutable.</span>
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<h2 id="Initialization">Initialization</h2>
<p>As already mentioned, all variables can be initialized to some value in the declaration. In case the initialization value is not specified, the variable is implicitly "zero" initialized.</p>

<pre><code>number: s32;   <span class="syntax-comment">// Default value 0.</span>
boolean: bool; <span class="syntax-comment">// This is also false.</span>

</code></pre>
<p>In case we want to disable the implicit initialization for some reason, we can use <code>#noinit</code> directive after the variable type.</p>

<pre><code>number: s32 <span class="syntax-directive">#noinit</span>;
boolean: bool <span class="syntax-directive">#noinit</span>;

</code></pre>
<p>Both variables are left uninitialized (containing some random data from the stack). Uninitialized variables should not be used before they are set to some meaningful value.</p>
<p>This can be useful in some cases when the default initialization may be expensive; i.e. The initialized variable is a large struct, and we explicitly initialize all its members later.</p>

<pre><code>Data :: <span class="syntax-keyword">struct</span> <span class="syntax-keyword">{</span>
    a: s32;
    b: bool;
    <span class="syntax-comment">// ... lot of other members</span>
<span class="syntax-keyword">}</span>

data: Data <span class="syntax-directive">#noinit</span>; <span class="syntax-comment">// Disable default initialization.</span>
data.a = 10;
data.b = true;
<span class="syntax-comment">// Initialize all other members...</span>

</code></pre>
<h2 id="Local">Local</h2>
<p>Local variables have their lifetime limited to the current block (code usually surrounded by curly braces). They are allocated on the stack frame of an owning function and become invalid when a function returns.</p>

<pre><code>main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    my_local_integer: s32;

    <span class="syntax-keyword">{</span>
        another_one: s32;
    <span class="syntax-keyword">}</span>
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>

</code></pre>
<p>The first local variable in the previous function is declared in the function block, so it's available in the whole function since it's declared. However, the second variable is declared in the anonymous block, it's available only inside this block.</p>

<pre><code>main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    my_local_integer: s32;

    <span class="syntax-keyword">{</span>
        my_local_integer = 1; <span class="syntax-comment">// This is OK.</span>
        another_one: s32;
        another_one = 2; <span class="syntax-comment">// This is also OK.</span>
    <span class="syntax-keyword">}</span>

    another_one = 2; <span class="syntax-comment">// Error!</span>
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>

</code></pre>

<pre><code>hello.bl:10:5: error(0018): Unknown symbol 'another_one'.
    9 |
&gt;  10 |         another_one = 2; <span class="syntax-comment">// Error!</span>
      |         ^^^^^^^^^^^
   11 |         <span class="syntax-keyword">return</span> 0;

error: Compilation of target 'hello' failed.
</code></pre>
<h2 id="Global">Global</h2>
<p>Global variables are in general, variables declared outside of any function. Its lifetime is not limited in any way and they are available anywhere in the program. Since there is no required ordering of symbols declared in global scope, the global variable can be used even before its declaration appears in the file. Due to this, BL does not require any header files or any kind of forward declarations.</p>
<p>All global variables must be initialized; either to a default value or explicitly, so we cannot use <code>#noinit</code> directive the same way as we did with local variables.</p>

<pre><code><span class="syntax-comment">// Mutable initialized to 0.</span>
number: s32;
<span class="syntax-comment">// Mutable initialized to 'true'.</span>
boolean := true;

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    print("number  = %\n", number);
    print("boolean = %\n", boolean);
    print("text    = %\n", text);
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>

<span class="syntax-comment">// Immutable, declared after use.</span>
text :: "Hello";
</code></pre>
<p>The lifetime of global variables can be explicitly limited to the thread by <code>#thread_local</code> directive added after the variable declaration. The thread local variable is later instantiated for each thread separately, so it's safe to use them without any locks. But keep in mind that each instance points to a different memory location (data are not shared between threads).</p>

<pre><code><span class="syntax-directive">#import</span> "std/thread"

COUNT :: 50;
counter: s32 <span class="syntax-directive">#thread_local</span>;

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
	print("Start thread!!!\n");
	<span class="syntax-keyword">defer</span> print("Threads joined!!!\n");
	t1 :: std.thread_create(&first);
	t2 :: std.thread_create(&second);
	std.thread_join(t1);
	std.thread_join(t2);
	
	<span class="syntax-keyword">assert</span>(counter == 0);
	<span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>

first :: <span class="syntax-keyword">fn</span> (args: *u8) s32 <span class="syntax-keyword">{</span>
	<span class="syntax-keyword">loop</span> i := 0; i &lt; COUNT; i += 1 <span class="syntax-keyword">{</span>
		counter += 1;
		os_sleep_ms(5);
	<span class="syntax-keyword">}</span>
	<span class="syntax-keyword">assert</span>(counter == COUNT);
	<span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>

second :: <span class="syntax-keyword">fn</span> (args: *u8) s32 <span class="syntax-keyword">{</span>
	<span class="syntax-keyword">loop</span> i := 0; i &lt; COUNT; i += 1 <span class="syntax-keyword">{</span>
		counter += 1;
		os_sleep_ms(10);
	<span class="syntax-keyword">}</span>
	<span class="syntax-keyword">assert</span>(counter == COUNT);
	<span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>

</code></pre>
<h2 id="Usage-Checks">Usage Checks</h2>
<p>The compiler will check if all declared variables are used and produce warnings eventually. However, variables declared in <em>non-private</em> global scope may be part of an API and are not checked for usage.</p>

<pre><code>name := "Martin";

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    age :: 30;
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>

<span class="syntax-directive">#private</span>
nationality := "CZ";
</code></pre>

<pre><code>test2.bl:9:1: warning: Unused symbol 'nationality'. Mark the symbol as '#maybe_unused'
                       if it's intentional.
   8 | #private
&gt;  9 | nationality := "CZ";
     | ^^^^^^^^^^^
  10 |

test2.bl:4:5: warning: Unused symbol 'age'. Use blank identificator '_' if it's
                       intentional, or mark the symbol as '#maybe_unused'. If it's
                       used only in some conditional or generated code.
   3 | main :: fn () s32 {
&gt;  4 |     age :: 30;
     |     ^^^
   5 |     return 0;
</code></pre>
<p>As you can see, the compiler gives you some possible options on how to disable these warnings.</p>

<pre><code>name := "Martin";

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    _ :: 30; <span class="syntax-comment">// Blank identificator.</span>
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>

<span class="syntax-directive">#private</span>
nationality := "CZ" <span class="syntax-directive">#maybe_unused</span>;
</code></pre>
<h2 id="Shadowing">Shadowing</h2>
<p>It's possible to declare a new variable with the same name in nested scopes, the previous variable is <em>shadowed</em> by the new one. In general, it's not a good idea; however, there are currently no restrictions or limitations. This may change in the future.</p>

<pre><code>name := "Martin";

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    name := "Travis";
    <span class="syntax-keyword">{</span>
        name := "George";
        print("name = %\n", name);
    <span class="syntax-keyword">}</span>
    print("name = %\n", name);
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<h2 id="Comptime-Variables">Comptime Variables</h2>
<p>Compile-time known variable is any immutable variable with a value known in compile-time. In some cases, it's required to do compile-time evaluations of the value. For example, the array type definition requires the element count to be known in compile time.</p>

<pre><code>main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    N := 10;
    array: [N]s32;
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>

<pre><code>test2.bl:3:13: error(0052): Array size must be compile-time constant.
   2 |     N := 10;
&gt;  3 |     array: [N]s32;
     |             ^
   4 |     return 0;
</code></pre>
<p>To fix this, it's enough to make the N variable immutable:</p>

<pre><code>main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    N :: 10; <span class="syntax-comment">// Changed from = to :.</span>
    array: [N]s32;
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<p>The <code>N</code> variable is initialized with compile-time known integer literal, however, if the initialization value is not known in compile-time, we'll get the same error again even if <code>N</code> is immutable.</p>

<pre><code>foo := 10;

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    N :: foo;
    array: [N]s32;
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>

<pre><code>test2.bl:5:13: error(0052): Array size must be compile-time constant.
   4 |     N :: foo;
&gt;  5 |     array: [N]s32;
     |             ^
   6 |     return 0;
</code></pre>
<h1 id="Types">Types</h1>
<h2 id="Fundamental-Types">Fundamental Types</h2>
<table>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
<tr>
<td>s8</td>
<td>Signed 8-bit number.</td>
</tr>
<tr>
<td>s16</td>
<td>Signed 16-bit number.</td>
</tr>
<tr>
<td>s32</td>
<td>Signed 32-bit number.</td>
</tr>
<tr>
<td>s64</td>
<td>Signed 64-bit number.</td>
</tr>
<tr>
<td>u8</td>
<td>Unsigned 8-bit number.</td>
</tr>
<tr>
<td>u16</td>
<td>Unsigned 16-bit number.</td>
</tr>
<tr>
<td>u32</td>
<td>Unsigned 32-bit number.</td>
</tr>
<tr>
<td>u64</td>
<td>Unsigned 64-bit number.</td>
</tr>
<tr>
<td>usize</td>
<td>Unsigned 64-bit size.</td>
</tr>
<tr>
<td>bool</td>
<td>Boolean. (true/false)</td>
</tr>
<tr>
<td>f32</td>
<td>32-bit floating point number.</td>
</tr>
<tr>
<td>f64</td>
<td>64-bit floating point number.</td>
</tr>
<tr>
<td>type</td>
<td>Type of any other type.</td>
</table>
<h2 id="Pointer-Type">Pointer Type</h2>
<p>Represents the address of some allocated data.</p>

<pre><code><span class="syntax-directive">#import</span> "std/test"

pointers :: <span class="syntax-keyword">fn</span> () <span class="syntax-directive">#test</span> <span class="syntax-keyword">{</span>
    i := 666;
    i_ptr : *s32 = &i; <span class="syntax-comment">// taking the address of 'i' variable and set 'i_ptr'</span>
    j := @i_ptr;       <span class="syntax-comment">// pointer dereferencing</span>

    test_true(j == i);
<span class="syntax-keyword">}</span>;
</code></pre>
<h2 id="Array-Type">Array Type</h2>
<p>The array is an aggregate type of multiple values of the same type. Size value must be known in compile-time (unless it's not explicitly marked for automatic element count detection based on content of compound expression). Arrays can be inline initialized with compound block; type is required. Zero initializers can be used for zero initializations of whole array storage, otherwise, we must specify a value for every element in an array.</p>

<pre><code>array_type :: <span class="syntax-keyword">fn</span> () <span class="syntax-directive">#test</span> <span class="syntax-keyword">{</span>
    arr1 : [10] s32; <span class="syntax-comment">// declare zero initialized array variable</span>
    arr1[0] = 666;

    arr1.len; <span class="syntax-comment">// yields array element count (s64)</span>
    arr1.ptr; <span class="syntax-comment">// yields pointer to first element '&arr[0]'</span>

    <span class="syntax-comment">// inline initialization of array type</span>
    arr2 := [10].s32<span class="syntax-keyword">{</span><span class="syntax-keyword">}</span>;              <span class="syntax-comment">// Initialize all elements to 0.</span>
    arr3 := [4]s32.<span class="syntax-keyword">{</span> 1, 2, 3, 4 <span class="syntax-keyword">}</span>;   <span class="syntax-comment">// Initialize array to the sequence 1, 2, 3, 4</span>
    arr4 := [_]s32.<span class="syntax-keyword">{</span> 1, 2, 3, 4 ];   <span class="syntax-comment">// The same as previous one but the legth of the array is set automatically.</span>
    arr5 : [4]s32 : .<span class="syntax-keyword">{</span> 1, 2, 3, 4 <span class="syntax-keyword">}</span>; <span class="syntax-comment">// With use of anonymous compound initializer.</span>
<span class="syntax-keyword">}</span>;
</code></pre>
<p>Arrays can be implicitly converted to slices:</p>

<pre><code>array_to_slice :: <span class="syntax-keyword">fn</span> () <span class="syntax-directive">#test</span> <span class="syntax-keyword">{</span>
    arr : [10] s32;
    slice : []s32 = arr;
<span class="syntax-keyword">}</span>;
</code></pre>
<h2 id="String-Type">String Type</h2>
<p>String type in Biscuit aka <code>string_view</code> is a slice containing a pointer to string data and string length. String literals are always zero-terminated. The <code>string_view</code> represents a string of fixed length. In case you want a dynamically allocated string use <code>string</code> type and its associated methods. Values of <code>string</code> can be implicitly converted to <code>string_view</code>.</p>

<pre><code>string_type :: <span class="syntax-keyword">fn</span> () <span class="syntax-directive">#test</span> <span class="syntax-keyword">{</span>
    msg : string_view = "Hello world\n";
    msg.len; <span class="syntax-comment">// character count of the string</span>
    msg.ptr; <span class="syntax-comment">// pointer to the string content</span>
<span class="syntax-keyword">}</span>;
</code></pre>
<h2 id="Slice">Slice</h2>
<p>The array slice consists of the array length and pointer to the first array element.</p>
<p>Slice layout:</p>

<pre><code>Slice :: <span class="syntax-keyword">struct</span> <span class="syntax-keyword">{</span>
    len: s64;
    ptr: *T 
<span class="syntax-keyword">}</span>;
</code></pre>

<pre><code>array_slice :: <span class="syntax-keyword">fn</span> () <span class="syntax-directive">#test</span> <span class="syntax-keyword">{</span>
    arr :: [4]s32.<span class="syntax-keyword">{</span>1, 2, 3, 4<span class="syntax-keyword">}</span>;
    slice : []s32 = arr;
    <span class="syntax-keyword">loop</span> i := 0; i &lt; slice.len; i += 1 <span class="syntax-keyword">{</span>
        print("%\n", slice[i]);
    <span class="syntax-keyword">}</span>
<span class="syntax-keyword">}</span>;
</code></pre>
<p><span class="hint-note"><b>Note:</b>
<code>alloc_slice</code> can be used to allocate a slice on the heap.</span></p>
<h2 id="Struct-Type">Struct Type</h2>
<p>The structure is a composite type representing a group of data as a single type. The structure is as an array another way to define a user data type, but types of structure members could be different. It can be used in situations when it's better to group data into one unit instead of interacting with separate units.</p>
<p>A structure can be declared with the use of <em>struct</em> keyword.</p>

<pre><code>Person :: <span class="syntax-keyword">struct</span> <span class="syntax-keyword">{</span>
    id: s32;
    name: string_view;
    age: s32;
<span class="syntax-keyword">}</span>
</code></pre>
<p>Structure Person in the example consists of id, name and age. Now we can create a variable of this type and fill it with data. To access a person's member fields use <code>.</code> operator.</p>

<pre><code>main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    my_person: Person; <span class="syntax-comment">// Create instance of type Person</span>
    my_person.id = 1;
    my_person.age = 20;
    my_person.name = "Martin";

    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<p>Inline initialization is also possible. We can use a compound expression to set all members at once.</p>

<pre><code>main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    <span class="syntax-comment">// Set all data in person to 0</span>
    my_person1 := Person.<span class="syntax-keyword">{</span><span class="syntax-keyword">}</span>;

    <span class="syntax-comment">// Initialize all members.</span>
    my_person2 := Person.<span class="syntax-keyword">{</span> 1, "Martin", 20 <span class="syntax-keyword">}</span>;

    <span class="syntax-comment">// We can explicitly name the members we want to initialize.</span>
    my_person3 := Person.<span class="syntax-keyword">{</span> id = 1, name = "Martin", age = 20 <span class="syntax-keyword">}</span>;

    <span class="syntax-comment">// We can change the order.</span>
    my_person4 := Person.<span class="syntax-keyword">{</span> name = "Martin", age = 20, id = 1 <span class="syntax-keyword">}</span>;

    <span class="syntax-comment">// Or initialize only something. In such a case the rest is initialized to 0 by default.</span>
    my_person5 := Person.<span class="syntax-keyword">{</span> name = "Martin" <span class="syntax-keyword">}</span>;

    <span class="syntax-comment">// Untyped compound initializer can be used too.</span>
    my_persor6 : Person = .<span class="syntax-keyword">{</span> name = "Martin" <span class="syntax-keyword">}</span>;

    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<p>Structure content can be printed by print function.</p>

<pre><code>main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    my_person := Person.<span class="syntax-keyword">{</span> 1, "Martin", 20 <span class="syntax-keyword">}</span>;
    print("%\n", my_person);

    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>

<pre><code>Person <span class="syntax-keyword">{</span>id = 1, name = Martin, age = 20<span class="syntax-keyword">}</span>
</code></pre>
<p>Due to lacking OOP support, we cannot declare member functions in structures and there is no class or object concept in the language. A common way to manipulate data is by passing them into the function as an argument.</p>

<pre><code>person_add_age :: <span class="syntax-keyword">fn</span> (person: *Person, add: s32) <span class="syntax-keyword">{</span>
    <span class="syntax-comment">// Age can be modified even if the 'person' argument is immutable.</span>
    person.age += add;
<span class="syntax-keyword">}</span>
</code></pre>
<p>A structure can extend any type with the use of <code>#base &lt;T&gt;</code>. This is a kind of inheritance (similar to the C style) where inheritance can be simulated by composition. The <code>#base &lt;T&gt;</code> inserts <code>base: T</code>; as the first member into the structure. The compiler can use this information later to provide more inheritance-related features like merging of scopes to enable direct access to base-type members via <code>.</code> operator or implicit cast from a child to a parent pointer type.</p>
<p>Example of structure extension:</p>

<pre><code>Entity :: <span class="syntax-keyword">struct</span> <span class="syntax-keyword">{</span>
    id: s32 
<span class="syntax-keyword">}</span>

<span class="syntax-comment">// Player has base type Entity</span>
Player :: <span class="syntax-keyword">struct</span> <span class="syntax-directive">#base</span> Entity <span class="syntax-keyword">{</span>
    <span class="syntax-comment">// base: Entity; is implicitly inserted as first member</span>
    name: string_view;
<span class="syntax-keyword">}</span>;

Wall :: <span class="syntax-keyword">struct</span> <span class="syntax-directive">#base</span> Entity <span class="syntax-keyword">{</span>
    height: s32 
<span class="syntax-keyword">}</span>;

Enemy :: <span class="syntax-keyword">struct</span> <span class="syntax-directive">#base</span> Entity <span class="syntax-keyword">{</span>
    health: s32 
<span class="syntax-keyword">}</span>;

<span class="syntax-comment">// Multi-level extension Boss -&gt; Enemy -&gt; Entity</span>
Boss :: <span class="syntax-keyword">struct</span> <span class="syntax-directive">#base</span> Enemy <span class="syntax-keyword">{</span>
    <span class="syntax-comment">// Extended struct can be empty.</span>
<span class="syntax-keyword">}</span>;

struct_extending :: <span class="syntax-keyword">fn</span> () <span class="syntax-directive">#test</span> <span class="syntax-keyword">{</span>
    p: Player;
    p.id = 10; <span class="syntax-comment">// direct access to base-type members</span>
    p.name = "Travis";
    <span class="syntax-keyword">assert</span>(p.base.id == 10); <span class="syntax-comment">// access via .base</span>

    w: Wall;
    w.id = 11;
    w.height = 666;

    e: Enemy;
    e.id = 12;
    e.health = 100;

    b: Boss;
    b.id = 13;

    <span class="syntax-comment">// implicit down cast to entity</span>
    update(&p);
    update(&w);
    update(&e);
    update(&b);
<span class="syntax-keyword">}</span>

update :: <span class="syntax-keyword">fn</span> (e: *Entity) <span class="syntax-keyword">{</span>
    print("id = %\n", e.id);
<span class="syntax-keyword">}</span>
</code></pre>
<h2 id="Union-Type">Union Type</h2>
<p>The union is a special composite type representing the value of multiple types. Union size is always equal to the size of the biggest member type and the memory offset of all members is the same. Union is usually associated with some <em>enum</em> providing information about the stored type.</p>

<pre><code>Token :: <span class="syntax-keyword">union</span> <span class="syntax-keyword">{</span>
    as_string: string_view;
    as_int: s32;
<span class="syntax-keyword">}</span>

Kind :: <span class="syntax-keyword">enum</span> <span class="syntax-keyword">{</span>
    String;
    Int;
<span class="syntax-keyword">}</span>

test_union :: <span class="syntax-keyword">fn</span> () <span class="syntax-directive">#test</span> <span class="syntax-keyword">{</span>
    token1: Token;
    token2: Token;

    <span class="syntax-comment">// Token has total size of the biggest member.</span>
    <span class="syntax-keyword">assert</span>(<span class="syntax-keyword">sizeof</span>(token1 == <span class="syntax-keyword">sizeof</span>(string_view));

    token1.as_string = "This is string";
    consumer(&token, Kind.String);

    token2.as_int = 666;
    consumer(&token, Kind.Int);
<span class="syntax-keyword">}</span>

consumer :: <span class="syntax-keyword">fn</span> (token: *Token, kind: TokenKind) <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">switch</span> kind <span class="syntax-keyword">{</span>
        Kind.String <span class="syntax-keyword">{</span> print("%\n", token.as_string); <span class="syntax-keyword">}</span>
        Kind.Int    <span class="syntax-keyword">{</span> print("%\n", token.as_int); <span class="syntax-keyword">}</span>
        <span class="syntax-keyword">default</span> <span class="syntax-keyword">{</span> <span class="syntax-keyword">panic</span>(); <span class="syntax-keyword">}</span>
    <span class="syntax-keyword">}</span>
<span class="syntax-keyword">}</span>
</code></pre>
<h2 id="Any-Type">Any Type</h2>
<p>Any type is a special builtin structure containing the pointer to TypeInfo and to the data. Any value can be implicitly casted to this type while passed into a function.</p>

<pre><code>Any :: <span class="syntax-keyword">struct</span> <span class="syntax-directive">#compiler</span> <span class="syntax-keyword">{</span>
    type_info: *TypeInfo;
    data: *u8 
<span class="syntax-keyword">}</span>;
</code></pre>
<p>The <em>Any</em> value should never own the original data!</p>
<p>Implicit conversion to <em>Any</em> type may cause stack allocation of a temporary variable on the call side in case the original value does not represent stack or heap-allocated memory. This may cause a <em>hidden</em> overhead in some cases.</p>

<pre><code>...
foo(10); <span class="syntax-comment">// temp for '10' is created here</span>
...

foo :: <span class="syntax-keyword">fn</span> (v: Any) <span class="syntax-keyword">{</span><span class="syntax-keyword">}</span>
</code></pre>
<p>For types converted to <em>Any</em> compiler implicitly sets <code>type_info</code> field to a pointer to the <em>TypeType</em> type-info and the data field to the pointer to the actual type-info of the converted type.</p>

<pre><code>...
foo(s32); <span class="syntax-comment">// Type passed</span>
...

foo :: <span class="syntax-keyword">fn</span> (v: Any) <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">assert</span>(v.type_info.kind == TypeKind.TYPE);

    data_info := <span class="syntax-keyword">cast</span>(*TypeInfo) v.data;
    <span class="syntax-keyword">assert</span>(data_info.kind == TypeKind.INT);
<span class="syntax-keyword">}</span>
</code></pre>
<p>Any can be combined with <em>vargs</em>; a good example of this use case is a <em>print</em> function where <em>args</em> argument type is <em>vargs</em> of <em>Any</em> (... is the same as ...Any). The <em>print</em> function can take values of any type passed as <em>args</em>.</p>

<pre><code>print :: <span class="syntax-keyword">fn</span> (format: string_view, args: ...) <span class="syntax-keyword">{</span>
    ...
<span class="syntax-keyword">}</span>;
</code></pre>
<h2 id="Enum-Type">Enum Type</h2>
<p>The <em>enum</em> represents an integer type with a limited set of possible named values. The underlying integer type can be explicitly specified after <em>enum</em> keyword, otherwise <code>s32</code> is used implicitly. Each possible variant lives in the <em>enum</em> namespace.</p>

<pre><code>Color :: <span class="syntax-keyword">enum</span> <span class="syntax-keyword">{</span>
	RED;    <span class="syntax-comment">// default value 0</span>
	GREEN;  <span class="syntax-comment">// default value 1</span>
	BLUE    <span class="syntax-comment">// default value 2</span>
<span class="syntax-keyword">}</span>;

<span class="syntax-comment">// Enum declaration (base type is u8)</span>
Day :: <span class="syntax-keyword">enum</span> u8 <span class="syntax-keyword">{</span>
	SAT = 1; <span class="syntax-comment">// first value explicitly set to 1</span>
	SUN;     <span class="syntax-comment">// implicitly set to previous value + 1 -&gt; 2</span>
	MON;     <span class="syntax-comment">// 3</span>
	TUE;     <span class="syntax-comment">// ...</span>
	WED;
	THU;
	FRI
<span class="syntax-keyword">}</span>;

EntityKind :: <span class="syntax-keyword">enum</span> <span class="syntax-keyword">{</span>
	<span class="syntax-comment">// All values explicitly defined.</span>
	PLAYER = 10;
	ENEMY  = 32;
	NPC    = 78;
<span class="syntax-keyword">}</span>

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
	<span class="syntax-comment">// Print types:</span>
	print("Color      = %\n", Color);
	print("Day        = %\n", Day);
	print("EntityKind = %\n", EntityKind);

	day := Day.MON;
	print("day = %\n", day);

	<span class="syntax-comment">// We can use 'enum_count' helper function to get count</span>
	<span class="syntax-comment">// of all possible values.</span>
	day_count :: enum_count(Day);
	print("We have % possible days.\n", day_count);

	<span class="syntax-comment">// The 'using' can expose all possible variants of enum</span>
	<span class="syntax-comment">// into the current scope.</span>
	<span class="syntax-keyword">using</span> Day;
	<span class="syntax-keyword">switch</span> day <span class="syntax-keyword">{</span>
		MON <span class="syntax-keyword">{</span> print("It's Monday!\n"); <span class="syntax-keyword">}</span>
		FRI <span class="syntax-keyword">{</span> print("It's Friday!\n"); <span class="syntax-keyword">}</span>
		<span class="syntax-keyword">default</span> <span class="syntax-keyword">{</span> print("It's some other day!\n") ; <span class="syntax-keyword">}</span>
	<span class="syntax-keyword">}</span>

	<span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>

</code></pre>
<h3 id="Nested-Enum-Type">Nested Enum Type</h3>
<p>An enumerator can be nested in any <em>struct</em> in case we want to explicitly associate the enumeration with some data type.</p>

<pre><code>Fruit :: <span class="syntax-keyword">struct</span> <span class="syntax-keyword">{</span>
	kind: <span class="syntax-keyword">enum</span> <span class="syntax-keyword">{</span>
		APPLE;
		ORANGE;
		BANANA;
	<span class="syntax-keyword">}</span>;
<span class="syntax-keyword">}</span>

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
	<span class="syntax-comment">// Access the nested anonymous enum type in the structure.</span>
	kind: Fruit.kind;

	kind = Fruit.kind.APPLE;

	<span class="syntax-comment">// We can use 'using'.</span>
	<span class="syntax-keyword">using</span> Fruit.kind;

	<span class="syntax-keyword">switch</span> kind <span class="syntax-keyword">{</span>
		APPLE  <span class="syntax-keyword">{</span> print("Apple!\n");  <span class="syntax-keyword">}</span>
		ORANGE <span class="syntax-keyword">{</span> print("Orange!\n"); <span class="syntax-keyword">}</span>
		BANANA <span class="syntax-keyword">{</span> print("Banana!\n"); <span class="syntax-keyword">}</span>
	<span class="syntax-keyword">}</span>

	<span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>

</code></pre>
<h2 id="Enum-Flags-Type">Enum Flags Type</h2>
<p>An enumerator can be used as a definition of bit flags by adding #flags directive to the type definition. This directive slightly changes the way how the enumerator values are generated. By default, the enumerator starts with zero variant (if it's not explicitly changed by the programmer) and every following enumerator variant has a value set to the previous one plus one. The flags enumerator starts with the first variant set to 1 and the following variants are set to the left-bit-shifted value of the previous one.</p>
<p>Enumerators marked as flags are also serialized as a combination of atomic flags instead of just one value.</p>

<pre><code>OpenMode :: <span class="syntax-keyword">enum</span> <span class="syntax-directive">#flags</span> <span class="syntax-keyword">{</span>
	READ;   <span class="syntax-comment">// 1</span>
	WRITE;  <span class="syntax-comment">// 2</span>
	APPEND; <span class="syntax-comment">// 4</span>
	CREATE; <span class="syntax-comment">// 8</span>
	WRITE_APPEND = WRITE | APPEND; <span class="syntax-comment">// Combination of multiple variants.</span>
	WRITE_CREATE = WRITE | CREATE;
<span class="syntax-keyword">}</span>

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
	mode: OpenMode; <span class="syntax-comment">// Set to OpenMode.Read by default</span>
	print("mode = %\n", mode);

	<span class="syntax-comment">//</span>
	<span class="syntax-comment">// Set the flag</span>
	<span class="syntax-comment">//</span>

	<span class="syntax-comment">// Set mode to combination of WRITE nad CREATE flags.</span>
	mode = OpenMode.WRITE_CREATE;
	print("mode = %\n", mode);
	
	<span class="syntax-comment">// Note that we can use the | (or) operator on the flags enumerators. To toggle one additional</span>
	<span class="syntax-comment">// flag like this:</span>
	mode |= OpenMode.APPEND;
	print("mode = %\n", mode);

	<span class="syntax-comment">// Reset the mode back to READ only.</span>
	mode = OpenMode.READ;
	print("mode = %\n", mode);

	<span class="syntax-comment">// To set more flags at once, we can use the combination of multiple flags like this:</span>
	mode = OpenMode.WRITE | OpenMode.CREATE | OpenMode.APPEND;
	print("mode = %\n", mode);


	<span class="syntax-comment">//</span>
	<span class="syntax-comment">// Check flags</span>
	<span class="syntax-comment">//</span>

	<span class="syntax-keyword">if</span> (mode & OpenMode.WRITE) == OpenMode.WRITE <span class="syntax-keyword">{</span>
		print("Set!\n");
	<span class="syntax-keyword">}</span> <span class="syntax-keyword">else</span> <span class="syntax-keyword">{</span>
		print("Not set!\n");
	<span class="syntax-keyword">}</span>

	<span class="syntax-comment">// We can use helper function for this.</span>
	<span class="syntax-keyword">if</span> is_flag(mode, OpenMode.WRITE) <span class="syntax-keyword">{</span>
		print("Set!\n");
	<span class="syntax-keyword">}</span> <span class="syntax-keyword">else</span> <span class="syntax-keyword">{</span>
		print("Not set!\n");
	<span class="syntax-keyword">}</span>


	<span class="syntax-comment">// Check the combination. Evaluates true in case WRITE or CREATE is set.</span>
	<span class="syntax-keyword">if</span> is_flag(mode, OpenMode.WRITE | OpenMode.CREATE) <span class="syntax-keyword">{</span>
		print("Set!\n");
	<span class="syntax-keyword">}</span> <span class="syntax-keyword">else</span> <span class="syntax-keyword">{</span>
		print("Not set!\n");
	<span class="syntax-keyword">}</span>

	<span class="syntax-comment">//</span>
	<span class="syntax-comment">// Clear flags</span>
	<span class="syntax-comment">//</span>

	mode &= ~OpenMode.WRITE;
	print("mode = %\n", mode);

	<span class="syntax-comment">// Now check the WRITE flag again...</span>
	<span class="syntax-keyword">if</span> is_flag(mode, OpenMode.WRITE) <span class="syntax-keyword">{</span>
		print("Set!\n");
	<span class="syntax-keyword">}</span> <span class="syntax-keyword">else</span> <span class="syntax-keyword">{</span>
		print("Not set!\n");
	<span class="syntax-keyword">}</span>

	<span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>

</code></pre>
<p>So in comparison to conventional enumerators, bunch of binary operations are allowed for flags enumerators to easily manipulate (set, clear and check) its values. Namely:</p>

<pre><code>&      Intersection.
|      Union.
~      Bit flip.
&=     Assign intersection.
|=     Assign union.
</code></pre>
<p><span class="hint-note"><b>Note:</b>
Since flags enumerators start implicitly with value 1, you can explicitly define <code>NoFlag</code><code> </code><code>= 0;</code> variant at the beginning of the variant list.</span></p>
<p><span class="hint-note"><b>Note:</b>
Flags enumerators should use an unsigned number type as a base type (<code>u32</code> by default).</span></p>
<p><span class="hint-note"><b>Note:</b>
It's possible to do an implicit casting of flags enumerators to its base type.</span></p>
<h2 id="Type-Casting">Type Casting</h2>
<p>Change the type of value to the other type. Conversions between integer types, from pointer to <code>bool</code> and from array to slice are generated implicitly by the compiler.</p>

<pre><code>main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    <span class="syntax-comment">// Default type of integer literal is 's32'.</span>
    i := 666;

    <span class="syntax-comment">// Type of the integer literal is changed to u64.</span>
    j : u16 = 666;

    <span class="syntax-comment">// Implicit cast on function call.</span>
    <span class="syntax-keyword">fn</span> (num: u64) <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">}</span> (j);

    <span class="syntax-comment">// Explicit cast of 'f32' type to 's32'.</span>
    l := 1.5f;
    m := <span class="syntax-keyword">cast</span>(s32) l;
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>;
</code></pre>
<p>Type casting rules in BL are more strict compared to C or C++, there are no void pointers or implicit conversions between integers and enums etc. Despite this fact, an explicit cast can be in some cases replaced by <em>auto</em> cast. The <em>auto</em> cast operator does not need explicit destination type notation, it will automatically detect destination type based on expression if possible. When an <em>auto</em> operator cannot detect the type, it will keep an expression's type untouched. In such a case auto does not generate any instructions into the final binary.</p>

<pre><code>main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    s32_ptr : *s32;
    u32_ptr : *u32;

    <span class="syntax-comment">// auto cast from *u32 to *s32</span>
    s32_ptr = <span class="syntax-keyword">auto</span> u32_ptr;

    <span class="syntax-comment">// keep expession type s32</span>
    i := <span class="syntax-keyword">auto</span> 10;
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>;
</code></pre>
<h2 id="Type-Decomposition">Type Decomposition</h2>
<p>Type decomposition can be used on the composite types to get a type of any of the nested members.</p>

<pre><code>Person :: <span class="syntax-keyword">struct</span> <span class="syntax-keyword">{</span>
    name: string_view;
    age: s32;
<span class="syntax-keyword">}</span>

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    name: Person.name; <span class="syntax-comment">// string_view type</span>
    age: Person.age; <span class="syntax-comment">// s32 type</span>
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>

</code></pre>
<p>This can be extremely useful when generic structures are used in polymorphic functions and we don't know internal member types in advance.</p>

<pre><code>MyContainer :: <span class="syntax-keyword">fn</span> (TValue: type) type <span class="syntax-directive">#comptime</span> <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">return</span> <span class="syntax-keyword">struct</span> <span class="syntax-keyword">{</span>
        value: TValue;
    <span class="syntax-keyword">}</span>;
<span class="syntax-keyword">}</span>

<span class="syntax-comment">// Return type is type of TContainer member value.</span>
get_value :: <span class="syntax-keyword">fn</span> (container: *?TContainer) *TContainer.value <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">return</span> &container.value;
<span class="syntax-keyword">}</span>

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    container: MyContainer(u64);
    value :: get_value(&container);
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<p>Pointer type dereference is also possible.</p>

<pre><code>Person :: <span class="syntax-keyword">struct</span> <span class="syntax-keyword">{</span>
    name: string_view;
    age: s32;
    parent: *Person;
<span class="syntax-keyword">}</span>

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    parent_by_value: @Person.parent; <span class="syntax-comment">// Person type.</span>
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<h1 id="Functions">Functions</h1>
<p>A function is a chunk of code representing a specific piece of the program functionality introduced by <em>fn</em> keyword. A function can be called using the call operator <code>()</code>, we can provide any number of arguments into the function and get <em>return</em> value back on a call side.</p>
<p>A function is usually associated with a name and can be later called by this name followed by the call operator. To keep the syntax consistent, the function declaration looks similar to a variable declaration. The philosophy under the hood is the same, we associate some symbol (name) with some value (in this case a function literal). However, a function declaration is required to be always immutable.</p>
<p>Functions can be declared in the global or a local scope (one function can be nested in another one).</p>

<pre><code>my_global_function :: <span class="syntax-keyword">fn</span> () <span class="syntax-keyword">{</span>
    print("Hello from global function!!!\n");
<span class="syntax-keyword">}</span> <span class="syntax-comment">// Semicolon is optional here.</span>

test_fn :: <span class="syntax-keyword">fn</span> () <span class="syntax-directive">#test</span> <span class="syntax-keyword">{</span>
    my_local_function :: <span class="syntax-keyword">fn</span> () <span class="syntax-keyword">{</span>
        print("Hello from local function!!!\n");
    <span class="syntax-keyword">}</span>; <span class="syntax-comment">// Semicolon is required here.</span>

    <span class="syntax-comment">// Call functions.</span>
    my_global_function();
    my_local_function();
<span class="syntax-keyword">}</span>
</code></pre>
<p><span class="hint-note"><b>Note:</b>
Local functions cannot use any variables from the parent function. No variable capturing is supported, for now, you have to pass a context explicitly into the function as an argument.</span></p>
<h2 id="Function-Arguments">Function Arguments</h2>
<p>Function arguments are values passed into the function from the outside. Arguments, the function expects, are listed in the <em>argument list</em> in the function declaration. Each argument is declared as the name and type separated by the semicolon. Function arguments in BL are immutable (an argument itself cannot be changed in the function body). See the following example:</p>

<pre><code>Person :: <span class="syntax-keyword">struct</span> <span class="syntax-keyword">{</span>
    age: s32;
<span class="syntax-keyword">}</span>

<span class="syntax-comment">// Function taking two arguments.</span>
my_function :: <span class="syntax-keyword">fn</span> (person_1: *Person, person_2: Person, age: s32) <span class="syntax-keyword">{</span>
    age = 30; <span class="syntax-comment">// This is invalid 'age' is immutable.</span>
    person_1 = null; <span class="syntax-comment">// The same for the 'person_1' argument.</span>

    <span class="syntax-comment">// The 'person_1' here is immutable (you cannot change the pointer to something else),</span>
    <span class="syntax-comment">// however you can modify members using this pointer.</span>
    <span class="syntax-comment">// The C equivalent would be something like 'struct Person *const person_1'.</span>
    person_1.age = age;

    <span class="syntax-comment">// On the other hand the 'person_2' is passed into the function by value, so the</span>
    <span class="syntax-comment">// following expression is invalid; you cannot modify its members.</span>
    parson_2.age = age;

    <span class="syntax-comment">// You can use de-reference to modify the whole person data; you do not change</span>
    <span class="syntax-comment">// the pointer itself (it still points to the same memory, just content of this</span>
    <span class="syntax-comment">// memory is being changed).</span>
    person: Person;
    @person_1 = person;

    <span class="syntax-comment">// In case you want to modify the argument value, you should create a local copy.</span>
    local_age := age;
    local_age += 2;
<span class="syntax-keyword">}</span>

</code></pre>
<h3 id="Arguments-With-Default-Value">Arguments With Default Value</h3>
<p>In some cases we want to provide less boilerplate API and call functions only with some of the arguments from the argument list, this is possible using argument default values.</p>

<pre><code>compare :: <span class="syntax-keyword">fn</span> (a: f32, b: f32, epsilon: f32 = 0.1f) bool <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">return</span> std.abs(a - b) &lt; epsilon;
<span class="syntax-keyword">}</span>

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    compare(13.f, 12.f, 0.001f); <span class="syntax-comment">// We don't use the default value.</span>
    compare(13.f, 12.f); <span class="syntax-comment">// We use default value.</span>

    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<p>The explicit <code>f32</code> type is optional for the <code>epsilon</code> with default value since we have the value to get the type from, so the following code is also valid.</p>

<pre><code>compare :: <span class="syntax-keyword">fn</span> (a: f32, b: f32, epsilon := 0.1f) bool <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">return</span> std.abs(a - b) &lt; epsilon;
<span class="syntax-keyword">}</span>
</code></pre>
<p>One limitation here is that the arguments with default values must go very last in the argument list. Currently, there is no way how to specify namely which argument we want to call on the call side.</p>

<pre><code>compare :: <span class="syntax-keyword">fn</span> (epsilon := 0.1f, a: f32, b: f32) bool <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">return</span> std.abs(a - b) &lt; epsilon;
<span class="syntax-keyword">}</span>
</code></pre>

<pre><code>test2.bl:1:16: error(0035): All arguments with default value must be listed last in the function
                            argument list. Before arguments without default value.
&gt;  1 | compare :: fn (epsilon := 0.1f, a: f32, b: f32) bool {
     |                ^^^^^^^
   2 |     return std.abs(a - b) &lt; epsilon;
</code></pre>
<h3 id="Call-Location">Call Location</h3>
<p>One special feature very useful for debugging is <code>#call_location</code> which can be used as a default argument value. Each time the function is called, the <code>#call_location</code> is replaced by a pointer to the <code>CodeLocation</code> variable, containing information about where the function was called in the source code.</p>

<pre><code>my_assert :: <span class="syntax-keyword">fn</span> (expression: bool, location : *CodeLocation = <span class="syntax-directive">#call_location</span>) <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">if</span> !expression <span class="syntax-keyword">{</span>
        print("Assert called in '%' on line %.\n", location.file, location.line);
    <span class="syntax-keyword">}</span>
<span class="syntax-keyword">}</span>

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    my_assert(false);
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>

<pre><code>Assert called in 'C:/Develop/bl/tests/test2.bl' on line 9.
</code></pre>
<h3 id="Compile-time-Known-Arguments">Compile-time Known Arguments</h3>
<p>So far, in all examples, arguments passed to functions were processed in runtime. In some cases, we may require the argument to be compile-time known. A function having at least one compile-time known argument is called <em>mixed</em> function. We can do so simply by adding <code>#comptime</code> directive after the argument declaration.</p>

<pre><code>load_data :: <span class="syntax-keyword">fn</span> (BUFFER_SIZE: s32 <span class="syntax-directive">#comptime</span>) <span class="syntax-keyword">{</span>
    <span class="syntax-comment">// 'SIZE' is compile-time known constant here.</span>
    buffer: [BUFFER_SIZE]s32;
    <span class="syntax-comment">// ...</span>
<span class="syntax-keyword">}</span>
</code></pre>
<p>Since the <code>BUFFER_SIZE</code> is compile-time known constant, it can be used as size in an array type definition. This obviously means the <code>BUFFER_SIZE</code> argument needs to be compile-time constant when the function is called, otherwise the compiler generates an error.</p>
<p>Internally, <code>load_data</code> function does not exist until the compiler hits a call to this function; we don't know what the value of <code>BUFFER_SIZE</code> is in advance. The compiler will generate a unique implementation with <code>BUFFER_SIZE</code> argument removed from the argument list and converted into compile-time known constant value for each compiled call to this function in the code. At this point, you may see some possible disadvantages. Since the compile-time argument is removed from the argument list, the <em>mixed</em> function cannot follow <em>C call conventions</em> and cannot be <em>exported</em> or <em>external</em>. Also, instantiating a new function implementation for each call in the code can lead to a bigger executable and slow down the compiler.</p>
<p>One important thing, we can do with <em>mixed</em> functions is having also types as input arguments. See the implementation of <code>new</code> function from the <em>standard library</em>:</p>

<pre><code><span class="syntax-comment">// Allocate memory on heap for value of 'T' type.</span>
new :: <span class="syntax-keyword">fn</span> (T: type <span class="syntax-directive">#comptime</span>, preferred_allocator: *Allocator = null, loc := <span class="syntax-directive">#call_location</span>)
          (ptr: *T, err: Error) <span class="syntax-directive">#inline</span> <span class="syntax-keyword">{</span>
    mem, err :: alloc(<span class="syntax-keyword">sizeof</span>(T), <span class="syntax-keyword">alignof</span>(T), preferred_allocator, loc);
    <span class="syntax-keyword">return</span> <span class="syntax-keyword">auto</span> mem, err;
<span class="syntax-keyword">}</span>

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    number_on_heap :: new(s32);
    free(<span class="syntax-keyword">auto</span> number_on_heap);
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<p><b>Pros</b></p>
<ul>
<li>We can pass types into functions.</li>
<li>We can reference the compile-time arguments in the argument list (i.e. use them as return type).</li>
</ul>
<p><b>Cons</b></p>
<ul>
<li>Can produce larger binary and slow down the compilation process.</li>
<li>Compile-time known argument cannot be used as a default value of another argument.</li>
<li>Type-checking is very limited since we don't know <code>comptime</code> arguments in advance; the generated implementation is type-checked each time the function is called.</li>
<li>Mixed functions do not represent any stack-allocated memory (we cannot get its address).</li>
<li>Don't follow C calling conventions:<ul>
<li>Cannot be <code>extern</code>.</li>
<li>Cannot be <code>export</code>.</li>
</ul>
</li>
</ul>
<h3 id="Variable-Argument-Count">Variable Argument Count</h3>
<p>In BL, we can have a function taking 0-N values in the argument list, let's start with an example:</p>

<pre><code>sum :: <span class="syntax-keyword">fn</span> (nums: ...s32) s32 <span class="syntax-keyword">{</span>
    <span class="syntax-comment">// nums is slice of s32</span>
    result := 0;
    <span class="syntax-keyword">loop</span> i := 0; i &lt; nums.len; i += 1 <span class="syntax-keyword">{</span>
        result += nums[i];
    <span class="syntax-keyword">}</span>

    <span class="syntax-keyword">return</span> result;
<span class="syntax-keyword">}</span>

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    print("%\n", sum(10, 20, 30));
    print("%\n", sum(10, 20));
    print("%\n", sum());

    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<p>The <code>nums</code> argument type is <code>...s32</code>, that means we expect any number of  <code>s32</code> integers to be passed into the function. This is just syntax sugar for passing a pointer to an array of integers. When <code>sum</code> function is called, the compiler will implicitly generate a temporary array containing all passed arguments and then forward this array into the function. Inside the function we can use common <code>.len</code> slice member to get a count of passed integers and access each one using <code>[]</code> operator. This approach may cause some overhead compared to C version of the same feature, however, it's way more safe and ergonomic.</p>
<p>We can use <code>...Any</code> to allow values of any type to be passed into the function, or just <code>...</code> shortcut to do the same. One good example is the <code>print</code> function from the <em>standard library</em>.</p>

<pre><code>print :: <span class="syntax-keyword">fn</span> (format: string_view, args: ...) s32 <span class="syntax-keyword">{</span>
    <span class="syntax-comment">// ...</span>
<span class="syntax-keyword">}</span>
</code></pre>
<p><b>Pros</b></p>
<ul>
<li>We can pass any number of arguments we want.</li>
<li>Safe and easy to use.</li>
</ul>
<p><b>Cons</b></p>
<ul>
<li>Some overhead may be introduced by implicit conversion to an array.</li>
<li>Must be the last in the argument list.</li>
<li>Don't follow C calling conventions:<ul>
<li>Cannot be <code>extern</code>.</li>
<li>Cannot be <code>export</code>.</li>
</ul>
</li>
</ul>
<h2 id="Return-Value">Return Value</h2>
<p>Each function can eventually return some value using the <em>return</em> statement. The <em>return</em> statement returns the execution back to the caller, so the execution of the function ends in case the <em>return</em> is reached. The return value is optional and can be specified in the function declaration <em>header</em> after the argument list. There is no <em>void</em> type (like in C or C++) to say the function does not return, we simply leave the return value type empty. The following example shows the function without the return value.</p>

<pre><code>say :: <span class="syntax-keyword">fn</span> (is_hello: bool) <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">if</span> is_hello <span class="syntax-keyword">{</span>
        print("Hello!");
        <span class="syntax-keyword">return</span>; <span class="syntax-comment">// We can use 'return' without values.</span>
    <span class="syntax-keyword">}</span>
    print("Hi!");
    <span class="syntax-comment">// Return here is optional.</span>
<span class="syntax-keyword">}</span>
</code></pre>
<p>Another example shows the function returning an integer.</p>

<pre><code>add :: <span class="syntax-keyword">fn</span> (a: s32, b: s32) s32 <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">return</span> a + b; <span class="syntax-comment">// Return is mandatory.</span>
<span class="syntax-keyword">}</span>

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    result := add(1, 2);
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<p>A function may return multiple values at once like this:</p>

<pre><code>foo :: <span class="syntax-keyword">fn</span> () (s32, bool) <span class="syntax-keyword">{</span>
    <span class="syntax-comment">// We separate each value by comma.</span>
    <span class="syntax-keyword">return</span> 666, true;
<span class="syntax-keyword">}</span>

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    <span class="syntax-comment">// s32 goes into int1 and bool into boolean1</span>
    int1, boolean1 := foo();

    <span class="syntax-comment">// Not all values must be used.</span>
    <span class="syntax-comment">// s32 value goes into int2.</span>
    int2 := foo();

    <span class="syntax-comment">// We can use '_'  blank identifier to ignore some values.</span>
    _, boolean2 := foo();

    <span class="syntax-comment">// We can access each return value like it was structure.</span>
    boolean3 := foo()._0; <span class="syntax-comment">// '_0' is builtin index of first value.</span>
    boolean3 := foo()._1; <span class="syntax-comment">// '_1' is builtin index of second value.</span>

    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<p>The returned result values can be <em>unrolled</em> on the call side; we can initialize more variables with different type at once, but we have to keep the order of return values specified in the function declaration.</p>
<p>Each returned value can have a name:</p>

<pre><code>foo :: <span class="syntax-keyword">fn</span> () (number: s32, is_valid: bool) <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">return</span> 666, true;
<span class="syntax-keyword">}</span>

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    <span class="syntax-comment">// s32 goes into int1 and bool into boolean1</span>
    int1, boolean1 := foo();

    <span class="syntax-comment">// We can access each return value like it was structure.</span>
    boolean2 := foo().is_valid;

    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<p>Internally the compiler creates an implicit structure and returns all values as a single one; that's why the call-side use of the call results is called <em>unrolling</em>. In case we return a lot of values, the compiler may introduce some optimizations to avoid returning large data from a function.</p>
<p>This feature comes in handy in cases where we want to include also a possible <em>error</em> as the result. One common approach to addressing an error handling goes like this:</p>

<pre><code><span class="syntax-directive">#import</span> "std/fs"

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
	<span class="syntax-keyword">using</span> std;

	stream, open_err :: open_file(<span class="syntax-directive">#file</span>);
	<span class="syntax-keyword">defer</span> close_file(&stream);
	<span class="syntax-keyword">if</span> open_err <span class="syntax-keyword">{</span> 
		print_err(open_err); 
		<span class="syntax-keyword">return</span> 1; 
	<span class="syntax-keyword">}</span>

	str := str_new();
	<span class="syntax-keyword">defer</span> str_delete(&str);
	read_bytes, read_err :: read_string(&stream, &str);
	<span class="syntax-keyword">if</span> read_err <span class="syntax-keyword">{</span> 
		print_err(read_err);
		<span class="syntax-keyword">return</span> 2;
	<span class="syntax-keyword">}</span>
	print("read % bytes\n", read_bytes);
	print("%\n", str);
	<span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>

</code></pre>
<p>The <code>open_file</code> function in this case returns the file stream and possible error in case the file cannot be opened.</p>
<h2 id="Anonymous-Functions-And-Callbacks">Anonymous Functions And Callbacks</h2>
<p>Sometimes a function may be used only once as an <em>callback</em> function passed into some other function. In such a case we can simplify the declaration and keep the function unnamed. One good example is the <code>sort</code> function declared like this:</p>

<pre><code>sort :: <span class="syntax-keyword">fn</span> (list: []s32, cmp: *<span class="syntax-keyword">fn</span>(a: *s32, b: *s32) bool)  <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">loop</span> i := 0; i &lt; list.len; i += 1 <span class="syntax-keyword">{</span>
        <span class="syntax-keyword">loop</span> j := i+1; j &lt; list.len; j += 1 <span class="syntax-keyword">{</span>
            <span class="syntax-keyword">if</span> cmp(&list[i], &list[j]) <span class="syntax-keyword">{</span>
                swap(&list[i], &list[j]);
            <span class="syntax-keyword">}</span>
        <span class="syntax-keyword">}</span>
    <span class="syntax-keyword">}</span>
<span class="syntax-keyword">}</span>
</code></pre>
<p>We pass a <code>list</code> slice of numbers and we want it to be sorted with use of some custom <code>cmp</code> comparator. The comparator in this case is a pointer to any function taking <em>*s32</em>, <em>*s32</em> and returning <em>bool</em>. The easiest way to provide such a function is to create an anonymous callback and pass its address.</p>

<pre><code>main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    numbers: []s32;
    alloc_slice(&numbers, 10);
    <span class="syntax-keyword">defer</span> free_slice(&numbers);
    <span class="syntax-keyword">loop</span> i := 0; i &lt; numbers.len; i += 1 <span class="syntax-keyword">{</span> numbers[i] = i; <span class="syntax-keyword">}</span>
    print("%\n", numbers);

    <span class="syntax-comment">// Here we pass pointer to anonymous function into the 'sort'.</span>
    sort(numbers, &<span class="syntax-keyword">fn</span> (a: *s32, b: *s32) bool <span class="syntax-keyword">{</span>
        <span class="syntax-keyword">return</span> @a &lt; @b;
    <span class="syntax-keyword">}</span>);

    print("%\n", numbers);
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<h2 id="Function-Overloading">Function Overloading</h2>
<p>More functions can be associated with one name with explicit function overloading groups. A call to a group of functions is replaced with a proper function call during compilation, based on provided arguments.</p>

<pre><code>group :: <span class="syntax-keyword">fn</span> <span class="syntax-keyword">{</span> s32_add; f32_add; <span class="syntax-keyword">}</span>

s32_add :: <span class="syntax-keyword">fn</span> (a: s32, b: s32) s32 <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">return</span> a + b;
<span class="syntax-keyword">}</span>

f32_add :: <span class="syntax-keyword">fn</span> (a: f32, b: f32) f32 <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">return</span> a + b;
<span class="syntax-keyword">}</span>

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    i :: group(10, 20);
    j :: group(0.2f, 13.534f);
    print("i = %\n", i);
    print("j = %\n", j);
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<p><span class="hint-note"><b>Note:</b>
There is no additional runtime overhead caused by function overloading.</span></p>
<p><span class="hint-note"><b>Note:</b>
Ordering of functions inside the group is arbitrary.</span></p>
<p>Functions can be declared directly inside the overload group:</p>

<pre><code>group :: <span class="syntax-keyword">fn</span> <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">fn</span> (a: s32, b: s32) s32 <span class="syntax-keyword">{</span>
        <span class="syntax-keyword">return</span> a + b;
    <span class="syntax-keyword">}</span>;

    <span class="syntax-keyword">fn</span> (a: f32, b: f32) f32 <span class="syntax-keyword">{</span>
        <span class="syntax-keyword">return</span> a + b;
    <span class="syntax-keyword">}</span>;
<span class="syntax-keyword">}</span>
</code></pre>
<h3 id="Overload-Resolution">Overload Resolution</h3>
<p>When a function group is called the function overload resolution takes into account multiple options to sort all possible call candidates by priority. The candidate function with the highest priority is used. In case there are multiple functions with the same priority found in the group, the compiler complains about ambiguous a function. In case there is no call candidate, the first one is used. This usually leads to an error later if the function interface is not compatible.</p>
<p><b>The overload resolution is based on:</b></p>
<ul>
<li>Argument count.</li>
<li>Argument types.</li>
<li>Type casting.</li>
<li>Conversion to slice.</li>
<li>Conversion to any.</li>
</ul>
<p><span class="hint-note"><b>Note:</b>
The return type does not affect choosing the best call candidate.</span></p>
<p><b>Resolving the best call candidate is done in two passes:</b></p>
<ul>
<li><p>Pick all possible candidates based on call-side argument count when:</p>
<ul>
<li>The argument count is exactly matching the count of arguments required by the function interface.</li>
<li>All arguments, up to the first defaulted or variable count argument in the function interface, are provided.</li>
</ul>
</li>
<li><p>Iterate over previously picked functions and rank them by comparing call-side arguments with each function's interface arguments one by one:</p>
<ul>
<li>The type is exactly the same. (Rank +3)</li>
<li>Can be implicitly casted. (Rank +2)</li>
<li>Can be implicitly converted. (Rank +2)</li>
<li>Can be implicitly converted to <code>Any</code>. (Rank +1)</li>
<li>Can be added to the variable count argument array. (Rank +1)</li>
</ul>
</li>
<li><p>Use the function with the highest rank.</p>
</li>
</ul>

<pre><code>a :: <span class="syntax-keyword">fn</span> (_: []u8)                <span class="syntax-keyword">{</span><span class="syntax-keyword">}</span>
b :: <span class="syntax-keyword">fn</span> (_: string)              <span class="syntax-keyword">{</span><span class="syntax-keyword">}</span>
c :: <span class="syntax-keyword">fn</span> (_: Any)                 <span class="syntax-keyword">{</span><span class="syntax-keyword">}</span>
d :: <span class="syntax-keyword">fn</span> (_: s32, _: bool = true) <span class="syntax-keyword">{</span><span class="syntax-keyword">}</span>

group :: <span class="syntax-keyword">fn</span> <span class="syntax-keyword">{</span> a; b; c; d; <span class="syntax-keyword">}</span>

<span class="syntax-comment">// a: rank = 3 &lt;- used</span>
<span class="syntax-comment">// b: rank = 0</span>
<span class="syntax-comment">// c: rank = 1</span>
<span class="syntax-comment">// d: rank = 0</span>
group("hello");

<span class="syntax-comment">// a: rank = 2 (can be implicitly converted to []u8)</span>
<span class="syntax-comment">// b: rank = 3 &lt;- used</span>
<span class="syntax-comment">// c: rank = 1</span>
<span class="syntax-comment">// d: rank = 0</span>
str: string;
group(str);

<span class="syntax-comment">// a: rank = 0</span>
<span class="syntax-comment">// b: rank = 0</span>
<span class="syntax-comment">// c: rank = 1</span>
<span class="syntax-comment">// d: rank = 3 &lt;- used</span>
group(10);

<span class="syntax-comment">// a: rank = 0</span>
<span class="syntax-comment">// b: rank = 0</span>
<span class="syntax-comment">// c: rank = 0</span>
<span class="syntax-comment">// d: rank = 6 &lt;- used</span>
group(10, false);

<span class="syntax-comment">// a: rank = 0</span>
<span class="syntax-comment">// b: rank = 0</span>
<span class="syntax-comment">// c: rank = 1</span>
<span class="syntax-comment">// d: rank = 2 &lt;- used (implicitly casted s8 to s32)</span>
i: s8;
group(10);
</code></pre>
<h2 id="Polymorphic-Functions">Polymorphic Functions</h2>
<p>Polymorphic function (aka templated function or generic function) is a well-known concept in many programming languages. It's a sort of meta-programming method reducing a boilerplate code. The basic idea is the automatic generation of functions doing the same operation but using different types. Instead of rewriting the function for every type needed, we just specify it as a "recipe" for later generations.</p>
<p>Consider the following function doing an addition of two values, when we want to use the function with multiple different types, we must explicitly rewrite the same function for every type needed:</p>

<pre><code>add_s32 :: <span class="syntax-keyword">fn</span> (a: s32, b: s32) s32 <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">return</span> a + b;
<span class="syntax-keyword">}</span>

<span class="syntax-comment">// Same for floats.</span>
add_f32 :: <span class="syntax-keyword">fn</span> (a: f32, b: f32) f32 <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">return</span> a + b;
<span class="syntax-keyword">}</span>
</code></pre>
<p>In this case, we can use polymorph instead:</p>

<pre><code>add :: <span class="syntax-keyword">fn</span> (a: ?T, b: T) T <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">return</span> a + b;
<span class="syntax-keyword">}</span>
</code></pre>
<p>Value of <code>T</code> represents any type, in this case, chosen based on usage of the function. The question
mark before <code>T</code> says the first <code>T</code> is the master polymorph type. The compiler tries to replace all
master types with the type of argument on the call side and register the new type alias <code>T</code> in the
function scope.</p>
<p>Example of usage:</p>

<pre><code>main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    result_1 : s32 = add(10, 20);
    result_2 : f32 = add(1.4f, 42.5f);

    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<p>Notice that we call the same function, first with integers and second with floats. The type of <code>T</code>
is based on the first argument type (because the master type is defined as the type of the first
argument).  The second argument type, in this case, must be the same type as the master
because <code>b</code> use, as its type, alias <code>T</code>. The same alias is used also as a return type.</p>
<p>So two functions are generated internally:</p>

<pre><code>.add.1 :: <span class="syntax-keyword">fn</span> (a: s32, b: s32) s32 <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">return</span> a + b;
<span class="syntax-keyword">}</span>

.add.2 :: <span class="syntax-keyword">fn</span> (a: f32, b: f32) f32 <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">return</span> a + b;
<span class="syntax-keyword">}</span>
</code></pre>
<p><span class="hint-note"><b>Note:</b>
Content of polymorphic function is semantically analyzed only when the function is used.</span></p>
<h3 id="Nested-Master-Type">Nested Master Type</h3>
<p>Polymorph master type replacement can be used also as a nested member in more complex types.</p>

<pre><code>sum :: <span class="syntax-keyword">fn</span> (slice: []?T) T <span class="syntax-keyword">{</span>
    result: T; <span class="syntax-comment">// We can use T inside the function as well</span>
    <span class="syntax-keyword">loop</span> i := 0; i &lt; slice.len; i += 1 <span class="syntax-keyword">{</span>
        result += slice[i];
    <span class="syntax-keyword">}</span>
    <span class="syntax-keyword">return</span> result;
<span class="syntax-keyword">}</span>

<span class="syntax-comment">// Sum function accepts any slice as an input and any array is implicitly convertible</span>
<span class="syntax-comment">// to slice.</span>

<span class="syntax-comment">// Use the function with static array</span>
arr_static := [3]s32.<span class="syntax-keyword">{</span>10, 20, 30<span class="syntax-keyword">}</span>;
sum(arr_static); <span class="syntax-comment">// T = s32</span>

<span class="syntax-comment">// Use the function with dynamic array</span>
arr_dynamic: [..]f32;
<span class="syntax-keyword">defer</span> array_terminate(&arr_dynamic);
array_push(&arr_dynamic, 10.f);
array_push(&arr_dynamic, 20.f);
array_push(&arr_dynamic, 30.f);

sum(arr_dynamic); <span class="syntax-comment">// T = f32</span>
</code></pre>
<h3 id="Multiple-Polymorph-Masters">Multiple Polymorph Masters</h3>
<p>More than one polymorphic master can be declared inside the function argument list:</p>

<pre><code>table_insert :: <span class="syntax-keyword">fn</span> (table: *Table, key: ?TKey, value: ?TValue) <span class="syntax-keyword">{</span>
    <span class="syntax-comment">// ...</span>
<span class="syntax-keyword">}</span>
</code></pre>
<h3 id="Specify-Implementation-For-Type">Specify Implementation For Type</h3>
<p>In some cases we want to specify explicitly what implementation should be used for some specific type, i.e. in a function doing a comparison of two values, we can provide specific handling for string:</p>

<pre><code>is_equal :: <span class="syntax-keyword">fn</span> <span class="syntax-keyword">{</span> <span class="syntax-comment">// function group</span>
    <span class="syntax-comment">// Implementation used for strings only.</span>
    <span class="syntax-keyword">fn</span> (a: string_view, b: string_view) bool <span class="syntax-keyword">{</span>
        <span class="syntax-keyword">return</span> std.str_compare(a, b);
    <span class="syntax-keyword">}</span>;

    <span class="syntax-comment">// Implementation used for all other types.</span>
    <span class="syntax-keyword">fn</span> (a: ?T, b: T) bool <span class="syntax-keyword">{</span>
        <span class="syntax-keyword">return</span> a == b;
    <span class="syntax-keyword">}</span>;
<span class="syntax-keyword">}</span>
</code></pre>
<p><b>Limitations:</b></p>
<ul>
<li>Polymorph master type cannot have a default value.</li>
<li>Type-checking is very limited since we don't know types of the arguments in advance.</li>
<li>Polymorph functions does not represent any stack allocated memory (we cannot get its address).</li>
<li>Don't follow C calling conventions:<ul>
<li>Cannot be <code>extern</code>.</li>
<li>Cannot be <code>export</code>.</li>
</ul>
</li>
</ul>
<h2 id="Function-Directives">Function Directives</h2>
<p>The function directives can be specified after the function return type declaration:</p>

<pre><code>get_age :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-directive">#inline</span> <span class="syntax-keyword">{</span><span class="syntax-keyword">}</span>
</code></pre>
<h3 id="inline/noinline">inline/noinline</h3>
<p>Tells the compiler whether it should try to inline the called function. Inlining may not be possible in some cases, however in general it can improve the runtime speed. Inline functions should not be too complex.</p>
<h3 id="extern">extern</h3>
<p>An extern function is a function implemented in a foreign library linked to the program. Such a function defines only an interface but cannot be implemented (does not have a body). The <code>#extern</code> directive can be optionally followed by the linkage name of the external symbol. If the linkage name is not specified, the function name is used instead. Having external functions allows the use of any existing C ABI compatible library.</p>
<p>The extern functions must strictly follow <em>C call conventions</em>.</p>

<pre><code>my_malloc :: <span class="syntax-keyword">fn</span> (size: size_t) void_ptr <span class="syntax-directive">#extern</span> "malloc";
free :: <span class="syntax-keyword">fn</span> (ptr: void_ptr) <span class="syntax-directive">#extern</span>;
</code></pre>
<h3 id="export">export</h3>
<p>Functions with an <code>export</code> directive are exported from the binary when a program is compiled as a shared library (with <code>-shared</code> flag). So the function may be called from the other libraries or executables after successful linking. The <code>#export</code> directive can be optionally followed by the linkage name of the exported symbol. If the linkage name is not specified, the function name is used instead.</p>
<p>The export functions must strictly follow <em>C call conventions</em>. That means, the function cannot be polymorphic (generated in compile time).</p>

<pre><code>my_add :: <span class="syntax-keyword">fn</span> (a: s32, b: s32) s32 <span class="syntax-directive">#export</span> "add" <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">return</span> a + b;
<span class="syntax-keyword">}</span>
</code></pre>
<h3 id="comptime">comptime</h3>
<p>Every call to such a function is going to be evaluated in compile-time and replaced by constant eventually.</p>

<pre><code>hash_string :: <span class="syntax-keyword">fn</span> (s: string_view) u32 <span class="syntax-directive">#comptime</span> <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">return</span> std.str_hash(s);
<span class="syntax-keyword">}</span>
</code></pre>
<p>The <code>hash</code> function can be later called the same way as any other regular function, but the call itself is replaced by the constant result value in the final binary.</p>

<pre><code>main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    <span class="syntax-comment">// 'hash_string' is executed in compile-time and 'hash' value is initialized</span>
    <span class="syntax-comment">// later in runtime with pre-calculated constant.</span>
    <span class="syntax-comment">// Called function does not exist in the final binary.</span>
    hash := hash_string("Hello!");
    print("%\n", hash);
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<p>So the comptime function has no runtime overhead.</p>
<p><b>Pros:</b></p>
<ul>
<li>Since all comptime functions are evaluated in compile-time, there is no runtime overhead.</li>
<li>The result of the comptime function call is also compile time known.</li>
<li>Compile time function can return types and can be used in type definitions.</li>
</ul>
<p><b>Cons:</b></p>
<ul>
<li>Every argument passed, must be known in compile-time.</li>
<li>Returning pointers from comptime functions is not a good idea.</li>
<li>An internal execution stack for compile-time evaluated functions is limited to 128kB; compile time execution of too complicated stuff may cause stack overflows.</li>
</ul>
<h3 id="enable_if">enable_if</h3>
<p>The <code>#enable_if</code> directive can be used to conditionally specify whether a certain function should be included or excluded from a final binary. This might be used for debug-only functions like debug logs, profiling code etc.</p>
<p>Following code is supposed to measure the runtime of the main function only in debug mode (when <code>bool</code> expression after <code>#enable_if</code> directive evaluates <code>true</code> in compile-time). Calls to these functions are completely removed in release mode as well as the implementation.</p>

<pre><code>main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    measure_runtime_in_debug_only();
    <span class="syntax-keyword">defer</span> measure_runtime_in_debug_only_end();

    <span class="syntax-comment">// do something here</span>

    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>

measure_runtime_in_debug_only :: <span class="syntax-keyword">fn</span> () <span class="syntax-directive">#enable_if</span> IS_DEBUG <span class="syntax-keyword">{</span>
    <span class="syntax-comment">// ...</span>
<span class="syntax-keyword">}</span>

measure_runtime_in_debug_only_end :: <span class="syntax-keyword">fn</span> () <span class="syntax-directive">#enable_if</span> IS_DEBUG <span class="syntax-keyword">{</span>
    <span class="syntax-comment">// ...</span>
<span class="syntax-keyword">}</span>
</code></pre>
<p><b>Notes:</b></p>
<ul>
<li>The function and all its calls are fully analyzed even if the function is disabled.</li>
<li>The conditional function might return values, but in case the function is disabled the returned value on the call side is implicitly changed to <code>void</code> type. Such behavior is intentionally chosen to prevent possible issues with uninitialized variables.</li>
</ul>
<h1 id="Comments">Comments</h1>
<p>Simple documentation can be written directly into the code the same way as in other programming languages, simply by adding comments. The BL comments use the same syntax as in C. You can write a single-line comment or multi-line comment as needed. You can also write documentation directly into the code and let the compiler generate <em>markdown</em> files for you.</p>
<h2 id="Single-line-Comments">Single-line Comments</h2>
<p>You can use single-line comments introduced by <code>//</code> anywhere in the code. Everything up to the end of the line is considered a comment.</p>

<pre><code><span class="syntax-comment">// This is the main function.</span>
main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">return</span> 0; <span class="syntax-comment">// We return 0 here.</span>
<span class="syntax-keyword">}</span>
</code></pre>
<h2 id="Multi-line-Comments">Multi-line Comments</h2>
<p>Multi-line comments are also supported:</p>

<pre><code><span class="syntax-comment">/*</span>
    The main function.

    This is the entry point of our program.
*/
main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-comment">/* the signed number is returned from the main */</span>/ <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<h2 id="Documentation-Comments">Documentation Comments</h2>
<p>Since the BL compiler supports documentation generation out of the box, you can use two types of comments which are supposed to be a part of a generated document.</p>
<ul>
<li><code>//!</code> Documentation of the file.</li>
<li><code>///</code> Documentation of the following symbol.</li>
</ul>
<p>See also <a href="/book/documentation">Self-Documentation</a>.</p>
<h1 id="Literals">Literals</h1>
<h2 id="Simple-Literals">Simple Literals</h2>

<pre><code>b :: true;         <span class="syntax-comment">// bool true literal</span>
b :: false;        <span class="syntax-comment">// bool false literal</span>
ptr : *s32 = null; <span class="syntax-comment">// *s32 null pointer literal</span>
</code></pre>
<h2 id="Integer-Literals">Integer Literals</h2>
<p>Biscuit language provides constant integer literals written in various formats showed in the example bellow. Integer literals have a volatile type, when the desired type is not specified compiler will choose the best type to hold the value. Numbers requiring less space than 32 bits will be implicitly set to <em>s32</em>, numbers requiring more space than 31 bits and less space than 64 bits will be set to <em>s64</em> and numbers requiring 64 bits will be set to <em>u64</em> type. Bigger numbers are not supported and the compiler will complain. When we specify type explicitly (ex.: <code>foo : u8 : 10;</code>), an integer literal will inherit the type of the variable (same for function calls where the type is known).</p>

<pre><code>i     :: 10;      <span class="syntax-comment">// s32 literal</span>
i_u8  : u8 : 10;  <span class="syntax-comment">// u8 literal</span>
i_hex :: 0x10;    <span class="syntax-comment">// s32 literal</span>
i_bin :: 0b1011;  <span class="syntax-comment">// s32 literal</span>
f     :: 13.43f;  <span class="syntax-comment">// f32 literal</span>
d     :: 13.43;   <span class="syntax-comment">// f64 literal</span>
char  :: 'i';     <span class="syntax-comment">// u8 character literal</span>
</code></pre>
<h2 id="String-Literals">String Literals</h2>
<p>The string literal is represented as a constant <em>utf8</em> array of bytes stored in the builtin value of <em>string_view</em> type.  The content of the array is allocated on the <em>stack</em> and cannot be changed in runtime.</p>

<pre><code>the_name :: "Martin Dorazil";
</code></pre>
<p>A longer string value may be split into multiple lines, the result value is evaluated as a single string.</p>

<pre><code>text ::
    "This "
    "is "
    "long "
    "text on multiple "
    "lines.";
</code></pre>
<h1 id="Operators">Operators</h1>
<h2 id="Binary-Operators">Binary Operators</h2>

<pre><code>+      Addition.
-      Subtraction.
*      Multiplication.
/      Division.
%      Remainder division.
+=     Addition and assign.
-=     Subtraction and assign.
*=     Multiplication and assign.
/=     Division and assign.
%=     Remainder division and assign.
&lt;      Less.
&gt;      Greater.
&lt;=     Less or equals.
&gt;=     Greater or equals.
==     Equals.
&&     Logical AND.
||     Logical OR.
&      Bit AND.
|      Bit OR.
^      Bit XOR.
&=     Bit AND and assign.
|=     Bit OR and assign.
^=     Bit XOR and assign.
&lt;&lt;     Bitshift left.
&gt;&gt;     Bitshift right.
</code></pre>
<h2 id="Unary-Operators">Unary Operators</h2>

<pre><code>\+     Positive value.
\-     Negative value.
@      Pointer dereference.
&      Address of.
!      Logical not.
~      Bit flip.
</code></pre>
<h1 id="Flow-Control">Flow Control</h1>
<p>In this chapter, we'll focus on language features focused on conditional code execution and repetitive execution of some code blocks. The BL implements all well-known concepts of flow control and a little bit more. The most common way to let you execute a part of a code only in case some runtime condition is <em>true</em> is the <em>if</em> statement.</p>
<h2 id="If-Else">If Else</h2>
<p>The <em>if-else</em>, as in many other languages, splits the code into two branches and executes one or the other based on some runtime condition.  The first branch is executed only if the condition is <em>true</em>. The expression after <em>if</em> statement is required to be a <em>bool</em> or at least convertible to <em>bool</em> type. The implicit conversion is applied only to the pointer values where the <em>null</em> pointer converts to <em>false</em> implicitly.</p>

<pre><code>main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    do_it := true;

    <span class="syntax-keyword">if</span> do_it <span class="syntax-keyword">{</span>
        print("It's done!\n");
    <span class="syntax-keyword">}</span>
<span class="syntax-keyword">}</span>

</code></pre>
<p>Notice that we don't need additional brackets around the condition like in C-like languages.  We can optionally introduce the <em>else</em> block executed if the <em>if</em> condition is <em>false</em>.</p>

<pre><code>main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    do_it := false;

    <span class="syntax-keyword">if</span> do_it <span class="syntax-keyword">{</span>
        print("It's done!\n");
    <span class="syntax-keyword">}</span> <span class="syntax-keyword">else</span> <span class="syntax-keyword">{</span>
        print("It's not done!\n");
    <span class="syntax-keyword">}</span>

    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>

</code></pre>
<p>In some cases we might need only simple single line piece of code executed conditionally. To make it possible, since brackets around the if statement expression are not required, we've introduced <code>then</code> keyword. All following examples are valid.</p>

<pre><code>main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    expr := true;

    <span class="syntax-keyword">if</span> expr <span class="syntax-keyword">{</span> print("This is true branch!\n"); <span class="syntax-keyword">}</span>
    <span class="syntax-keyword">if</span> !expr <span class="syntax-keyword">{</span> print("This is true branch!\n"); <span class="syntax-keyword">}</span> <span class="syntax-keyword">else</span> <span class="syntax-keyword">{</span> print("This is false branch!\n"); <span class="syntax-keyword">}</span>

    <span class="syntax-comment">// Then is optional here.</span>
    <span class="syntax-keyword">if</span> expr <span class="syntax-keyword">then</span> <span class="syntax-keyword">{</span> print("This is true branch!\n"); <span class="syntax-keyword">}</span>
    <span class="syntax-keyword">if</span> !expr <span class="syntax-keyword">then</span> <span class="syntax-keyword">{</span> print("This is true branch!\n"); <span class="syntax-keyword">}</span> <span class="syntax-keyword">else</span> <span class="syntax-keyword">{</span> print("This is false branch!\n"); <span class="syntax-keyword">}</span>

    <span class="syntax-comment">// Then is required here. We can have only one statement/expression for each branch.</span>
    <span class="syntax-keyword">if</span> expr <span class="syntax-keyword">then</span> print("This is true branch!\n");
    <span class="syntax-keyword">if</span> !expr <span class="syntax-keyword">then</span> print("This is true branch!\n") <span class="syntax-keyword">else</span> print("This is false branch!\n");

    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<p>We can also create the whole conditional chain:</p>

<pre><code>Color :: <span class="syntax-keyword">enum</span> <span class="syntax-keyword">{</span>
    RED;
    GREEN;
    BLUE;
<span class="syntax-keyword">}</span>

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    color := Color.GREEN;

    <span class="syntax-keyword">if</span> color == Color.RED <span class="syntax-keyword">{</span>
        print("It's red!\n");
    <span class="syntax-keyword">}</span> <span class="syntax-keyword">else</span> <span class="syntax-keyword">if</span> color == Color.GREEN <span class="syntax-keyword">{</span>
        print("It's green!\n");
    <span class="syntax-keyword">}</span> <span class="syntax-keyword">else</span> <span class="syntax-keyword">if</span> color == Color.BLUE <span class="syntax-keyword">{</span>
        print("It's blue!\n");
    <span class="syntax-keyword">}</span> <span class="syntax-keyword">else</span> <span class="syntax-keyword">{</span>
        print("It's something <span class="syntax-keyword">else</span>!\n");
    <span class="syntax-keyword">}</span>

    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<p>However, in such a situation it's better to use the <em>switch</em> statement.</p>
<h3 id="Ternary-If-Operator">Ternary If Operator</h3>
<p>Multiline conditional can be in some cases condensed to a single line expression. We can use ternary <code>if</code> expression for this. Unlike in C languge, there is no special operator for such expression in BL. We can just use the same syntax we already have using <code>if then</code> pattern. In case the <code>if</code> statement is used as an expression, the <code>else</code> branch is mandatory. We also cannot use block branches.</p>

<pre><code>main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    value := 50;

    number: s32;
    <span class="syntax-comment">// Conditional using standard if statement.</span>
    <span class="syntax-keyword">if</span> value &gt; 0 <span class="syntax-keyword">{</span>
        number = 10;
    <span class="syntax-keyword">}</span> <span class="syntax-keyword">else</span> <span class="syntax-keyword">{</span>
        number = 20;
    <span class="syntax-keyword">}</span>

    <span class="syntax-comment">// Conditional using inline if statement.</span>
    <span class="syntax-keyword">if</span> value &gt; 0 <span class="syntax-keyword">then</span> number = 10 <span class="syntax-keyword">else</span> number = 20;

    <span class="syntax-comment">// Direct conditional initialization using ternary if expression.</span>
    number = <span class="syntax-keyword">if</span> value &gt; 0 <span class="syntax-keyword">then</span> 10 <span class="syntax-keyword">else</span> 20;

    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<h2 id="Switch">Switch</h2>
<p>A <em>switch</em> can compare one numeric value against multiple values and switch execution flow to matching case. The <code>default</code> case can be used for all other values we don't explicitly handle. While the expression after <em>switch</em> keyword is supposed to be a runtime value, the <em>case</em> values must be known in compile-time. Currently, the <em>switch</em> can be used only with <em>integer</em> types.</p>

<pre><code>Color :: <span class="syntax-keyword">enum</span> <span class="syntax-keyword">{</span>
    RED;
    GREEN;
    BLUE;
<span class="syntax-keyword">}</span>

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    color := Color.BLUE;
    <span class="syntax-keyword">switch</span> color <span class="syntax-keyword">{</span>
        Color.RED   <span class="syntax-keyword">{</span> print("It's red!\n");   <span class="syntax-keyword">}</span>
        Color.GREEN <span class="syntax-keyword">{</span> print("It's green!\n"); <span class="syntax-keyword">}</span>
        Color.BLUE  <span class="syntax-keyword">{</span> print("It's blue!\n");  <span class="syntax-keyword">}</span>
    <span class="syntax-keyword">}</span>

    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<p>It's also possible to reuse one execution block for multiple cases, just list all case values separated by comma followed by the execution block.</p>

<pre><code><span class="syntax-keyword">switch</span> color <span class="syntax-keyword">{</span>
    Color.RED,
    Color.GREEN <span class="syntax-keyword">{</span> print("It's red or green!\n"); <span class="syntax-keyword">}</span>
    Color.BLUE  <span class="syntax-keyword">{</span> print("It's  blue!\n");  <span class="syntax-keyword">}</span>
<span class="syntax-keyword">}</span>
</code></pre>
<p>In case the switch is used with <em>enum</em> values, the compiler will automatically check for you if all possible cases are covered.</p>

<pre><code><span class="syntax-keyword">switch</span> color <span class="syntax-keyword">{</span>
    Color.GREEN <span class="syntax-keyword">{</span> print("It's red or green!\n"); <span class="syntax-keyword">}</span>
    Color.BLUE  <span class="syntax-keyword">{</span> print("It's  blue!\n");  <span class="syntax-keyword">}</span>
<span class="syntax-keyword">}</span>
</code></pre>

<pre><code>test2.bl:9:5: warning: Switch does not handle all possible enumerator values.
   8 |     color := Color.BLUE;
&gt;  9 |     switch color {
     |     ^^^^^^
  10 |         Color.GREEN { print("It's red or green!\n"); }

Missing case for: RED
</code></pre>
<p>If you don't want to handle all cases explicitly, you can introduce a <em>default</em> case:</p>

<pre><code><span class="syntax-keyword">switch</span> color <span class="syntax-keyword">{</span>
    Color.GREEN <span class="syntax-keyword">{</span> print("It's red or green!\n"); <span class="syntax-keyword">}</span>
    Color.BLUE  <span class="syntax-keyword">{</span> print("It's  blue!\n");  <span class="syntax-keyword">}</span>
    <span class="syntax-keyword">default</span> <span class="syntax-keyword">{</span> print("It's some other color."); <span class="syntax-keyword">}</span>
<span class="syntax-keyword">}</span>
</code></pre>
<p>In the previous example we print a message for the default case, but we can use just an empty statement here:</p>

<pre><code><span class="syntax-keyword">switch</span> color <span class="syntax-keyword">{</span>
    Color.GREEN <span class="syntax-keyword">{</span> print("It's red or green!\n"); <span class="syntax-keyword">}</span>
    Color.BLUE  <span class="syntax-keyword">{</span> print("It's  blue!\n");  <span class="syntax-keyword">}</span>
    <span class="syntax-keyword">default</span>;
<span class="syntax-keyword">}</span>
</code></pre>
<h2 id="Loop">Loop</h2>
<p>Another common way how to manage program control flow is looping. This is a well-known concept available in a lot of languages. We simply run some part of code N-times where N is based on some condition. In BL there is only a single <em>loop</em> keyword for loops followed by an optional condition. We can use <em>break</em> and <em>continue</em> statements inside loops. The <em>break</em> statement will simply interrupt looping and skip out of the <em>loop</em> body. The <em>continue</em> statement will immediately jump to the next loop iteration.</p>

<pre><code>main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    count :: 10;
    i := 0;

    <span class="syntax-comment">// The loop without conditions will run infinitely until return or break is hit.</span>
    <span class="syntax-keyword">loop</span> <span class="syntax-keyword">{</span>
        i += 1;
        <span class="syntax-keyword">if</span> i == count <span class="syntax-keyword">{</span>
            <span class="syntax-comment">// Jump out of the loop.</span>
            <span class="syntax-keyword">break</span>;
        <span class="syntax-keyword">}</span>
    <span class="syntax-keyword">}</span>

    <span class="syntax-comment">// Iterate until the 'i' is less than 'count'.</span>
    i = 0;
    <span class="syntax-keyword">loop</span> i &lt; count <span class="syntax-keyword">{</span>
        i += 1;
    <span class="syntax-keyword">}</span>

    <span class="syntax-comment">// Iterate until the 'j' is less than 'count'. This is the same concept</span>
    <span class="syntax-comment">// as the previous one, except we declare the iterator directly in the</span>
    <span class="syntax-comment">// loop.</span>
    <span class="syntax-keyword">loop</span> j := 0; j &lt; count; j += 1 <span class="syntax-keyword">{</span>
        <span class="syntax-comment">// do something amazing here</span>
    <span class="syntax-keyword">}</span>

    <span class="syntax-keyword">loop</span> j := 0; j &lt; count; j += 1 <span class="syntax-keyword">{</span>
        <span class="syntax-comment">// We can use 'continue' to skip printing when j is 2.</span>
        <span class="syntax-keyword">if</span> j == 2 <span class="syntax-keyword">{</span> <span class="syntax-keyword">continue</span>; <span class="syntax-keyword">}</span>
        print("j = %\n", j);
    <span class="syntax-keyword">}</span>

    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<h2 id="Defer">Defer</h2>
<p>One, not so common concept is a <em>defer</em> statement. The <em>defer</em> statement can be used for the "deferring" execution of some expressions. All deferred expressions will be executed at the end of the current scope in <b>reverse</b> order. This is usually useful for some cleanup (i.e. closing a file or freeing memory). When the scope is terminated by return all previous defers up the scope tree will be called after evaluation of return value. See the following example:</p>

<pre><code>main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">defer</span> print("1\n");

    <span class="syntax-keyword">{</span>
        <span class="syntax-comment">// Lexical scope introduced.</span>
        <span class="syntax-keyword">defer</span> print("2 ");
        <span class="syntax-keyword">defer</span> print("3 ");
        <span class="syntax-keyword">defer</span> print("4 ");
    <span class="syntax-keyword">}</span> <span class="syntax-comment">// defer 4, 3, 2</span>

    other_function();

    <span class="syntax-keyword">defer</span> print("5 ");
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span> <span class="syntax-comment">// defer 5, 1</span>

other_function :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">defer</span> print("6 ");
    <span class="syntax-keyword">defer</span> print("7 ");

    <span class="syntax-keyword">if</span> true <span class="syntax-keyword">{</span>
        <span class="syntax-keyword">defer</span> print("8 ");
        <span class="syntax-keyword">return</span> 1;
    <span class="syntax-keyword">}</span> <span class="syntax-comment">// defer 8, 7, 6</span>

    <span class="syntax-comment">// This part is newer reached, compiler will complain.</span>
    <span class="syntax-keyword">defer</span> print("9 ");
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<p>The output:</p>

<pre><code>4 3 2 8 7 6 5 1
</code></pre>
<p>Another good example is the following:</p>

<pre><code><span class="syntax-directive">#import</span> "std/fs"

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
	<span class="syntax-keyword">using</span> std;

	stream, open_err :: open_file(<span class="syntax-directive">#file</span>);
	<span class="syntax-keyword">defer</span> close_file(&stream);
	<span class="syntax-keyword">if</span> open_err <span class="syntax-keyword">{</span> 
		print_err(open_err); 
		<span class="syntax-keyword">return</span> 1; 
	<span class="syntax-keyword">}</span>

	str := str_new();
	<span class="syntax-keyword">defer</span> str_delete(&str);
	read_bytes, read_err :: read_string(&stream, &str);
	<span class="syntax-keyword">if</span> read_err <span class="syntax-keyword">{</span> 
		print_err(read_err);
		<span class="syntax-keyword">return</span> 2;
	<span class="syntax-keyword">}</span>
	print("read % bytes\n", read_bytes);
	print("%\n", str);
	<span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>

</code></pre>
<p>Where the <em>defer</em> is used to <code>close_file</code> and <code>str_delete</code>; we can nicely couple the resource <em>allocation</em> and <em>deallocation</em> together and also handle possible errors in more elegant way. In this case, the <code>close_file</code> will be called in case of any error, while opening a file, after <code>return 1;</code> or after the last <code>return 0;</code> automatically.</p>
<h1 id="Code-Structure">Code Structure</h1>
<p>A BL code is organized into scopes similar to C++ namespaces. Each scope groups entities inside, and can limit their visibility from the outside. Scopes can be used also to avoid naming collisions. They are organized into a tree structure, where one scope may contain a bunch of other scopes. In this chapter, we describe all possible scope kinds in detail.</p>
<h2 id="Global-Scope">Global Scope</h2>
<p>The global scope is created implicitly and encloses all symbols and other scopes in the program. It's the top scope without any parent scope. You can use <code>#load</code> or <code>#import</code> directives to add symbols from other files in the global scope of our program. Consider we have two files, one called <em>utils.bl</em> containing the <em>my_print_log</em> function declared in global scope, and the other file containing the <em>main</em> function. We can use a <code>#load</code> followed by the file name to make the <em>my_print_log</em> function available in the <em>main</em>. The <code>#load</code> should be followed by the <em>filepath</em> relative to the file we're loading from, but it can be any <em>absolute</em> existing path to the other file. The <code>#import</code> is meant to be used with <a href="/book/modules">modules</a>.</p>

<pre><code><span class="syntax-comment">// utils.bl</span>
my_print_log :: <span class="syntax-keyword">fn</span> (text: string_view) <span class="syntax-keyword">{</span><span class="syntax-keyword">}</span>
</code></pre>

<pre><code><span class="syntax-comment">// main.bl</span>
<span class="syntax-directive">#load</span> "utils.bl"

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    my_print_log("Hello");
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<h3 id="Load">Load</h3>

<pre><code><span class="syntax-directive">#load</span> "&lt;path/to/your/file.bl&gt;"
</code></pre>
<p>Loads source code in a single file into the current global scope of your project. Every file is loaded only once even if we load it from multiple locations. The <em>filepath</em> may be any existing absolute or relative path, in case the path is relative, the compiler lookup the file using the following lookup order (the first hit is used):</p>
<p><b>Lookup order:</b></p>
<ul>
<li>Current file parent directory.</li>
<li>BL API directory set in <code>install-location/etc/bl.yaml</code>.</li>
<li>System <em>PATH</em> environment variable.</li>
</ul>
<h3 id="Import">Import</h3>

<pre><code><span class="syntax-directive">#import</span> "&lt;path/to/your/module&gt;"
</code></pre>
<p>The import is supposed to be used with BL <a href="/book/modules">modules</a>.</p>
<p>See also <a href="/modules/build/#moduleimportpolicy">Module Import Policy</a>.</p>
<h2 id="Named-Scope">Named Scope</h2>
<p>The named scope may be introduced in a source file if we want to prevent possible name collisions with other symbols in the global scope. In the previous example, we've introduced <code>my_print_log</code>  function, but we probably don't want to call it like this in a production code; we prefer only <code>print_log</code> name. The problem is, the <code>print_log</code> function already exists in the <em>standard library</em> and is imported by default. To fix this we may enclose our function into named scope called <em>utils</em>.</p>

<pre><code><span class="syntax-comment">// utils.bl</span>
<span class="syntax-directive">#scope</span> utils 

print_log :: <span class="syntax-keyword">fn</span> (text: string_view) <span class="syntax-keyword">{</span><span class="syntax-keyword">}</span>
</code></pre>

<pre><code><span class="syntax-comment">// main.bl</span>
<span class="syntax-directive">#load</span> "utils.bl"

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    <span class="syntax-comment">// Print is now nested in 'utils' scope.</span>
    utils.print_log("Hello");
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<p>The named scope in <em>utils.bl</em> file is now introduced by <code>#scope</code> directive followed by the scope name. Everything in the file after the <code>#scope</code> directive is added into <em>utils</em> named scope. There is currently no possibility to create named scope nested in another named scope; this restriction mainly exists only to keep the scope structure relatively flat.</p>
<p>As you can see, the <code>print_log</code> function is now accessible only through <code>.</code> operator and it's nested in the named scope called <em>utils</em>.</p>
<h2 id="Private-Scope">Private Scope</h2>
<p>The <em>private</em> scope may be created by <code>#private</code> directive in a source file, everything declared after this directive is visible only inside the file. The <em>private</em> scope may exist only once in each file. Note there is no <em>public</em> scope available in the BL everything outside the <em>private</em> scope is <em>public</em> and we cannot switch back to <em>public</em> scope once we're in the <em>private</em> one.</p>
<p>The main purpose of a <em>private</em> scope is to hide some internal implementations which should not be accessible from the outside world.</p>

<pre><code><span class="syntax-comment">// utils.bl</span>
<span class="syntax-directive">#scope</span> utils 

print_log :: <span class="syntax-keyword">fn</span> (text: string_view) <span class="syntax-keyword">{</span>
    <span class="syntax-comment">// We can access the private stuff since it's in the same file.</span>
    set_output_color(Color.BLUE);
    <span class="syntax-keyword">defer</span> set_output_color(Color.NORMAL);
    <span class="syntax-comment">// Use default print to print the message.</span>
    print(text);
<span class="syntax-keyword">}</span>

<span class="syntax-directive">#private</span>
<span class="syntax-comment">// All following code is visible only inside the current file.</span>

Color :: <span class="syntax-keyword">enum</span> <span class="syntax-keyword">{</span>
    NORMAL;
    RED;
    BLUE;
<span class="syntax-keyword">}</span>

set_output_color :: <span class="syntax-keyword">fn</span> (color: Color) <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">switch</span> color <span class="syntax-keyword">{</span>
        Color.NORMAL <span class="syntax-keyword">{</span> ... <span class="syntax-keyword">}</span>
        Color.RED <span class="syntax-keyword">{</span> ... <span class="syntax-keyword">}</span>
        Color.BLUE <span class="syntax-keyword">{</span> ... <span class="syntax-keyword">}</span>
    <span class="syntax-keyword">}</span>
<span class="syntax-keyword">}</span>
</code></pre>
<h2 id="Local-Scope">Local Scope</h2>
<p>Local scopes are created implicitly for each function since the usage of symbols, declared in the function, is strictly limited to be used only inside that function. The compiler creates local scopes also for structures, unions and enums, where the content of those is again accessible using the <code>.</code> operator.</p>
<h2 id="Using">Using</h2>
<p>The <em>using</em> statement may be added in local scopes to reduce the amount of code you have to write. It makes the content of "used" scope directly available in the scope the <em>using</em> is living in. Be careful using this feature, it may introduce symbol ambiguity and the compiler may complain.</p>
<p>Currently, the <em>using</em> supports named scopes and enums, it's not allowed for structures and unions, since it may make the code less readable.</p>

<pre><code><span class="syntax-comment">// main.bl</span>
<span class="syntax-directive">#load</span> "utils.bl"

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">using</span> utils;

    <span class="syntax-comment">// This is not valid, compiler don't known if you mean 'print_log' from the</span>
    <span class="syntax-comment">// standard library or the one from utils.bl.</span>
    print_log("Hello");
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>

<pre><code>main.bl:9:5: error(0078): Symbol is ambiguous.
   8 |     // standard library or the one from utils.bl.
&gt;  9 |     print_log("Hello");
     |     ^^^^^^^^^
  10 |     return 0;

debug.bl:38:1: First declaration found here.
   37 | /// Print debug log using current application_context `print_log_fn` function.
&gt;  38 | print_log :: fn (format: string_view, args: ...) #inline {
      | ^^^^^^^^^
   39 |     application_context.print_log_fn(PrintLogKind.MESSAGE, "", 0, format, args);

utils.bl:4:1: Another declaration found here.
   3 |
&gt;  4 | print_log :: fn (text: string_view) {
     | ^^^^^^^^^
   5 |     // We can access the private stuff since it's in the same file.
</code></pre>
<p>However, we can use this feature in <em>utils.bl</em> like this:</p>

<pre><code>set_output_color :: <span class="syntax-keyword">fn</span> (color: Color) <span class="syntax-keyword">{</span>
    <span class="syntax-keyword">using</span> Color;
    <span class="syntax-comment">// Content of Color is now available in current scope.</span>

    <span class="syntax-keyword">switch</span> color <span class="syntax-keyword">{</span>
        <span class="syntax-comment">// No need to write 'Color.' before each variant.</span>
        NORMAL <span class="syntax-keyword">{</span><span class="syntax-keyword">}</span>
        RED <span class="syntax-keyword">{</span><span class="syntax-keyword">}</span>
        BLUE <span class="syntax-keyword">{</span><span class="syntax-keyword">}</span>
    <span class="syntax-keyword">}</span>
<span class="syntax-keyword">}</span>
</code></pre>
<h1 id="Modules">Modules</h1>
<p>A module in BL is a chunk of reusable multi-platform code bundled with a configuration file in a single module <em>root</em> directory. See the following example of the <em>thread</em> module.</p>

<pre><code>thread/
  module.yaml       - module config
  _thread.win32.bl  - windows implementation
  _thread.posix.bl  - posix implementation
  thread.bl         - interface
  thread.test.bl    - unit tests
</code></pre>
<p>Modules can be imported into other projects using the <code>#import</code> directive followed by the module root directory path. The configuration file <em>module.yaml</em> is mandatory for each module and must be located in the module <em>root</em> directory. In general, the configuration file tells the compiler which source files should be loaded, which libraries are needed and what is the module version. See the module configuration example.</p>

<pre><code>version: 20221021

x86_64-pc-windows-msvc:
  src: "_thread.win32.bl"

x86_64-pc-linux-gnu:
  src: "_thread.posix.bl"

x86_64-apple-darwin:
  src: "_thread.posix.bl"

arm64-apple-darwin:
  src: "_thread.posix.bl"
</code></pre>
<p>The first in the file is the <code>version</code> of the module (usually in the format YYYYMMDD) followed by the list of all compilation targets supported by the module.  In this example, we use a different implementation for Windows. You can get a list of all supported platforms using the <code>blc --target-supported</code> command.</p>
<p>To import the <code>thread</code> module use the <em>root</em> directory path:</p>

<pre><code><span class="syntax-directive">#import</span> "path/to/module/thread"
</code></pre>
<p>See also <a href="modules_build.html#ModuleImportPolicy">Module Import Policy</a>.</p>
<p><span class="hint-note"><b>Note:</b>
Modules will be redesigned in the future to support the full set of features required by the build system. The long-term plan is to have the module configuration written directly in BL.</span></p>
<h2 id="List-of-module-config-entries">List of module config entries</h2>
<p>The configuration file entries may be <em>global</em> or <em>platform-specific</em>, see the following sections.</p>
<h3 id="Global-Options">Global Options</h3>
<p>The <em>global</em> options are applied to the module on all target platforms.</p>
<ul>
<li><code>version: &lt;N&gt;</code> - Module version number used during import to distinguish various versions of the same module, see also <code>ModuleImportPolicy</code> for more information.</li>
<li><code>supported: "[triple,...]"</code> - Optional list of target triples supported by module separated by comma. When module depends on some platform specific libraries (which are supposed to be bundled with the module), we might allow this module only on platforms we've provided the precompiled binaries for. Error is generated when module is used on target not included in this list.</li>
</ul>
<h3 id="Global-or-Platform-Specific-Options">Global or Platform-Specific Options</h3>
<p>All the following options may be applied globally or just for a specific target platform.</p>
<ul>
<li><code>src: "&lt;FILE1[;FILE2;...]&gt;"</code> - List of source file paths relative to the module <em>root</em> directory separated by <b>platform-specific</b> separator (<code>:</code> on Windows and <code>;</code> on Unix).</li>
<li><code>linker_opt: "&lt;OPTIONS&gt;"</code> - Additional runtime linker options.</li>
<li><code>linker_lib_path: "&lt;DIR1;[DIR2;...]&gt;"</code> - Additional linker lookup directories relative to the module <em>root</em> directory.</li>
<li><code>link: "&lt;LIB1[;LIB2;...]&gt;</code> - Libraries to link. Note that libraries listed here are dynamically loaded during compilation (may be executed in compile-time).</li>
</ul>

<pre><code># The version is required to be global.
version: 20221021

# Load this file on all platforms.
src: "my_file_imported_everytime.bl"

# Section specific for Windows.
x86_64-pc-windows-msvc:
  src: "my_file_only_for_windows.bl"

# Section specific for Linux.
x86_64-pc-linux-gnu:
  src: "my_file_only_for_linux.bl"
  linker_opt: "-lc -lm" # link these only on linux
</code></pre>
<h2 id="Additional-Module-Assets">Additional Module Assets</h2>
<ul>
<li>Unit tests implementation should be in <code>module-name.test.bl</code> file.</li>
<li>Additional information should be in <code>README.txt</code> file, we might provide instruction how to compile module dependencies if there are any.</li>
<li>Bundled platform specific libraries usually in folders with target triple names.</li>
</ul>
<h1 id="Libraries">Libraries</h1>
<p>TODO</p>
<h1 id="Type-Info">Type Info</h1>
<p>The full <em>runtime type introspection</em> is supported in BL. You can use <code>typeinfo(&lt;TYPE&gt;)</code> builtin function to get the runtime <a href="/modules/a/#typekind">information</a> about the <em>TYPE</em>.  The <code>typeinfo</code> returns a pointer to the type metadata included in the final binary, so there is no additional unexpected overhead involved (except the binary might be slightly bigger). The type metadata information is added lazily into the binary only for required types.</p>
<p>This feature may be handy for automatic serialization of any kind, the good example is the <a href="/modules/print/#print">print</a> which gives you automatically pretty print of any passed value or type.</p>

<pre><code>main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    <span class="syntax-comment">// yields pointer to TypeInfo constant structure</span>
    info := <span class="syntax-keyword">typeinfo</span>(s32);

    <span class="syntax-keyword">if</span> info.kind == TypeKind.INT <span class="syntax-keyword">{</span>
        <span class="syntax-comment">// safe cast to *TypeInfoInt</span>
        info_int := <span class="syntax-keyword">cast</span>(*TypeInfoInt) info;

        print("bit_count = %\n", info_int.bit_count);

        <span class="syntax-keyword">if</span> info_int.is_signed <span class="syntax-keyword">{</span>
            print("signed\n");
        <span class="syntax-keyword">}</span> <span class="syntax-keyword">else</span> <span class="syntax-keyword">{</span>
            print("unsigned\n");
        <span class="syntax-keyword">}</span>
    <span class="syntax-keyword">}</span>

    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>;
</code></pre>
<h1 id="Compiler-Builtins">Compiler Builtins</h1>
<h2 id="Variables">Variables</h2>
<p>List of builtin variables set by compiler:</p>
<ul>
<li><code>IS_DEBUG</code> Is bool immutable variable set to true when assembly is running in debug mode.</li>
<li><code>IS_COMPTIME_RUN</code> Is bool immutable variable set to true when assembly is executed in compile time.</li>
<li><code>BLC_VER_MAJOR</code> Compiler major version number.</li>
<li><code>BLC_VER_MINOR</code> Compiler minor version number.</li>
<li><code>BLC_VER_PATCH</code> Compiler patch version number.</li>
</ul>
<h2 id="Functions">Functions</h2>
<h3<code>sizeof</code></h3>

<pre><code>sizeof(&lt;expr&gt;)
</code></pre>
<p>Returns size of any expression or type in bytes.</p>
<h3<code>alignof</code></h3>

<pre><code>alignof(&lt;expr&gt;) #comptime
</code></pre>
<p>Returns alignment of any expression or type.</p>
<h3<code>typeinfo</code></h3>

<pre><code>typeinfo(&lt;expr&gt;) #comptime
</code></pre>
<p>Returns pointer to type information structure allocated on a stack.</p>
<h3<code>typeof</code></h3>

<pre><code>typeof(&lt;expr&gt;) #comptime
</code></pre>
<p>Returns type of any expression.</p>
<h3<code>compiler_error</code></h3>

<pre><code>compiler_error(message: string_view) #comptime
</code></pre>
<p>Report error in compile-time.</p>
<h3<code>compiler_warning</code></h3>

<pre><code>compiler_warning(message: string_view) #comptime
</code></pre>
<p>Report warning in compile-time.</p>
<h1 id="Documentation">Documentation</h1>
<p>Integrated self-documentation tool can be used to generate <a href="https://en.wikipedia.org/wiki/Markdown">Markdown</a> files from Biscuit source files automatically. Documentation text can be attached to a file by <code>//!</code> comment prefix or to declaration by <code>///</code> comment prefix.  Such comments will be recognized by the compiler and attached to the proper declaration or file compilation unit. Use <code>-doc</code> compiler flag followed by a list of files you want to generate documentation for. Documentation output will be written to the <code>out</code> directory into the current working directory if the <code>--doc-out-dir</code> is not specified.</p>
<p>Use marker <code>@Incomplete</code> in the documentation comment to mark it as incomplete. The compiler will warn you about symbols with incomplete documentation during generation.</p>
<p><b>Documentation rules:</b></p>
<ul>
<li>Only files listed in compiler input are used as generation input (no loaded or imported files are included).</li>
<li>Documentation is generated from AST; only a parsing pass is performed.</li>
<li>When the out directory already exists, the compiler will only append new files and override old ones in case of collision.</li>
<li>Only global and non-private declarations can be documented.</li>
<li>A declaration name and declaration itself are included automatically.</li>
<li>A single <code>md</code> file is produced for every input source file.</li>
</ul>
<p>Example of documented <code>print</code> function:</p>

<pre><code><span class="syntax-comment">/// Write string to the standard output (stdout). Format string can include format specifiers `%`</span>
<span class="syntax-comment">/// which are replaced by corresponding argument value passed in `args`. Value-string conversion is</span>
<span class="syntax-comment">/// done automatically, we can pass values of any type as an arguments, even structures or arrays.</span>
<span class="syntax-comment">///</span>
<span class="syntax-comment">/// The `print` function accepts C-like escape sequences as `\n`, `\t`, `\r`, etc.</span>
<span class="syntax-comment">///</span>
<span class="syntax-comment">/// Pointers to `Error` are dereferenced automatically; so the `print` function can print out errors</span>
<span class="syntax-comment">/// directly.</span>
<span class="syntax-comment">///</span>
<span class="syntax-comment">/// Count of printed bytes is returned.</span>
print :: <span class="syntax-keyword">fn</span> (format: string, args: ...) s32 <span class="syntax-keyword">{</span>
    buf: [PRINT_MAX_LENGTH]u8 <span class="syntax-directive">#noinit</span>;
    w := _print_impl(buf, format, args);
    __os_write(OS_STDOUT, buf.ptr, <span class="syntax-keyword">auto</span> w);
    <span class="syntax-keyword">return</span> w;
<span class="syntax-keyword">}</span>
</code></pre>
<p>Execution of <code>blc -doc print.bl</code> will produce following output:</p>

<pre><code>## print

```
print :: fn (format: string, args: ...) s32
```

Write string to the standard output (stdout). Format string can include format specifiers `%`
which are replaced by corresponding argument value passed in `args`. Value-string conversion is
done automatically, we can pass values of any type as an arguments, even structures or arrays.

The `print` function accepts C-like escape sequences as `\n`, `\t`, `\r`, etc.

Pointers to `Error` are dereferenced automatically; so the `print` function can print out errors
directly.

Count of printed bytes is returned.
</code></pre>
<h1 id="Compiler-Usage">Compiler Usage</h1>
<p>Biscuit language compiler is a standalone terminal application called <em>blc</em>.  It can be compiled from source code found on <a href="https://github.com/travisdoor/bl">GitHub</a> repository or downloaded from the home page as a binary executable (since the compiler is still under development, the binary versions may be outdated, currently <a href="/installation">compilation</a> from the source code is preferred). All three major operating systems (Windows, macOS and Linux) are supported, but current active development is done on Windows and it usually takes some time to port the latest changes to the other platforms. The compiler executable can be found in <em>bin</em> directory it's usually a good idea to add the executable location to the system <em>PATH</em> to be accessible from other locations.</p>
<p>There are several options that can be passed to the compiler.</p>
<h2 id="Compiler-Options">Compiler Options</h2>

<pre><code>blc --help

Usage:
  blc [options] [source-files]

Alternative usage:
  blc [options] &lt;-build&gt; [build-arguments]
  blc [options] &lt;-run&gt; &lt;source-file&gt; [arguments] [forwarded-arguments]

Options:
  -build                   Invoke project build pipeline. All following arguments are forwarded into the build script and ignored by compiler itself. Use as '-build [arguments]'.
  -doc                     Generate documentation and exit.
  -opt=&lt;debug|release-fast|release-small|release-with-debug-info&gt;
                           Specify binary optimization mode (use 'debug' by default).
  -release                 Specify binary optimization mode to release. (same as '-opt=release-fast')
  -run                     Execute BL program using interpreter and exit. The compiler expects &lt;source-file&gt; after '-run' flag, the file name and all following command line arguments are passed into the executed program and ignored by compiler itself. Use as '-run &lt;source-file&gt; [arguments]'.
  -shared                  Compile shared library.
  -silent-run              Execute BL program using interpreter and exit. The compiler expects &lt;source-file&gt; after '-silent-run' flag, the file name and all following command line arguments are passed into the executed program and ignored by compiler itself. Use as '-silent-run &lt;source-file&gt; [arguments]'. This flag also suppress all compiler console outputs. Basically it combines '-run' and '--silent' into a single flag. This can be useful in case the compiler is called implicitly from UNIX shebang.
  --about                  Print compiler info and exit
  --assert=&lt;default|on|off&gt;
                           Set assert mode ('default' option sets assert 'on' in debug and 'off' in release mode).
  --ast-dump               Print AST.
  --configure              Generate configuration file and exit.
  --di=&lt;dwarf|codeview&gt;    Set debug info format.
  --doc-out-dir=&lt;STRING&gt;   Set documentation output directory. (Use 'out' in current working directory by default.)
  --emit-asm               Write assembly to file.
  --emit-llvm              Write LLVM-IR to file.
  --emit-mir               Write MIR to file.
  --error-limit=&lt;N&gt;        Set maximum reported error count.
  --full-path              Report full file paths.
  --help                   Print usage information and exit.
  --lex-dump               Print tokens.
  --no-analyze             Disable analyze pass, only parse and exit.
  --no-api                 Don't load internal API.
  --no-bin                 Don't write binary to disk.
  --no-color               Disable colored output.
  --no-jobs                Enable single-thread mode.
  --no-llvm                Disable LLVM back-end.
  --no-usage-check         Disable checking of unused symbols.
  --no-warning             Ignore all warnings.
  --override-config=&lt;STRING&gt;
                           Set custom path to the 'bl.yaml' configuration file.
  --reg-split=&lt;off|on&gt;     Enable/disable splitting of structures passed into the function by value into registers.
  --run-tests              Execute all unit tests in compile time.
  --silent                 Disable compiler console logging.
  --stats                  Print compilation statistics.
  --syntax-only            Check syntax and exit.
  --target-experimental    Enable experimental compilation targets.
  --target-host            Print current host target triple and exit.
  --target-supported       Print all supported targets and exit. (Cross compilation is not allowed yet!)
  --tests-minimal-output   Reduce compile-time tests (--run-tests) output (remove results section).
  --verbose                Enable verbose mode.
  --verify-llvm            Verify LLVM IR after generation.
  --version                Print compiler version and exit.
  --vmdbg-attach           Attach compile-time execution debugger.
  --vmdbg-break-on=&lt;N&gt;     Attach compile-time execution debugger and sets break point to the MIR instruction with &lt;N&gt; id.
  --where-is-api           Print path to API folder and exit.
  --work-dir=&lt;STRING&gt;      Set current working directory. Compiler use by default the current working directory to output all files.
</code></pre>
<h2 id="Configuration">Configuration</h2>
<p>Use <code>blc --config</code> to change compiler configuration; this command generates a new <code>bl.yaml</code> configuration file containing all the needed information about your system. This configuration runs automatically in case the config file was not found.</p>
<h2 id="Execution-Status">Execution Status</h2>
<ul>
<li>After a regular compilation process <code>blc</code> return 0 on success or a numeric maximum error code on the fail.</li>
<li>When <code>-run</code> flag is specified <code>blc</code> return status returned by executed <code>main</code> function on success or numeric maximum error code on fail (compilation error or compile time execution error).</li>
<li>When <code>--run-tests</code> flag is specified <code>blc</code> returns a count of failed tests on success or a numeric maximum error code on a fail.</li>
</ul>
<h1 id="Script-mode">Script mode</h1>
<p>Programs written in BL can easily act like shell scripts on UNIX systems due to the support of <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a> character sequence specified at the first line of the entry file. The <code>-silent-run</code> option passed to the compiler reduces all compiler diagnostic output and executes the <code>main</code> function using the integrated interpreter. No output binary is produced in such a case. The following example can be directly executed in <em>bash</em>.</p>

<pre><code>#!/usr/local/bin/blc -silent-run 

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    print("Hello!!!\n");
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>

<pre><code>$ chmod +x main.bl
$ ./main.bl
</code></pre>
<p>All command line arguments are forwarded into the executed script and can be accessed via <code>command_line_arguments</code> builtin variable. The first argument contains the script name every time.</p>
<h1 id="Unit-Testing">Unit Testing</h1>
<p>TODO</p>
<h1 id="Compile-time-Debugger">Compile-time Debugger</h1>
<p><b>Warning:</b>
This feature is not complete, it's supposed to be used by compiler developers.</p>
<p>Since the compile-time execution is one of the most powerful things on BL and i.e. command-line utility scripts are executed using the interpreter almost every time, we have to provide a proper way how to debug them. In the case of the compile-time execution, no binary file is produced, so we cannot use external debuggers as gdb or Visual Studio, however, the compiler can be used for debugging directly.</p>
<p>Consider the following example program:</p>

<pre><code>my_function :: <span class="syntax-keyword">fn</span> () <span class="syntax-keyword">{</span>
    ptr: *s32 = null;
    @ptr = 10; <span class="syntax-comment">// error</span>
<span class="syntax-keyword">}</span>

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    my_function();
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<p>The mistake here is obvious, we're dereferencing the null pointer and the program will just crash during the execution with the  following error:</p>

<pre><code>$blc -run test.bl

Executing 'main' in compile time...
error: Dereferencing null pointer!

================================================================================
Obtained backtrace:
================================================================================
test.bl:3:5: Last called:
   2 |     ptr: *s32 = null;
&gt;  3 |     @ptr = 10; // error
   4 | }

test.bl:8:5: Called from:
   7 |     debugbreak;
&gt;  8 |     my_function();
   9 |     return 0;
</code></pre>
<p>To track down the error we can use the compiler built-in function <code>debugbreak</code>, causing the execution to be stopped when the interpreter reaches this call.</p>

<pre><code>my_function :: <span class="syntax-keyword">fn</span> () <span class="syntax-keyword">{</span>
    ptr: *s32 = null;
    @ptr = 10; <span class="syntax-comment">// error</span>
<span class="syntax-keyword">}</span>

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
    debugbreak; <span class="syntax-comment">// break here</span>
    my_function();
    <span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>
</code></pre>
<p>When the breakpoint is specified we must execute the program with the compile-time debugger attached to get the actual break. This can be done by the <code>--vmdbg-attach</code> command-line argument.</p>

<pre><code>$blc --vmdbg-attach -run test.bl

Executing 'main' in compile time...

Hit breakpoint in assembly 'out'.

   6 | main :: fn () s32 {
&gt;  7 |     debugbreak;
   8 |     my_function();
</code></pre>
<p>As you can see, the execution breaks on <code>debugbreak</code> call, and the debugger waits for user input, type <code>h</code> and hit <code>return</code> to get all available commands.</p>

<pre><code>: h
  h, help                             = Show this help.
  q, quit                             = Stop debugging.
  n, next                             = Step to next instruction.
  c, continue                         = Continue execution.
  p, print                            = Print current instruction.
  bt, backtrace                       = Print current backtrace.
  vs=&lt;on|off&gt;, verbose-stack=&lt;on|off&gt; = Log stack operations.
  mir=&lt;on|off&gt;, mir-mode=&lt;on|off&gt;     = Enable/disable MIR instruction level debugging.
</code></pre>
<p>Now we can step through our code, get some stack-related information, print stack traces on the user-code level, but also on MIR instruction level. Printing values of variables is supported only partially.</p>
</div>
<div class="column" id="column3">
<ul id="menu-top-level">
<li id="menu-top-level-item"><a href="#Introduction">Introduction</a></li>
<li id="menu-top-level-item"><a href="#Hello-World">Hello World</a></li>
<ul>
<li><a href="#The-Main-Function">The Main Function</a></li>
<li><a href="#Compile-&-Run">Compile & Run</a></li>
</ul>
<li id="menu-top-level-item"><a href="#Hello-Project">Hello Project</a></li>
<ul>
<li><a href="#Configuration">Configuration</a></li>
<li><a href="#Compilation">Compilation</a></li>
<li><a href="#How-It-Works">How It Works</a></li>
</ul>
<li id="menu-top-level-item"><a href="#Variables">Variables</a></li>
<ul>
<li><a href="#Syntax-And-Mutability">Syntax And Mutability</a></li>
<li><a href="#Mutability-Of-Structure-Members">Mutability Of Structure Members</a></li>
<li><a href="#Initialization">Initialization</a></li>
<li><a href="#Local">Local</a></li>
<li><a href="#Global">Global</a></li>
<li><a href="#Usage-Checks">Usage Checks</a></li>
<li><a href="#Shadowing">Shadowing</a></li>
<li><a href="#Comptime-Variables">Comptime Variables</a></li>
</ul>
<li id="menu-top-level-item"><a href="#Types">Types</a></li>
<ul>
<li><a href="#Fundamental-Types">Fundamental Types</a></li>
<li><a href="#Pointer-Type">Pointer Type</a></li>
<li><a href="#Array-Type">Array Type</a></li>
<li><a href="#String-Type">String Type</a></li>
<li><a href="#Slice">Slice</a></li>
<li><a href="#Struct-Type">Struct Type</a></li>
<li><a href="#Union-Type">Union Type</a></li>
<li><a href="#Any-Type">Any Type</a></li>
<li><a href="#Enum-Type">Enum Type</a></li>
<li><a href="#Enum-Flags-Type">Enum Flags Type</a></li>
<li><a href="#Type-Casting">Type Casting</a></li>
<li><a href="#Type-Decomposition">Type Decomposition</a></li>
</ul>
<li id="menu-top-level-item"><a href="#Functions">Functions</a></li>
<ul>
<li><a href="#Function-Arguments">Function Arguments</a></li>
<li><a href="#Return-Value">Return Value</a></li>
<li><a href="#Anonymous-Functions-And-Callbacks">Anonymous Functions And Callbacks</a></li>
<li><a href="#Function-Overloading">Function Overloading</a></li>
<li><a href="#Polymorphic-Functions">Polymorphic Functions</a></li>
<li><a href="#Function-Directives">Function Directives</a></li>
</ul>
<li id="menu-top-level-item"><a href="#Comments">Comments</a></li>
<ul>
<li><a href="#Single-line-Comments">Single-line Comments</a></li>
<li><a href="#Multi-line-Comments">Multi-line Comments</a></li>
<li><a href="#Documentation-Comments">Documentation Comments</a></li>
</ul>
<li id="menu-top-level-item"><a href="#Literals">Literals</a></li>
<ul>
<li><a href="#Simple-Literals">Simple Literals</a></li>
<li><a href="#Integer-Literals">Integer Literals</a></li>
<li><a href="#String-Literals">String Literals</a></li>
</ul>
<li id="menu-top-level-item"><a href="#Operators">Operators</a></li>
<ul>
<li><a href="#Binary-Operators">Binary Operators</a></li>
<li><a href="#Unary-Operators">Unary Operators</a></li>
</ul>
<li id="menu-top-level-item"><a href="#Flow-Control">Flow Control</a></li>
<ul>
<li><a href="#If-Else">If Else</a></li>
<li><a href="#Switch">Switch</a></li>
<li><a href="#Loop">Loop</a></li>
<li><a href="#Defer">Defer</a></li>
</ul>
<li id="menu-top-level-item"><a href="#Code-Structure">Code Structure</a></li>
<ul>
<li><a href="#Global-Scope">Global Scope</a></li>
<li><a href="#Named-Scope">Named Scope</a></li>
<li><a href="#Private-Scope">Private Scope</a></li>
<li><a href="#Local-Scope">Local Scope</a></li>
<li><a href="#Using">Using</a></li>
</ul>
<li id="menu-top-level-item"><a href="#Modules">Modules</a></li>
<ul>
<li><a href="#List-of-module-config-entries">List of module config entries</a></li>
<li><a href="#Additional-Module-Assets">Additional Module Assets</a></li>
</ul>
<li id="menu-top-level-item"><a href="#Libraries">Libraries</a></li>
<li id="menu-top-level-item"><a href="#Type-Info">Type Info</a></li>
<li id="menu-top-level-item"><a href="#Compiler-Builtins">Compiler Builtins</a></li>
<ul>
<li><a href="#Variables">Variables</a></li>
<li><a href="#Functions">Functions</a></li>
</ul>
<li id="menu-top-level-item"><a href="#Documentation">Documentation</a></li>
<li id="menu-top-level-item"><a href="#Compiler-Usage">Compiler Usage</a></li>
<ul>
<li><a href="#Compiler-Options">Compiler Options</a></li>
<li><a href="#Configuration">Configuration</a></li>
<li><a href="#Execution-Status">Execution Status</a></li>
</ul>
<li id="menu-top-level-item"><a href="#Script-mode">Script mode</a></li>
<li id="menu-top-level-item"><a href="#Unit-Testing">Unit Testing</a></li>
<li id="menu-top-level-item"><a href="#Compile-time-Debugger">Compile-time Debugger</a></li>
</ul>
</div>
</div>
</body>
</html>
