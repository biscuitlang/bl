<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="styles.css">
<link rel="icon" type="image/x-icon" href="favicon.png">
</head>
<body>
<div class="container">
<div class="column" id="column1">
<div class="logo">
<img src="biscuit_logo.svg">
<label class="version">release/0.11.0</label>
</div>
<ul id="menu-top-level">
<li id="menu-top-level-item"><a href="index.html">Home</a></li>
<li id="menu-top-level-item"><a href="installation.html">Installation</a></li>
<li id="menu-top-level-item"><a href="manual.html">Manual</a></li>
<li id="menu-top-level-item"><a href="modules.html">Modules</a></li>
<li id="menu-top-level-item"><a href="examples.html">Examples</a></li>
</ul>
</div>
<div class="column" id="column2">
<h1 id="Argument-Parser">Argument Parser</h1>
<p><code>#import "extra/argparse"</code></p>
<p>Generic command line argument parsing tool.</p>
<h3 id="Example">Example</h3>

<pre><code><span class="syntax-directive">#import</span> "extra/argparse"

MyOptLevel :: <span class="syntax-keyword">enum</span> <span class="syntax-keyword">{</span>
	DEBUG;
	RELEASE_SMALL;
	RELEASE_FAST;
<span class="syntax-keyword">}</span>

<span class="syntax-comment">// Some options we need.</span>
MyArgs :: <span class="syntax-keyword">struct</span> <span class="syntax-keyword">{</span>
	is_debug: bool;
	worker_count: s32;
	directory: string_view;
	inputs: []string_view;
	outputs: []string_view;
	optimization: MyOptLevel;
<span class="syntax-keyword">}</span>

main :: <span class="syntax-keyword">fn</span> () s32 <span class="syntax-keyword">{</span>
	<span class="syntax-keyword">using</span> argparse;

	<span class="syntax-comment">// Create and initialize new instance of argument parser.</span>
	parser: Parser;
	init(&parser, "This is cool testing application parsing command-line arguments, enjoy!");
	<span class="syntax-comment">// Don't forget to terminate it!</span>
	<span class="syntax-keyword">defer</span> terminate(&parser);

	args: MyArgs;

	<span class="syntax-comment">// Set the executable name (used in help).</span>
	set_executable_name(&parser, command_line_arguments[0]);

	<span class="syntax-comment">// Add very basic usage information.</span>
	add_usage(&parser, "[options]");

	<span class="syntax-comment">// Register positional argument prefixes for input and output files.</span>
	add_positional(&parser, &args.inputs, "--input", "-i", "List of input files.");
	add_positional(&parser, &args.outputs, "--output", "-o", "List of output files.");

	<span class="syntax-comment">// Register all other arguments.</span>
	add(&parser, &args.is_debug, "--debug", "-d", "Enable debug mode"); <span class="syntax-comment">// Boolean flag.</span>
	add(&parser, &args.worker_count, "--worker-count", "", "Count of worker threads."); <span class="syntax-comment">// Integer value.</span>
	add(&parser, &args.directory, "--dir", "", "Root directory path."); <span class="syntax-comment">// String view (no need to be preallocated).</span>
	add(&parser, &args.optimization, "--opt", "", "Optimization level."); <span class="syntax-comment">// Enumerator value.</span>

	<span class="syntax-comment">// Parse all command line arguments here.</span>
	parsed_argument_count, parse_error :: parse(&parser, command_line_arguments);
	<span class="syntax-keyword">if</span> parse_error <span class="syntax-keyword">{</span>
		<span class="syntax-comment">// Print error and show the help.</span>
		print_err(parse_error);
		print_help(&parser);
		<span class="syntax-keyword">return</span> 1;
	<span class="syntax-keyword">}</span>

	<span class="syntax-comment">// Use the parsed options.</span>
	print("\nParsed arguments: %\n", parsed_argument_count);
	print("%\n", args);
	<span class="syntax-keyword">return</span> 0;
<span class="syntax-keyword">}</span>


</code></pre>
<h3 id="Possible-application-output.">Possible application output.</h3>
<p>Note that '--help' argument was added implicitly.</p>

<pre><code>./out.exe --help -o first.txt second.txt
This is cool testing application parsing command-line arguments, enjoy!
Usage:
  out.exe [options]

Options:
  -d, --debug                   Enable debug mode
  -h, --help                    Print this help.
  -i, --input                   List of input files.
  -o, --output                  List of output files.
  --dir=&lt;STR&gt;                   Root directory path.
  --opt=&lt;DEBUG|RELEASE_SMALL|RELEASE_FAST&gt;
                                Optimization level.
  --worker-count=&lt;N&gt;            Count of worker threads.

Parsed arguments: 2
MyArgs {is_debug = false, worker_count = 0, directory = , inputs = [], outputs = [first.txt, second.txt], optimization = MyOptLevel.DEBUG}
</code></pre>
<h2 id="argparse.Parser">argparse.Parser</h2>

<pre><code>Parser :: <span class="syntax-keyword">struct</span> <span class="syntax-keyword">{</span>
    usage: [..]string_view;
    argument_list: [..]Argument;
    help: bool;
    info: string_view;
    executable_name: string_view;
    allocator: *Allocator;
<span class="syntax-keyword">}</span>
</code></pre>
<p><em>File: argparse.bl</em></p>
<h2 id="argparse.init">argparse.init</h2>

<pre><code>init :: <span class="syntax-keyword">fn</span> (parser: *Parser, info :: "", allocator : *Allocator: null) 
</code></pre>
<p>Initialize argument parser. Custom application information can be set as optional <code>info</code>, this information is later
shown in the help message printed by <code>print_help</code> function.</p>
<p>Optional <code>allocator</code> can be specified.</p>
<p>Use <code>terminate</code> function to release all resources needed by <code>parser</code>.</p>
<p><em>File: argparse.bl</em></p>
<h2 id="argparse.terminate">argparse.terminate</h2>

<pre><code>terminate :: <span class="syntax-keyword">fn</span> (parser: *Parser) 
</code></pre>
<p>Release all <code>parser</code> resources.</p>
<p><em>File: argparse.bl</em></p>
<h2 id="argparse.add">argparse.add</h2>

<pre><code>add :: <span class="syntax-keyword">fn</span> (parser: *Parser, target: *?T, long: string_view, short :: "", help :: "", is_required :: false) 
</code></pre>
<p>Add a single argument to the <code>parser</code>. Generic <code>target</code> pointer must point to the actual value modified by this
argument. Basic types as (numbers, floats, strings and bools) are supported. The <code>long</code> specifies the argument
long name (i.e. <code>--worker-count</code>) and <code>short</code> specifies the shortcut for the long name (i.e. <code>-wc</code>). The <code>short</code>
name is optional. The <code>help</code> is optional user friendly hint message printed with help. In case <code>is_required</code> is
<code>true</code>, the argument must be provided by user every time.</p>
<p><span class="hint-note"><b>Note:</b>
String values must be allocated before any parsing is done.</span></p>
<p><span class="hint-warning"><b>Warning:</b>
Argument parser internally does NOT duplicate any argument related metadata (i.e. long name).</span></p>
<p><em>File: argparse.bl</em></p>
<h2 id="argparse.add_positional">argparse.add_positional</h2>

<pre><code>add_positional :: <span class="syntax-keyword">fn</span> (parser: *Parser, target: *[]string_view, long: string_view, short :: "", help :: "", is_required :: false) 
</code></pre>
<p>Add positional argument prefix to the <code>parser</code>. In case such prefix argument is parsed from the input arguments, all following
input argument entries are added into <code>target</code> list (no duplication is done). All following input arguments are added until parser
hits some known argument name or the input argument list is empty.
@Incomplete: Example</p>
<p><em>File: argparse.bl</em></p>
<h2 id="argparse.add_usage">argparse.add_usage</h2>

<pre><code>add_usage :: <span class="syntax-keyword">fn</span> (parser: *Parser, usage: string_view) 
</code></pre>
<p>Add usage string message listed in <code>Usage</code> section in the help message.</p>
<p><em>File: argparse.bl</em></p>
<h2 id="argparse.set_executable_name">argparse.set_executable_name</h2>

<pre><code>set_executable_name :: <span class="syntax-keyword">fn</span> (parser: *Parser, name: string_view) 
</code></pre>
<p>Sets the executable name used in help message.</p>
<p><em>File: argparse.bl</em></p>
<h2 id="argparse.parse">argparse.parse</h2>

<pre><code>parse :: <span class="syntax-keyword">fn</span> (parser: *Parser, args: []string_view, first_arg_index :: 1) (parsed_arguments_count: s32, result: Error)
</code></pre>
<p>Start parsing of <code>args</code> argument list using the <code>parser</code> configuration. The <code>first_arg_index</code> can be used to skip
first <code>N</code> entries in the <code>args</code> list (one by default to skip usual executable name in case of command line arguments are
beeing parsed).</p>
<p>Returns count of successfully parsed arguments or an error. Client side should handle error cases gracefully (i.e. by printing help
message or terminating the application).</p>
<p><em>File: argparse.bl</em></p>
<h2 id="argparse.print_help">argparse.print_help</h2>

<pre><code>print_help :: <span class="syntax-keyword">fn</span> (parser: *Parser) 
</code></pre>
<p>Print formated help message. The <code>parser</code> should be already initialized with all argumenst.</p>
<p><em>File: argparse.bl</em></p>
</div>
<div class="column" id="column3">
<ul id="menu-top-level">
<li id="menu-top-level-item"><a href="#Argument-Parser">Argument Parser</a></li>
<ul>
<li><a href="#argparse.Parser">argparse.Parser</a></li>
<li><a href="#argparse.init">argparse.init</a></li>
<li><a href="#argparse.terminate">argparse.terminate</a></li>
<li><a href="#argparse.add">argparse.add</a></li>
<li><a href="#argparse.add_positional">argparse.add_positional</a></li>
<li><a href="#argparse.add_usage">argparse.add_usage</a></li>
<li><a href="#argparse.set_executable_name">argparse.set_executable_name</a></li>
<li><a href="#argparse.parse">argparse.parse</a></li>
<li><a href="#argparse.print_help">argparse.print_help</a></li>
</ul>
</ul>
</div>
</div>
</body>
</html>
